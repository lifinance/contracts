{
  "language": "Solidity",
  "sources": {
    "src/Periphery/GasZipPeriphery.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IGasZip } from \"../Interfaces/IGasZip.sol\";\nimport { IWhitelistManagerFacet } from \"../Interfaces/IWhitelistManagerFacet.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { WithdrawablePeriphery } from \"../Helpers/WithdrawablePeriphery.sol\";\nimport { SafeTransferLib } from \"solady/utils/SafeTransferLib.sol\";\nimport { InvalidCallData, ContractCallNotAllowed, InvalidConfig } from \"../Errors/GenericErrors.sol\";\n\n/// @title GasZipPeriphery\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality to swap ERC20 tokens to use the gas.zip protocol as a pre-bridge step (https://www.gas.zip/)\n/// @custom:version 1.0.2\ncontract GasZipPeriphery is ILiFi, WithdrawablePeriphery {\n    using SafeTransferLib for address;\n\n    /// State ///\n    IGasZip public immutable GAS_ZIP_ROUTER;\n    address public immutable LIFI_DIAMOND;\n    uint256 internal constant MAX_CHAINID_LENGTH_ALLOWED = 16;\n\n    bytes4 internal constant APPROVE_TO_ONLY_SELECTOR = 0xffffffff;\n\n    /// Errors ///\n    error TooManyChainIds();\n    error SwapOutputMustBeNative();\n\n    /// Constructor ///\n    constructor(\n        address _gasZipRouter,\n        address _liFiDiamond,\n        address _owner\n    ) WithdrawablePeriphery(_owner) {\n        if (\n            _gasZipRouter == address(0) ||\n            _liFiDiamond == address(0) ||\n            _owner == address(0)\n        ) {\n            revert InvalidConfig();\n        }\n        GAS_ZIP_ROUTER = IGasZip(_gasZipRouter);\n        LIFI_DIAMOND = _liFiDiamond;\n    }\n\n    /// @notice Swaps ERC20 tokens to native and deposits these native tokens in the GasZip router contract\n    ///         Swaps are allowed via any whitelisted contract from the Diamond's WhitelistManagerFacet\n    /// @dev this function can be used as a LibSwap.SwapData protocol step to combine it with any other bridge\n    /// @param _swapData The swap data that executes the swap from ERC20 to native\n    /// @param _gasZipData contains information about which chains gas should be sent to\n    function depositToGasZipERC20(\n        LibSwap.SwapData calldata _swapData,\n        IGasZip.GasZipData calldata _gasZipData\n    ) public {\n        if (_swapData.receivingAssetId != address(0)) {\n            revert SwapOutputMustBeNative();\n        }\n\n        IWhitelistManagerFacet whitelistManager = IWhitelistManagerFacet(\n            LIFI_DIAMOND\n        );\n\n        /// This check ensures that either the swap execution contract (_swapData.callTo)\n        /// is whitelisted for the specific call or the token spender (_swapData.approveTo)\n        /// is whitelisted using the APPROVE_TO_ONLY_SELECTOR (0xffffffff).\n        /// This prevents allowance leaks while supporting DEXs where the spender and\n        /// the caller addresses are different.\n        if (\n            !whitelistManager.isContractSelectorWhitelisted(\n                _swapData.callTo,\n                bytes4(_swapData.callData[:4])\n            ) ||\n            (_swapData.approveTo != _swapData.callTo &&\n                !whitelistManager.isContractSelectorWhitelisted(\n                    _swapData.approveTo,\n                    APPROVE_TO_ONLY_SELECTOR\n                ))\n        ) {\n            revert ContractCallNotAllowed();\n        }\n\n        // deposit ERC20 asset from diamond\n        LibAsset.depositAsset(_swapData.sendingAssetId, _swapData.fromAmount);\n\n        // max approve to DEX, if not already done\n        LibAsset.maxApproveERC20(\n            IERC20(_swapData.sendingAssetId),\n            _swapData.approveTo,\n            _swapData.fromAmount\n        );\n\n        uint256 preSwapBal = address(this).balance;\n\n        // execute swap using the whitelisted DEX\n        // Note on slippage protection:\n        // 1. Individual swap slippage is protected via minAmountOut parameter in _swapData.callData\n        // 2. Final output amount slippage is checked at diamond contract level in SwapperV2._depositAndSwap()\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call(\n            _swapData.callData\n        );\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n\n        uint256 swapOutputAmount = address(this).balance - preSwapBal;\n\n        // deposit native tokens to Gas.zip protocol\n        depositToGasZipNative(_gasZipData, swapOutputAmount);\n    }\n\n    /// @notice Deposits native tokens to the GasZip router contract\n    /// @dev this function can be used as a LibSwap.SwapData protocol step to combine it with any other bridge\n    /// @param _gasZipData contains information which chains and address gas should be sent to\n    /// @param _amount the total amount to be deposited (will be split equally across all chains)\n    function depositToGasZipNative(\n        IGasZip.GasZipData calldata _gasZipData,\n        uint256 _amount\n    ) public payable {\n        // make sure that receiverAddress is not 0\n        if (_gasZipData.receiverAddress == bytes32(0))\n            revert InvalidCallData();\n\n        // We are depositing to a new contract that supports deposits for EVM chains + Solana (therefore 'receiver' address is bytes32)\n        GAS_ZIP_ROUTER.deposit{ value: _amount }(\n            _gasZipData.destinationChains,\n            _gasZipData.receiverAddress\n        );\n\n        // return unused native value to msg.sender, if any\n        // this is required due to LI.FI backend-internal requirements (money flow)\n        uint256 remainingNativeBalance = address(this).balance;\n        if (remainingNativeBalance > 0) {\n            msg.sender.safeTransferETH(remainingNativeBalance);\n        }\n    }\n\n    /// @dev Returns a value that signals to Gas.zip to which chains gas should be sent in equal parts\n    /// @param _chainIds a list of Gas.zip-specific chainIds (not the original chainIds),\n    ///                 see https://dev.gas.zip/gas/chain-support/outbound\n    function getDestinationChainsValue(\n        uint8[] calldata _chainIds\n    ) external pure returns (uint256 destinationChains) {\n        uint256 length = _chainIds.length;\n\n        if (length > MAX_CHAINID_LENGTH_ALLOWED) revert TooManyChainIds();\n\n        for (uint256 i; i < length; ++i) {\n            // Shift destinationChains left by 16 bits and add the next chainID\n            destinationChains =\n                (destinationChains << 16) |\n                uint256(_chainIds[i]);\n        }\n    }\n\n    // Required to receive ETH from ERC20-to-Native swaps\n    receive() external payable {}\n}"
    }
  },
  "settings": {
    "remappings": [
      "lifi/=src/",
      "solady/=lib/solady/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/src/",
      "permit2/=lib/Permit2/src/",
      "forge-std/=lib/forge-std/src/",
      "test/=test/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.bytecode.sourceMap",
          "evm.deployedBytecode.sourceMap",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
