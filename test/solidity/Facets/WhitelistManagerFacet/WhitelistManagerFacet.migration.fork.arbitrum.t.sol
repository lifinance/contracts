// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity ^0.8.17;

import { Test } from "forge-std/Test.sol";
import { DiamondCutFacet } from "lifi/Facets/DiamondCutFacet.sol";
import { WhitelistManagerFacet } from "lifi/Facets/WhitelistManagerFacet.sol";
import { OwnershipFacet } from "lifi/Facets/OwnershipFacet.sol";
import { DiamondLoupeFacet } from "lifi/Facets/DiamondLoupeFacet.sol";
import { UnAuthorized, ExternalCallFailed } from "lifi/Errors/GenericErrors.sol";

/// @notice Interface for DexManagerFacet's functions (backward compatibility)
interface IDexManagerFacet {
    function approvedDexs() external view returns (address[] memory addresses);
    function isFunctionApproved(
        bytes4 _signature
    ) external view returns (bool approved);
}

/// @title WhitelistManagerFacet Migration Fork Test (Arbitrum)
/// @notice Tests the migration of WhitelistManagerFacet on Arbitrum using a fork
/// @dev This test:
/// 1. Forks Arbitrum from the latest block
/// 2. Uses the production diamond address
/// 3. Executes a diamond cut to add the WhitelistManagerFacet (already deployed)
/// 4. Runs assertions to verify the migration was successful
contract WhitelistManagerFacetMigrationForkArbitrumTest is Test {
    // Arbitrum addresses
    address internal constant DIAMOND_ARBITRUM =
        0x1231DEB6f5749EF6cE6943a275A1D3E7486F4EaE;
    address internal constant TIMELOCK_ARBITRUM =
        0x5604A94A3438C3074EFFF803fab14B7244fe4E29;
    address internal constant WHITELIST_MANAGER_FACET_ARBITRUM =
        0xAc0535C49A5CD8Fa0935968702D500BC38589232;

    // Deprecated function selectors (same for all networks)
    // These selectors were part of the old whitelist but should NOT be whitelisted after migration
    bytes4 internal constant DEPRECATED_SELECTOR_1 = 0x00a32e6c;
    bytes4 internal constant DEPRECATED_SELECTOR_2 = 0x04204ceb;
    bytes4 internal constant DEPRECATED_SELECTOR_3 = 0x04e45aaf;

    // Function selectors that should be whitelisted on Arbitrum (from whitelist.json)
    bytes4 internal constant WHITELISTED_SELECTOR_1 = 0x54bacd13;
    bytes4 internal constant WHITELISTED_SELECTOR_2 = 0x7617b389;
    bytes4 internal constant WHITELISTED_SELECTOR_3 = 0xf87dc1b7;

    // DEX contract-selector pairs that should be whitelisted on Arbitrum (from whitelist.json DEXS section)
    address internal constant DEX_CONTRACT_1 =
        0x88CBf433471A0CD8240D2a12354362988b4593E5;
    bytes4 internal constant DEX_CONTRACT_1_SELECTOR_1 = 0x54bacd13;
    bytes4 internal constant DEX_CONTRACT_1_SELECTOR_2 = 0xf87dc1b7;
    bytes4 internal constant DEX_CONTRACT_1_SELECTOR_3 = 0x1e6d24c2;
    address internal constant DEX_CONTRACT_2 =
        0x3B6067D4CAa8A14c63fdBE6318F27A0bBc9F9237;
    bytes4 internal constant DEX_CONTRACT_2_SELECTOR_1 = 0x7617b389;
    address internal constant DEX_CONTRACT_3 =
        0xe05dd51e4eB5636f4f0E8e7Fbe82eA31a2ecef16;
    bytes4 internal constant DEX_CONTRACT_3_SELECTOR_1 = 0xa8676443;
    bytes4 internal constant DEX_CONTRACT_3_SELECTOR_2 = 0x301a3720;
    bytes4 internal constant DEX_CONTRACT_3_SELECTOR_3 = 0x94cfab17;

    // PERIPHERY contract-selector pairs that should be whitelisted on Arbitrum (from whitelist.json PERIPHERY section)
    address internal constant PERIPHERY_CONTRACT_1 =
        0xB0210dE78E28e2633Ca200609D9f528c13c26cD9;
    bytes4 internal constant PERIPHERY_CONTRACT_1_SELECTOR_1 = 0xe0cbc5f2;
    bytes4 internal constant PERIPHERY_CONTRACT_1_SELECTOR_2 = 0xeedd56e1;
    address internal constant PERIPHERY_CONTRACT_2 =
        0xC18D9E84b8687A2645447A61e52c455Dac1675e1;
    bytes4 internal constant PERIPHERY_CONTRACT_2_SELECTOR_1 = 0x0e8ae67f;
    bytes4 internal constant PERIPHERY_CONTRACT_2_SELECTOR_2 = 0x332d746b;
    address internal constant PERIPHERY_CONTRACT_3 =
        0x7339d0d71DD79FE3Bc4A2650F7E025ffeac170FA;
    bytes4 internal constant PERIPHERY_CONTRACT_3_SELECTOR_1 = 0x1078c579;
    bytes4 internal constant PERIPHERY_CONTRACT_3_SELECTOR_2 = 0xa7a4a271;

    // ApproveTo-only addresses for Arbitrum (from whitelist.json)
    // These addresses only have the 0xffffffff selector (approveTo-only)
    address internal constant APPROVE_TO_ONLY_ADDRESS_1 =
        0xA867241cDC8d3b0C07C85cC06F25a0cD3b5474d8;
    address internal constant APPROVE_TO_ONLY_ADDRESS_2 =
        0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57;
    address internal constant APPROVE_TO_ONLY_ADDRESS_3 =
        0x216B4B4Ba9F3e719726886d34a177484278Bfcae;

    // ApproveTo-only selector (special selector for approveTo-only contracts)
    bytes4 internal constant APPROVE_TO_ONLY_SELECTOR = 0xffffffff;

    // Expected address count for Arbitrum (from whitelist.json - source of truth)
    // Includes addresses from both DEXS and PERIPHERY sections
    uint256 internal constant EXPECTED_ADDRESS_COUNT_ARBITRUM = 32;

    // Expected selector count for Arbitrum (from whitelist.json - source of truth)
    // Includes all unique function selectors (including 0xffffffff for approveTo-only contracts)
    // From both DEXS and PERIPHERY sections
    uint256 internal constant EXPECTED_SELECTOR_COUNT_ARBITRUM = 79;

    // Expected total contract-selector pairs count for Arbitrum (from whitelist.json - source of truth)
    // Includes pairs from both DEXS and PERIPHERY sections
    // Note: If an address appears in both DEXS and PERIPHERY, selectors are merged (not counted twice)
    uint256 internal constant EXPECTED_TOTAL_PAIRS_COUNT_ARBITRUM = 106;

    // This will be filled in by the user with the actual call data
    bytes internal constant DIAMOND_CUT_CALLDATA =
        hex"1f931c1c0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000ac0535c49a5cd8fa0935968702d500bc38589232000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000ac0535c49a5cd8fa0935968702d500bc3858923200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000a1171c0070000000000000000000000000000000000000000000000000000000000816c97000000000000000000000000000000000000000000000000000000006d0280270000000000000000000000000000000000000000000000000000000090f3d77b0000000000000000000000000000000000000000000000000000000094ddf6630000000000000000000000000000000000000000000000000000000013f44d10000000000000000000000000000000000000000000000000000000009baf00f90000000000000000000000000000000000000000000000000000000056977cc000000000000000000000000000000000000000000000000000000000b06faf620000000000000000000000000000000000000000000000000000000051fed648000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003484f08ad6eb00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001f2000000000000000000000000000000000000000000000000000000000000000d4000000000000000000000000000000000000000000000000000000000000000000a32e6c0000000000000000000000000000000000000000000000000000000001617fab0000000000000000000000000000000000000000000000000000000003b87e5f0000000000000000000000000000000000000000000000000000000004204ceb0000000000000000000000000000000000000000000000000000000004e45aaf000000000000000000000000000000000000000000000000000000000502b1c50000000000000000000000000000000000000000000000000000000007ed23790000000000000000000000000000000000000000000000000000000008298b5a00000000000000000000000000000000000000000000000000000000083001ba0000000000000000000000000000000000000000000000000000000009b81346000000000000000000000000000000000000000000000000000000000a512416000000000000000000000000000000000000000000000000000000000b86a4c1000000000000000000000000000000000000000000000000000000000c307f76000000000000000000000000000000000000000000000000000000000d5f0e3b000000000000000000000000000000000000000000000000000000001078c57900000000000000000000000000000000000000000000000000000000117aa6770000000000000000000000000000000000000000000000000000000011bcc81e00000000000000000000000000000000000000000000000000000000123456780000000000000000000000000000000000000000000000000000000012aa3caf00000000000000000000000000000000000000000000000000000000160e8be30000000000000000000000000000000000000000000000000000000017c2067700000000000000000000000000000000000000000000000000000000188ac35d0000000000000000000000000000000000000000000000000000000018cbafe50000000000000000000000000000000000000000000000000000000019367472000000000000000000000000000000000000000000000000000000001a01c532000000000000000000000000000000000000000000000000000000001b113d4d000000000000000000000000000000000000000000000000000000001c58db4f000000000000000000000000000000000000000000000000000000001e6d24c2000000000000000000000000000000000000000000000000000000001eacd35f000000000000000000000000000000000000000000000000000000001f0464d1000000000000000000000000000000000000000000000000000000001fc307ee0000000000000000000000000000000000000000000000000000000021025a06000000000000000000000000000000000000000000000000000000002143d82c000000000000000000000000000000000000000000000000000000002213bc0b0000000000000000000000000000000000000000000000000000000022dca3d70000000000000000000000000000000000000000000000000000000023856bc30000000000000000000000000000000000000000000000000000000024856bc30000000000000000000000000000000000000000000000000000000024dd64830000000000000000000000000000000000000000000000000000000025e651ed000000000000000000000000000000000000000000000000000000002646478b0000000000000000000000000000000000000000000000000000000027f9e409000000000000000000000000000000000000000000000000000000002a197298000000000000000000000000000000000000000000000000000000002bf6e9ec000000000000000000000000000000000000000000000000000000002e95b6c8000000000000000000000000000000000000000000000000000000002fa1164700000000000000000000000000000000000000000000000000000000301a37200000000000000000000000000000000000000000000000000000000030eef8bd0000000000000000000000000000000000000000000000000000000032af31390000000000000000000000000000000000000000000000000000000033320de3000000000000000000000000000000000000000000000000000000003593564c000000000000000000000000000000000000000000000000000000003598d8ab000000000000000000000000000000000000000000000000000000003865bde60000000000000000000000000000000000000000000000000000000038ed1739000000000000000000000000000000000000000000000000000000003b635ce4000000000000000000000000000000000000000000000000000000003ccfd60b000000000000000000000000000000000000000000000000000000003cdf133f000000000000000000000000000000000000000000000000000000003eca9c0a000000000000000000000000000000000000000000000000000000003f0bde2500000000000000000000000000000000000000000000000000000000414bf38900000000000000000000000000000000000000000000000000000000415565b00000000000000000000000000000000000000000000000000000000042712a670000000000000000000000000000000000000000000000000000000045977d03000000000000000000000000000000000000000000000000000000004629fd850000000000000000000000000000000000000000000000000000000046c67b6d00000000000000000000000000000000000000000000000000000000472b43f300000000000000000000000000000000000000000000000000000000476357fe0000000000000000000000000000000000000000000000000000000047f8bd4100000000000000000000000000000000000000000000000000000000492289780000000000000000000000000000000000000000000000000000000049404b7c0000000000000000000000000000000000000000000000000000000049616997000000000000000000000000000000000000000000000000000000004a25d94a000000000000000000000000000000000000000000000000000000004d914979000000000000000000000000000000000000000000000000000000004dcebcba000000000000000000000000000000000000000000000000000000005023b4df000000000000000000000000000000000000000000000000000000005028bb95000000000000000000000000000000000000000000000000000000005161b9660000000000000000000000000000000000000000000000000000000054bacd130000000000000000000000000000000000000000000000000000000054e3f31b0000000000000000000000000000000000000000000000000000000057eb8db40000000000000000000000000000000000000000000000000000000058f151000000000000000000000000000000000000000000000000000000000059e50fed000000000000000000000000000000000000000000000000000000005a099843000000000000000000000000000000000000000000000000000000005ae401dc000000000000000000000000000000000000000000000000000000005c11d795000000000000000000000000000000000000000000000000000000005e94e28d000000000000000000000000000000000000000000000000000000005f3bd1c80000000000000000000000000000000000000000000000000000000062e238bb000000000000000000000000000000000000000000000000000000006678ec1f00000000000000000000000000000000000000000000000000000000676528d1000000000000000000000000000000000000000000000000000000006af479b2000000000000000000000000000000000000000000000000000000006b58f2f0000000000000000000000000000000000000000000000000000000006be92b89000000000000000000000000000000000000000000000000000000006e5129d100000000000000000000000000000000000000000000000000000000715018a60000000000000000000000000000000000000000000000000000000072c8913d0000000000000000000000000000000000000000000000000000000073fc44570000000000000000000000000000000000000000000000000000000074ef98d9000000000000000000000000000000000000000000000000000000007515d97c000000000000000000000000000000000000000000000000000000007617b38900000000000000000000000000000000000000000000000000000000762b15620000000000000000000000000000000000000000000000000000000077725df60000000000000000000000000000000000000000000000000000000078e3214f00000000000000000000000000000000000000000000000000000000791ac947000000000000000000000000000000000000000000000000000000007a1eb1b9000000000000000000000000000000000000000000000000000000007a42416a000000000000000000000000000000000000000000000000000000007bf2d6d4000000000000000000000000000000000000000000000000000000007c025200000000000000000000000000000000000000000000000000000000007f457675000000000000000000000000000000000000000000000000000000007ff36ab500000000000000000000000000000000000000000000000000000000803ba26d00000000000000000000000000000000000000000000000000000000817917880000000000000000000000000000000000000000000000000000000083800a8e0000000000000000000000000000000000000000000000000000000083bd37f90000000000000000000000000000000000000000000000000000000084a7f3dd0000000000000000000000000000000000000000000000000000000084bd6d2900000000000000000000000000000000000000000000000000000000862738f9000000000000000000000000000000000000000000000000000000008765432100000000000000000000000000000000000000000000000000000000876a02f6000000000000000000000000000000000000000000000000000000008770ba91000000000000000000000000000000000000000000000000000000008803dbee000000000000000000000000000000000000000000000000000000008980041a0000000000000000000000000000000000000000000000000000000089af926a000000000000000000000000000000000000000000000000000000008a657e67000000000000000000000000000000000000000000000000000000008af033fb000000000000000000000000000000000000000000000000000000008b71ae6c000000000000000000000000000000000000000000000000000000008fd8d1bb0000000000000000000000000000000000000000000000000000000090411a32000000000000000000000000000000000000000000000000000000009169558600000000000000000000000000000000000000000000000000000000922c8daa0000000000000000000000000000000000000000000000000000000094cfab17000000000000000000000000000000000000000000000000000000009570eeee00000000000000000000000000000000000000000000000000000000987e7d8e000000000000000000000000000000000000000000000000000000009a2967d2000000000000000000000000000000000000000000000000000000009b2c0a37000000000000000000000000000000000000000000000000000000009cbd7f6200000000000000000000000000000000000000000000000000000000a22c27fe00000000000000000000000000000000000000000000000000000000a2a1623d00000000000000000000000000000000000000000000000000000000a5669eae00000000000000000000000000000000000000000000000000000000a5be382e00000000000000000000000000000000000000000000000000000000a6886da900000000000000000000000000000000000000000000000000000000a76dfc3b00000000000000000000000000000000000000000000000000000000a76f4eb600000000000000000000000000000000000000000000000000000000a7a4a27100000000000000000000000000000000000000000000000000000000a816ca9200000000000000000000000000000000000000000000000000000000a867644300000000000000000000000000000000000000000000000000000000a94e78ef00000000000000000000000000000000000000000000000000000000aacdd80f00000000000000000000000000000000000000000000000000000000ac9650d800000000000000000000000000000000000000000000000000000000b043118200000000000000000000000000000000000000000000000000000000b096f38600000000000000000000000000000000000000000000000000000000b22f4db800000000000000000000000000000000000000000000000000000000b35d7e7300000000000000000000000000000000000000000000000000000000b56c966300000000000000000000000000000000000000000000000000000000b6f9de9500000000000000000000000000000000000000000000000000000000b7c5277700000000000000000000000000000000000000000000000000000000b80c2f0900000000000000000000000000000000000000000000000000000000b858183f00000000000000000000000000000000000000000000000000000000b94c360900000000000000000000000000000000000000000000000000000000ba3f216500000000000000000000000000000000000000000000000000000000bc80f1a800000000000000000000000000000000000000000000000000000000c04b8d5900000000000000000000000000000000000000000000000000000000c43c9ef600000000000000000000000000000000000000000000000000000000c4af5a7400000000000000000000000000000000000000000000000000000000c57559dd00000000000000000000000000000000000000000000000000000000c63113ad00000000000000000000000000000000000000000000000000000000c6aabf8400000000000000000000000000000000000000000000000000000000ce8d3bde00000000000000000000000000000000000000000000000000000000cf81464b00000000000000000000000000000000000000000000000000000000d0a3b66500000000000000000000000000000000000000000000000000000000d0e30db000000000000000000000000000000000000000000000000000000000d33721a500000000000000000000000000000000000000000000000000000000d46cadbc00000000000000000000000000000000000000000000000000000000d4ef38de00000000000000000000000000000000000000000000000000000000d57360fc00000000000000000000000000000000000000000000000000000000d6ed22e600000000000000000000000000000000000000000000000000000000d85ca17300000000000000000000000000000000000000000000000000000000d9627aa400000000000000000000000000000000000000000000000000000000da1a5f4200000000000000000000000000000000000000000000000000000000da35bb0d00000000000000000000000000000000000000000000000000000000db3e219800000000000000000000000000000000000000000000000000000000dd34370000000000000000000000000000000000000000000000000000000000dd9c5f9600000000000000000000000000000000000000000000000000000000def6566900000000000000000000000000000000000000000000000000000000e066efdf00000000000000000000000000000000000000000000000000000000e0cbc5f200000000000000000000000000000000000000000000000000000000e21fd0e900000000000000000000000000000000000000000000000000000000e3665a4300000000000000000000000000000000000000000000000000000000e37ed25600000000000000000000000000000000000000000000000000000000e3ead59e00000000000000000000000000000000000000000000000000000000e449022e00000000000000000000000000000000000000000000000000000000e5d7bde600000000000000000000000000000000000000000000000000000000e8bb3b6c00000000000000000000000000000000000000000000000000000000e9406cf400000000000000000000000000000000000000000000000000000000ee62320400000000000000000000000000000000000000000000000000000000eedd56e100000000000000000000000000000000000000000000000000000000efae576b00000000000000000000000000000000000000000000000000000000f28c049800000000000000000000000000000000000000000000000000000000f2fde38b00000000000000000000000000000000000000000000000000000000f35b473300000000000000000000000000000000000000000000000000000000f35cae9000000000000000000000000000000000000000000000000000000000f52e33f500000000000000000000000000000000000000000000000000000000f78dc25300000000000000000000000000000000000000000000000000000000f7fcd38400000000000000000000000000000000000000000000000000000000f87dc1b700000000000000000000000000000000000000000000000000000000f8be52e100000000000000000000000000000000000000000000000000000000f970cf6400000000000000000000000000000000000000000000000000000000fa461e3300000000000000000000000000000000000000000000000000000000fb3bdb4100000000000000000000000000000000000000000000000000000000fc37415700000000000000000000000000000000000000000000000000000000ff84aafa00000000000000000000000000000000000000000000000000000000ffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000a867241cdc8d3b0c07c85cc06f25a0cd3b5474d800000000000000000000000088cbf433471a0cd8240d2a12354362988b4593e50000000000000000000000003b6067d4caa8a14c63fdbe6318f27a0bbc9f9237000000000000000000000000e05dd51e4eb5636f4f0e8e7fbe82ea31a2ecef1600000000000000000000000081bbba46b9fcf04ab13314136b895b15291f0462000000000000000000000000e95f6eaeae1e4d650576af600b33d9f7e5f9f7fd000000000000000000000000def171fe48cf0115b1d80b88dc8eab59176fee570000000000000000000000006a000f20005980200259b80c5102003040001068000000000000000000000000216b4b4ba9f3e719726886d34a177484278bfcae000000000000000000000000f75584ef6673ad213a685a1b58cc0330b8ea22cf000000000000000000000000a669e7a0d4b3e4fa48af2de86bd4cd7126be4e13000000000000000000000000111111125421ca6dc452d289314280a0f8842a650000000000000000000000001111111254eeb25477b68fb85ed929f73a9605820000000000000000000000006352a56caadc4f1e25cd6c75970fa768a3304e640000000000000000000000000000000000001ff3684f28c67538d4d072c227340000000000000000000000006131b5fae19ea4f9d964eac0408e4408b66337b50000000000000000000000008189afcc5b73dc90600fee92e5267aff1d1928840000000000000000000000009c6522117e2ed1fe5bdb72bb0ed5e3f2bde7dbe0000000000000000000000000fc506aaa1340b4dedffd88be278bee058952d674000000000000000000000000544ba588efd839d2692fc31ea991cd39993c135f000000000000000000000000f2614a233c7c3e7f08b1f887ba133a13f1eb2c5500000000000000000000000085cd07ea01423b1e937929b44e4ad8c40bbb5e71000000000000000000000000ac4c6e212a361c968f1725b4d055b47e63f80b75000000000000000000000000bbbbbbb520d69a9775e85b458c58c648259fad5f0000000000000000000000006088d94c5a40cecd3ae2d4e0710ca687b91c61d000000000000000000000000070cbb871e8f30fc8ce23609e9e0ea87b6b222f580000000000000000000000005e2f47bd7d4b357fcfd0bb224eb665773b1b98010000000000000000000000003608c8186ff3dca322deefb8c27162162d581081000000000000000000000000b0210de78e28e2633ca200609d9f528c13c26cd9000000000000000000000000c18d9e84b8687a2645447a61e52c455dac1675e10000000000000000000000007339d0d71dd79fe3bc4a2650f7e025ffeac170fa0000000000000000000000005215e9fd223bc909083fbdb2860213873046e45d00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000044000000000000000000000000000000000000000000000000000000000000004e0000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000000000000000000000000000000000005a000000000000000000000000000000000000000000000000000000000000005e0000000000000000000000000000000000000000000000000000000000000062000000000000000000000000000000000000000000000000000000000000006600000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000084000000000000000000000000000000000000000000000000000000000000008e000000000000000000000000000000000000000000000000000000000000009800000000000000000000000000000000000000000000000000000000000000aa00000000000000000000000000000000000000000000000000000000000000c400000000000000000000000000000000000000000000000000000000000000d600000000000000000000000000000000000000000000000000000000000000da00000000000000000000000000000000000000000000000000000000000000e200000000000000000000000000000000000000000000000000000000000000e800000000000000000000000000000000000000000000000000000000000000ec00000000000000000000000000000000000000000000000000000000000000f200000000000000000000000000000000000000000000000000000000000000f800000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000108000000000000000000000000000000000000000000000000000000000000010e0000000000000000000000000000000000000000000000000000000000000112000000000000000000000000000000000000000000000000000000000000011e0000000000000000000000000000000000000000000000000000000000000122000000000000000000000000000000000000000000000000000000000000012e000000000000000000000000000000000000000000000000000000000000013c00000000000000000000000000000000000000000000000000000000000001420000000000000000000000000000000000000000000000000000000000000148000000000000000000000000000000000000000000000000000000000000014e00000000000000000000000000000000000000000000000000000000000000001ffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000454bacd1300000000000000000000000000000000000000000000000000000000f87dc1b7000000000000000000000000000000000000000000000000000000001e6d24c2000000000000000000000000000000000000000000000000000000005028bb950000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017617b389000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003a867644300000000000000000000000000000000000000000000000000000000301a37200000000000000000000000000000000000000000000000000000000094cfab17000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e3665a4300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000157eb8db4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ce3ead59e00000000000000000000000000000000000000000000000000000000d85ca173000000000000000000000000000000000000000000000000000000001a01c53200000000000000000000000000000000000000000000000000000000e37ed25600000000000000000000000000000000000000000000000000000000e8bb3b6c00000000000000000000000000000000000000000000000000000000876a02f6000000000000000000000000000000000000000000000000000000007f45767500000000000000000000000000000000000000000000000000000000d6ed22e600000000000000000000000000000000000000000000000000000000a76f4eb6000000000000000000000000000000000000000000000000000000005e94e28d00000000000000000000000000000000000000000000000000000000da35bb0d00000000000000000000000000000000000000000000000000000000fa461e33000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004f52e33f500000000000000000000000000000000000000000000000000000000b94c360900000000000000000000000000000000000000000000000000000000f35cae900000000000000000000000000000000000000000000000000000000021025a060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000043b635ce40000000000000000000000000000000000000000000000000000000083bd37f9000000000000000000000000000000000000000000000000000000007bf2d6d40000000000000000000000000000000000000000000000000000000084a7f3dd000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008fa461e330000000000000000000000000000000000000000000000000000000007ed237900000000000000000000000000000000000000000000000000000000a76dfc3b0000000000000000000000000000000000000000000000000000000083800a8e000000000000000000000000000000000000000000000000000000008770ba9100000000000000000000000000000000000000000000000000000000193674720000000000000000000000000000000000000000000000000000000089af926a00000000000000000000000000000000000000000000000000000000188ac35d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ce449022e00000000000000000000000000000000000000000000000000000000fa461e330000000000000000000000000000000000000000000000000000000084bd6d290000000000000000000000000000000000000000000000000000000062e238bb000000000000000000000000000000000000000000000000000000003eca9c0a000000000000000000000000000000000000000000000000000000009570eeee000000000000000000000000000000000000000000000000000000005a09984300000000000000000000000000000000000000000000000000000000e5d7bde60000000000000000000000000000000000000000000000000000000012aa3caf00000000000000000000000000000000000000000000000000000000bc80f1a8000000000000000000000000000000000000000000000000000000000502b1c500000000000000000000000000000000000000000000000000000000f78dc25300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000890411a3200000000000000000000000000000000000000000000000000000000fa461e3300000000000000000000000000000000000000000000000000000000bc80f1a8000000000000000000000000000000000000000000000000000000008980041a000000000000000000000000000000000000000000000000000000006b58f2f00000000000000000000000000000000000000000000000000000000022dca3d700000000000000000000000000000000000000000000000000000000d57360fc0000000000000000000000000000000000000000000000000000000030eef8bd0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012213bc0b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e21fd0e90000000000000000000000000000000000000000000000000000000059e50fed000000000000000000000000000000000000000000000000000000008af033fb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002fa461e33000000000000000000000000000000000000000000000000000000002646478b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012646478b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002fa461e33000000000000000000000000000000000000000000000000000000002646478b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002fa461e33000000000000000000000000000000000000000000000000000000002646478b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003fa461e33000000000000000000000000000000000000000000000000000000002646478b0000000000000000000000000000000000000000000000000000000047f8bd41000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003fa461e3300000000000000000000000000000000000000000000000000000000dd9c5f9600000000000000000000000000000000000000000000000000000000ee6232040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025f3bd1c800000000000000000000000000000000000000000000000000000000d33721a50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014dcebcba000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005fa461e330000000000000000000000000000000000000000000000000000000003b87e5f000000000000000000000000000000000000000000000000000000000d5f0e3b0000000000000000000000000000000000000000000000000000000008298b5a0000000000000000000000000000000000000000000000000000000001617fab000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005fa461e330000000000000000000000000000000000000000000000000000000003b87e5f000000000000000000000000000000000000000000000000000000000d5f0e3b0000000000000000000000000000000000000000000000000000000008298b5a0000000000000000000000000000000000000000000000000000000001617fab000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006fa461e330000000000000000000000000000000000000000000000000000000003b87e5f000000000000000000000000000000000000000000000000000000000d5f0e3b0000000000000000000000000000000000000000000000000000000008298b5a0000000000000000000000000000000000000000000000000000000001617fab000000000000000000000000000000000000000000000000000000000c307f76000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002e0cbc5f200000000000000000000000000000000000000000000000000000000eedd56e10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020e8ae67f00000000000000000000000000000000000000000000000000000000332d746b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021078c57900000000000000000000000000000000000000000000000000000000a7a4a2710000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000023ccfd60b00000000000000000000000000000000000000000000000000000000d0e30db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

    WhitelistManagerFacet internal whitelistManagerFacet;
    DiamondCutFacet internal diamondCutFacet;
    OwnershipFacet internal ownershipFacet;
    DiamondLoupeFacet internal diamondLoupeFacet;
    IDexManagerFacet internal dexManagerFacet;

    // Cached getter results (populated in setUp)
    address[] internal whitelistedAddresses;
    bytes4[] internal whitelistedFunctionSelectors;
    address[] internal allContractAddresses;
    bytes4[][] internal allContractSelectors;
    address[] internal approvedDexs;

    function setUp() public {
        // Fork Arbitrum from latest block
        string memory rpcUrl = vm.envString("ETH_NODE_URI_ARBITRUM");
        vm.createSelectFork(rpcUrl);

        // Initialize facet interfaces
        whitelistManagerFacet = WhitelistManagerFacet(DIAMOND_ARBITRUM);
        diamondCutFacet = DiamondCutFacet(DIAMOND_ARBITRUM);
        ownershipFacet = OwnershipFacet(DIAMOND_ARBITRUM);
        diamondLoupeFacet = DiamondLoupeFacet(DIAMOND_ARBITRUM);
        dexManagerFacet = IDexManagerFacet(DIAMOND_ARBITRUM);

        // Label addresses for better readability in error traces
        vm.label(DIAMOND_ARBITRUM, "LiFiDiamond");
        vm.label(TIMELOCK_ARBITRUM, "LiFiTimelockController");
        vm.label(WHITELIST_MANAGER_FACET_ARBITRUM, "WhitelistManagerFacet");

        // Verify TimeLock is the owner
        address owner = ownershipFacet.owner();
        if (owner != TIMELOCK_ARBITRUM) {
            revert UnAuthorized();
        }

        // Execute diamond cut as TimeLock controller
        // The call data already includes the function selector (diamondCut.selector)
        vm.prank(TIMELOCK_ARBITRUM);
        (bool success, ) = address(diamondCutFacet).call(DIAMOND_CUT_CALLDATA);
        if (!success) {
            revert ExternalCallFailed();
        }

        // Cache getter results (called once for all tests)
        whitelistedAddresses = whitelistManagerFacet.getWhitelistedAddresses();
        whitelistedFunctionSelectors = whitelistManagerFacet
            .getWhitelistedFunctionSelectors();
        (allContractAddresses, allContractSelectors) = whitelistManagerFacet
            .getAllContractSelectorPairs();
        approvedDexs = dexManagerFacet.approvedDexs();
    }

    /// @notice Test that migration status is true after migration
    /// @dev Verifies that isMigrated() returns true after the diamond cut
    function test_MigrationStatus() public {
        bool isMigrated = whitelistManagerFacet.isMigrated();
        assertTrue(isMigrated, "Migration should be completed");
    }

    /// @notice Test that approvedDexs() and getWhitelistedAddresses() match exactly
    /// @dev Verifies:
    ///      1. approvedDexs() returns the expected count (from whitelist.json)
    ///      2. getWhitelistedAddresses() returns the expected count (from whitelist.json)
    ///      3. Both arrays have the same length
    ///      4. All addresses in both arrays match exactly
    ///      If differences are found, they are identified and reported
    function test_ApprovedDexsAndWhitelistedAddressesMatch() public {
        // Check approvedDexs() count and identify differences
        if (approvedDexs.length != EXPECTED_ADDRESS_COUNT_ARBITRUM) {
            _reportAddressCountMismatch(
                "approvedDexs()",
                approvedDexs,
                EXPECTED_ADDRESS_COUNT_ARBITRUM
            );
        }
        assertEq(
            approvedDexs.length,
            EXPECTED_ADDRESS_COUNT_ARBITRUM,
            "approvedDexs() should return expected count"
        );

        // Check getWhitelistedAddresses() count and identify differences
        if (whitelistedAddresses.length != EXPECTED_ADDRESS_COUNT_ARBITRUM) {
            _reportAddressCountMismatch(
                "getWhitelistedAddresses()",
                whitelistedAddresses,
                EXPECTED_ADDRESS_COUNT_ARBITRUM
            );
        }
        assertEq(
            whitelistedAddresses.length,
            EXPECTED_ADDRESS_COUNT_ARBITRUM,
            "getWhitelistedAddresses() should return expected count"
        );

        // Check lengths match
        assertEq(
            approvedDexs.length,
            whitelistedAddresses.length,
            "approvedDexs().length should equal getWhitelistedAddresses().length"
        );

        // Deep content check: verify both arrays contain the same values
        _assertArraysContainSameValues(approvedDexs, whitelistedAddresses);
    }

    /// @notice Helper function to verify two arrays contain the same values
    /// @dev Iterates through the first array and checks if each element exists in the second array
    ///      Since both arrays have the same length, checking one direction is sufficient
    /// @param arr1 First array to compare
    /// @param arr2 Second array to compare
    function _assertArraysContainSameValues(
        address[] memory arr1,
        address[] memory arr2
    ) internal {
        assertEq(
            arr1.length,
            arr2.length,
            "Arrays must have the same length for comparison"
        );

        for (uint256 i = 0; i < arr1.length; i++) {
            bool found = false;
            for (uint256 j = 0; j < arr2.length; j++) {
                if (arr1[i] == arr2[j]) {
                    found = true;
                    break;
                }
            }
            assertTrue(
                found,
                "All elements from first array must exist in second array"
            );
        }
    }

    /// @notice Helper function to report address count mismatches and identify extra addresses
    /// @dev Prints information about extra addresses that are on-chain but not in whitelist.json
    /// @param functionName Name of the function being checked
    /// @param actualAddresses Array of addresses returned from on-chain
    /// @param expectedCount Expected count from whitelist.json
    function _reportAddressCountMismatch(
        string memory functionName,
        address[] memory actualAddresses,
        uint256 expectedCount
    ) internal {
        // This will cause the test to fail with detailed information
        // The actual addresses will be visible in the test failure output
        emit log_named_string("Function", functionName);
        emit log_named_uint(
            "Expected count (from whitelist.json)",
            expectedCount
        );
        emit log_named_uint("Actual count (on-chain)", actualAddresses.length);
        uint256 diff = actualAddresses.length >= expectedCount
            ? actualAddresses.length - expectedCount
            : 0;
        emit log_named_uint("Difference (extra addresses on-chain)", diff);

        if (actualAddresses.length > expectedCount) {
            emit log(
                "=== Extra addresses on-chain (not in whitelist.json) ==="
            );
            for (uint256 i = expectedCount; i < actualAddresses.length; i++) {
                emit log_named_uint("Extra address index", i);
                emit log_named_address("Extra address", actualAddresses[i]);
            }
        }
    }

    /// @notice Test that deprecated function selectors are not whitelisted after migration
    /// @dev Checks:
    ///      1. isFunctionSelectorWhitelisted() returns false
    ///      2. getWhitelistedFunctionSelectors() does not contain the deprecated selector
    ///      3. isFunctionApproved() returns false (backward compatibility check)
    function test_DeprecatedSelectorsNotWhitelisted() public {
        bytes4[3] memory deprecatedSelectors = [
            DEPRECATED_SELECTOR_1,
            DEPRECATED_SELECTOR_2,
            DEPRECATED_SELECTOR_3
        ];

        for (uint256 i = 0; i < deprecatedSelectors.length; i++) {
            bytes4 selector = deprecatedSelectors[i];

            // Check isFunctionSelectorWhitelisted() returns false
            bool isWhitelisted = whitelistManagerFacet
                .isFunctionSelectorWhitelisted(selector);
            assertFalse(
                isWhitelisted,
                "Deprecated selector should not be whitelisted"
            );

            // Check getWhitelistedFunctionSelectors() does not contain the deprecated selector
            bool foundInList = false;
            for (uint256 j = 0; j < whitelistedFunctionSelectors.length; j++) {
                if (whitelistedFunctionSelectors[j] == selector) {
                    foundInList = true;
                    break;
                }
            }
            assertFalse(
                foundInList,
                "Deprecated selector should not be in whitelisted selectors list"
            );

            // Check isFunctionApproved() returns false (backward compatibility)
            bool isApproved = dexManagerFacet.isFunctionApproved(selector);
            assertFalse(
                isApproved,
                "Deprecated selector should not be approved"
            );
        }
    }

    /// @notice Test that isFunctionApproved() returns true for whitelisted selectors
    /// @dev Verifies isFunctionApproved() returns true for selectors that should be whitelisted (backward compatibility)
    function test_IsFunctionApproved() public {
        // Test selectors that should return true (from whitelist.json)
        bytes4[3] memory whitelistedSelectors = [
            WHITELISTED_SELECTOR_1,
            WHITELISTED_SELECTOR_2,
            WHITELISTED_SELECTOR_3
        ];

        for (uint256 i = 0; i < whitelistedSelectors.length; i++) {
            bytes4 selector = whitelistedSelectors[i];
            bool isApproved = dexManagerFacet.isFunctionApproved(selector);
            assertTrue(isApproved, "Selector should be approved");
        }
    }

    /// @notice Test that specific contract-selector pairs from DEXS and PERIPHERY are whitelisted after migration
    /// @dev Verifies that contract-selector pairs from whitelist.json DEXS and PERIPHERY sections are correctly whitelisted
    function test_ContractSelectorPairs() public {
        // Test DEX contracts (from whitelist.json DEXS section)
        _testContractSelectorPair(
            DEX_CONTRACT_1,
            DEX_CONTRACT_1_SELECTOR_1,
            "DEX_CONTRACT_1_SELECTOR_1"
        );
        _testContractSelectorPair(
            DEX_CONTRACT_1,
            DEX_CONTRACT_1_SELECTOR_2,
            "DEX_CONTRACT_1_SELECTOR_2"
        );
        _testContractSelectorPair(
            DEX_CONTRACT_1,
            DEX_CONTRACT_1_SELECTOR_3,
            "DEX_CONTRACT_1_SELECTOR_3"
        );

        _testContractSelectorPair(
            DEX_CONTRACT_2,
            DEX_CONTRACT_2_SELECTOR_1,
            "DEX_CONTRACT_2_SELECTOR_1"
        );

        _testContractSelectorPair(
            DEX_CONTRACT_3,
            DEX_CONTRACT_3_SELECTOR_1,
            "DEX_CONTRACT_3_SELECTOR_1"
        );
        _testContractSelectorPair(
            DEX_CONTRACT_3,
            DEX_CONTRACT_3_SELECTOR_2,
            "DEX_CONTRACT_3_SELECTOR_2"
        );
        _testContractSelectorPair(
            DEX_CONTRACT_3,
            DEX_CONTRACT_3_SELECTOR_3,
            "DEX_CONTRACT_3_SELECTOR_3"
        );

        // Test PERIPHERY contracts (from whitelist.json PERIPHERY section)
        _testContractSelectorPair(
            PERIPHERY_CONTRACT_1,
            PERIPHERY_CONTRACT_1_SELECTOR_1,
            "PERIPHERY_CONTRACT_1_SELECTOR_1"
        );
        _testContractSelectorPair(
            PERIPHERY_CONTRACT_1,
            PERIPHERY_CONTRACT_1_SELECTOR_2,
            "PERIPHERY_CONTRACT_1_SELECTOR_2"
        );

        _testContractSelectorPair(
            PERIPHERY_CONTRACT_2,
            PERIPHERY_CONTRACT_2_SELECTOR_1,
            "PERIPHERY_CONTRACT_2_SELECTOR_1"
        );
        _testContractSelectorPair(
            PERIPHERY_CONTRACT_2,
            PERIPHERY_CONTRACT_2_SELECTOR_2,
            "PERIPHERY_CONTRACT_2_SELECTOR_2"
        );

        _testContractSelectorPair(
            PERIPHERY_CONTRACT_3,
            PERIPHERY_CONTRACT_3_SELECTOR_1,
            "PERIPHERY_CONTRACT_3_SELECTOR_1"
        );
        _testContractSelectorPair(
            PERIPHERY_CONTRACT_3,
            PERIPHERY_CONTRACT_3_SELECTOR_2,
            "PERIPHERY_CONTRACT_3_SELECTOR_2"
        );
    }

    /// @notice Helper function to test a single contract-selector pair
    /// @param contractAddr The contract address to test
    /// @param selector The selector to test
    /// @param pairName Name of the pair for error messages
    function _testContractSelectorPair(
        address contractAddr,
        bytes4 selector,
        string memory pairName
    ) internal {
        // Check 1: approvedDexs() contains the contract (both DEX and PERIPHERY contracts are in approvedDexs)
        // Note: The function name is outdated - it includes both DEX and PERIPHERY contracts
        bool foundInApprovedDexs = false;
        for (uint256 j = 0; j < approvedDexs.length; j++) {
            if (approvedDexs[j] == contractAddr) {
                foundInApprovedDexs = true;
                break;
            }
        }
        assertTrue(
            foundInApprovedDexs,
            string.concat(pairName, " contract should be in approvedDexs()")
        );

        // Check 2: getWhitelistedAddresses() contains the contract
        bool foundInWhitelistedAddresses = false;
        for (uint256 j = 0; j < whitelistedAddresses.length; j++) {
            if (whitelistedAddresses[j] == contractAddr) {
                foundInWhitelistedAddresses = true;
                break;
            }
        }
        assertTrue(
            foundInWhitelistedAddresses,
            string.concat(
                pairName,
                " contract should be in getWhitelistedAddresses()"
            )
        );

        // Check 3: getAllContractSelectorPairs() contains the pair
        bool foundInPairs = false;
        for (uint256 j = 0; j < allContractAddresses.length; j++) {
            if (allContractAddresses[j] == contractAddr) {
                for (uint256 k = 0; k < allContractSelectors[j].length; k++) {
                    if (allContractSelectors[j][k] == selector) {
                        foundInPairs = true;
                        break;
                    }
                }
                if (foundInPairs) break;
            }
        }
        assertTrue(
            foundInPairs,
            string.concat(
                pairName,
                " should be in getAllContractSelectorPairs()"
            )
        );

        // Check 4: isContractSelectorWhitelisted(contract, selector) returns true
        bool isContractSelectorWhitelisted = whitelistManagerFacet
            .isContractSelectorWhitelisted(contractAddr, selector);
        assertTrue(
            isContractSelectorWhitelisted,
            string.concat(pairName, " should be whitelisted")
        );

        // Check 5: isAddressWhitelisted(contract) returns true
        bool isAddressWhitelisted = whitelistManagerFacet.isAddressWhitelisted(
            contractAddr
        );
        assertTrue(
            isAddressWhitelisted,
            string.concat(pairName, " contract address should be whitelisted")
        );

        // Check 6: isFunctionSelectorWhitelisted(selector) returns true
        bool isSelectorWhitelisted = whitelistManagerFacet
            .isFunctionSelectorWhitelisted(selector);
        assertTrue(
            isSelectorWhitelisted,
            string.concat(pairName, " function selector should be whitelisted")
        );

        // Check 7: getWhitelistedSelectorsForContract(contract) contains the selector
        bytes4[] memory contractSelectors = whitelistManagerFacet
            .getWhitelistedSelectorsForContract(contractAddr);
        bool foundInContractSelectors = false;
        for (uint256 j = 0; j < contractSelectors.length; j++) {
            if (contractSelectors[j] == selector) {
                foundInContractSelectors = true;
                break;
            }
        }
        assertTrue(
            foundInContractSelectors,
            string.concat(
                pairName,
                " contract selectors should contain the selector"
            )
        );
    }

    /// @notice Test that approveTo-only addresses are correctly configured after migration
    /// @dev Checks that approveTo-only addresses:
    ///      1. Are in getWhitelistedAddresses()
    ///      2. Have isContractSelectorWhitelisted(address, 0xffffffff) return true
    ///      3. Have getWhitelistedSelectorsForContract(address) return [0xffffffff]
    ///      4. Are in getAllContractSelectorPairs() with [0xffffffff]
    function test_ApproveToOnlyAddresses() public {
        address[3] memory approveToOnlyAddresses = [
            APPROVE_TO_ONLY_ADDRESS_1,
            APPROVE_TO_ONLY_ADDRESS_2,
            APPROVE_TO_ONLY_ADDRESS_3
        ];

        for (uint256 i = 0; i < approveToOnlyAddresses.length; i++) {
            address contractAddr = approveToOnlyAddresses[i];

            // Check 1: Address is in getWhitelistedAddresses()
            bool foundInWhitelistedAddresses = false;
            for (uint256 j = 0; j < whitelistedAddresses.length; j++) {
                if (whitelistedAddresses[j] == contractAddr) {
                    foundInWhitelistedAddresses = true;
                    break;
                }
            }
            assertTrue(
                foundInWhitelistedAddresses,
                "ApproveTo-only address should be in getWhitelistedAddresses()"
            );

            // Check 2: isContractSelectorWhitelisted(address, 0xffffffff) returns true
            bool isSelectorWhitelisted = whitelistManagerFacet
                .isContractSelectorWhitelisted(
                    contractAddr,
                    APPROVE_TO_ONLY_SELECTOR
                );
            assertTrue(
                isSelectorWhitelisted,
                "ApproveTo-only address should have 0xffffffff selector whitelisted"
            );

            // Check 3: getWhitelistedSelectorsForContract(address) returns [0xffffffff]
            bytes4[] memory selectors = whitelistManagerFacet
                .getWhitelistedSelectorsForContract(contractAddr);
            assertEq(
                selectors.length,
                1,
                "ApproveTo-only address should have exactly one selector"
            );
            assertEq(
                selectors[0],
                APPROVE_TO_ONLY_SELECTOR,
                "ApproveTo-only address should have 0xffffffff selector"
            );

            // Check 4: getAllContractSelectorPairs() contains the address with [0xffffffff]
            bool foundInPairs = false;
            for (uint256 j = 0; j < allContractAddresses.length; j++) {
                if (allContractAddresses[j] == contractAddr) {
                    assertEq(
                        allContractSelectors[j].length,
                        1,
                        "ApproveTo-only address should have exactly one selector in pairs"
                    );
                    assertEq(
                        allContractSelectors[j][0],
                        APPROVE_TO_ONLY_SELECTOR,
                        "ApproveTo-only address should have 0xffffffff selector in pairs"
                    );
                    foundInPairs = true;
                    break;
                }
            }
            assertTrue(
                foundInPairs,
                "ApproveTo-only address should be in getAllContractSelectorPairs()"
            );
        }
    }

    /// @notice Test that array function counts match expected values from whitelist.json
    /// @dev Verifies:
    ///      1. getWhitelistedFunctionSelectors() count matches expected selector count (from whitelist.json)
    ///      2. getAllContractSelectorPairs() total pairs count matches expected pairs count (from whitelist.json)
    ///      If differences are found, they are identified and reported
    function test_ArrayFunctionCounts() public {
        // Check 1: getWhitelistedFunctionSelectors() count
        if (
            whitelistedFunctionSelectors.length !=
            EXPECTED_SELECTOR_COUNT_ARBITRUM
        ) {
            _reportSelectorCountMismatch(
                whitelistedFunctionSelectors,
                EXPECTED_SELECTOR_COUNT_ARBITRUM
            );
        }
        assertEq(
            whitelistedFunctionSelectors.length,
            EXPECTED_SELECTOR_COUNT_ARBITRUM,
            "getWhitelistedFunctionSelectors() count should match expected selector count"
        );

        // Check 2: getAllContractSelectorPairs() total pairs count
        uint256 totalPairs = 0;
        for (uint256 i = 0; i < allContractSelectors.length; i++) {
            totalPairs += allContractSelectors[i].length;
        }
        if (totalPairs != EXPECTED_TOTAL_PAIRS_COUNT_ARBITRUM) {
            _reportPairsCountMismatch(
                totalPairs,
                EXPECTED_TOTAL_PAIRS_COUNT_ARBITRUM
            );
        }
        assertEq(
            totalPairs,
            EXPECTED_TOTAL_PAIRS_COUNT_ARBITRUM,
            "getAllContractSelectorPairs() total pairs count should match expected pairs count"
        );
    }

    /// @notice Helper function to report selector count mismatches
    /// @dev Prints information about extra selectors that are on-chain but not in whitelist.json
    /// @param actualSelectors Array of selectors returned from on-chain
    /// @param expectedCount Expected count from whitelist.json
    function _reportSelectorCountMismatch(
        bytes4[] memory actualSelectors,
        uint256 expectedCount
    ) internal {
        emit log_named_string("Function", "getWhitelistedFunctionSelectors()");
        emit log_named_uint(
            "Expected count (from whitelist.json)",
            expectedCount
        );
        emit log_named_uint("Actual count (on-chain)", actualSelectors.length);
        uint256 diff = actualSelectors.length >= expectedCount
            ? actualSelectors.length - expectedCount
            : 0;
        emit log_named_uint("Difference (extra selectors on-chain)", diff);

        if (actualSelectors.length > expectedCount) {
            emit log(
                "=== Extra selectors on-chain (not in whitelist.json) ==="
            );
            for (uint256 i = expectedCount; i < actualSelectors.length; i++) {
                emit log_named_uint("Extra selector index", i);
                emit log_named_bytes32(
                    "Extra selector (as bytes32)",
                    bytes32(actualSelectors[i])
                );
            }
        }
    }

    /// @notice Helper function to report pairs count mismatches
    /// @dev Prints information about extra pairs that are on-chain but not in whitelist.json
    /// @param actualPairs Total pairs count from on-chain
    /// @param expectedCount Expected count from whitelist.json
    function _reportPairsCountMismatch(
        uint256 actualPairs,
        uint256 expectedCount
    ) internal {
        emit log_named_string("Function", "getAllContractSelectorPairs()");
        emit log_named_uint(
            "Expected total pairs (from whitelist.json)",
            expectedCount
        );
        emit log_named_uint("Actual total pairs (on-chain)", actualPairs);
        uint256 diff = actualPairs >= expectedCount
            ? actualPairs - expectedCount
            : 0;
        emit log_named_uint("Difference (extra pairs on-chain)", diff);

        if (actualPairs > expectedCount) {
            emit log(
                "=== Extra contract-selector pairs on-chain (not in whitelist.json) ==="
            );
            // Note: To identify which specific pairs are extra, we would need to compare
            // against whitelist.json pairs, which would require more complex logic
            emit log(
                "Note: Specific extra pairs would require comparing against whitelist.json"
            );
        }
    }
}
