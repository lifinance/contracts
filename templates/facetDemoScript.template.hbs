import {
  getContract,
  parseUnits,
  parseEther,
  Narrow,
  zeroAddress
} from 'viem'
import { randomBytes } from 'crypto'
import dotenv from 'dotenv'
import erc20Artifact from '../../out/ERC20/ERC20.sol/ERC20.json'
import {{camelCase name}}FacetArtifact from '../../out/{{titleCase name}}Facet.sol/{{titleCase name}}Facet.json'
import config from '../../config/{{camelCase name}}.json'
import { {{titleCase name}}Facet, ILiFi } from '../../typechain'
import { SupportedChain } from './utils/demoScriptChainConfig'
import { checkBalance, ensureAllowance, executeTransaction, getConfigElement, setupEnvironment, zeroPadAddressToBytes32 } from './utils/demoScriptHelpers'

dotenv.config()

// #region ABIs

const ERC20_ABI = erc20Artifact.abi as Narrow<typeof erc20Artifact.abi>
const {{constantCase name}}_FACET_ABI = {{camelCase name}}FacetArtifact.abi as Narrow<typeof {{camelCase name}}FacetArtifact.abi>

// #endregion

dotenv.config()

async function main() {
  // === Set up environment ===
  const srcChain: SupportedChain = "mainnet"; // Set source chain
  const destinationChainId = 1 // Set destination chain id

  const { client, publicClient, walletAccount, lifiDiamondAddress, lifiDiamondContract } = await setupEnvironment(srcChain, {{constantCase name}}_FACET_ABI);
  const signerAddress = walletAccount.address

  // === Contract addresses ===
  const SRC_TOKEN_ADDRESS = '' as `0x${string}` // Set the source token address here.

  // If you need to retrieve a specific address from your config file 
  // based on the chain and element name, use this helper function.
  //
  // const EXAMPLE_ADDRESS = getConfigElement(config, srcChain, 'example');
  //

  // === Instantiate contracts ===
  const srcTokenContract = getContract({
    address: SRC_TOKEN_ADDRESS,
    abi: ERC20_ABI,
    client
  })

  // If you need to interact with a contract, use the following helper. 
  // Provide the contract address, ABI, and a client instance to initialize 
  // the contract for both read and write operations.
  //
  // const exampleContract = getContract({
  //   address: EXAMPLE_ADDRESS,
  //   abi: EXAMPLE_ABI,
  //   client
  // });
  //

  const srcTokenName = await srcTokenContract.read.name() as string
  const srcTokenSymbol = await srcTokenContract.read.symbol() as string
  const amount = parseUnits('10', 18) // 10 * 1e18

  console.info(`\Bridge ${amount} ${srcTokenName} (${srcTokenSymbol}) from ${srcChain} --> {DESTINATION CHAIN NAME}`) // Set destination chain name
  console.info(`Connected wallet address: ${signerAddress}`)

  await ensureBalance(wormholeTokenContract, signerAddress, amount);

  await ensureAllowance(wormholeTokenContract, signerAddress, lifiDiamondAddress, amount, publicClient); 

  // === In this part put necessary logic usually it's fetching quotes, estimating fees, signing messages etc. ===




  // === Prepare bridge data ===
  const bridgeData: ILiFi.BridgeDataStruct = {
    // Edit fields as needed
    transactionId: `0x${randomBytes(32).toString('hex')}`,
    bridge: '{{camelCase name}}',
    integrator: 'ACME Devs',
    referrer: zeroAddress,
    sendingAssetId: SRC_TOKEN_ADDRESS,
    receiver: signerAddress,
    destinationChainId,
    minAmount: amount,
    hasSourceSwaps: false,
    hasDestinationCall: false,
  }

  const {{camelCase name}}BridgeData: {{titleCase name}}Facet.{{titleCase name}}DataStruct = {
    // Add your specific fields for {{titleCase name}} here.
  }

  // === Start bridging ===
  await executeTransaction(
    () =>
      lifiDiamondContract.write.startBridgeTokensVia{{titleCase name}}(
        [bridgeData, {{camelCase name}}BridgeData],
        { value: nativeFee }
      ),
    'Starting bridge tokens via {{titleCase name}}',
    publicClient,
    true
  );
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error)
    process.exit(1)
  })
