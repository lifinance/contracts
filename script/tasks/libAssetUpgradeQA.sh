#!/bin/bash

# =============================================================================
# LibAsset v2.0.0 Upgrade – QA Validator
# =============================================================================
# Purpose: Validate outputs generated by the LibAsset upgrade flow and ensure
# they are syntactically correct and semantically meaningful for the workflow.
#
# Usage:
#   ./script/tasks/libAssetUpgradeQA.sh <chainName> [--run]
#   - Without --run: only validates existing files in repo/tmp
#   - With --run: runs the dry-run wrapper non-interactively, then validates
# =============================================================================

set -euo pipefail

source script/helperFunctions.sh

CHAIN_NAME="${1:-}"
RUN_FLAG="${2:-}"

if [[ -z "$CHAIN_NAME" ]]; then
  echo "Usage: $0 <chainName> [--run]" >&2
  exit 1
fi

DEPLOYMENT_FILE="./deployments/${CHAIN_NAME}.json"
if [[ ! -f "$DEPLOYMENT_FILE" ]]; then
  echo "[QA] Missing deployments file: $DEPLOYMENT_FILE" >&2
  exit 1
fi

function info() { echo "[QA] $*"; }
function fail() { echo "[QA][FAIL] $*" >&2; EXIT_CODE=1; }
function pass() { echo "[QA][PASS] $*"; }

EXIT_CODE=0

if [[ "$RUN_FLAG" == "--run" ]]; then
  info "Running upgrade wrapper in dry-run, auto-continue prompts"
  # Send newlines to continue interactive pauses
  yes "" | ./script/libAssetUpgradeWrapper.sh "$CHAIN_NAME" --dry-run || true
fi

# Load known contracts from deployment file
DEPLOYED_CONTRACTS=()
while IFS= read -r _c; do
  DEPLOYED_CONTRACTS+=("$_c")
done < <(jq -r 'keys[]' "$DEPLOYMENT_FILE")

function is_in_deployments() {
  local name="$1"
  for c in "${DEPLOYED_CONTRACTS[@]}"; do
    [[ "$c" == "$name" ]] && return 0
  done
  return 1
}

# 1) contractClassification.txt sanity
if [[ -f contractClassification.txt ]]; then
  info "Validating contractClassification.txt structure"
  if rg -n "SECTION 1: CONTRACTS USING LIBASSET" contractClassification.txt >/dev/null && \
     rg -n "SECTION 2: CONTRACTS NOT USING LIBASSET" contractClassification.txt >/dev/null && \
     rg -n "SECTION 3: CONTRACTS MISSING FROM CODEBASE" contractClassification.txt >/dev/null && \
     rg -n "SECTION 4: DIAMOND CONTRACTS" contractClassification.txt >/dev/null; then
    pass "contractClassification.txt has required sections"
  else
    fail "contractClassification.txt missing required section headers"
  fi
else
  info "contractClassification.txt not found – skipping"
fi

# 2) contractsUsingLibAsset.txt exists and contains only names
if [[ -f contractsUsingLibAsset.txt ]]; then
  info "Validating contractsUsingLibAsset.txt"
  if rg -n "[^A-Za-z0-9_]" contractsUsingLibAsset.txt | rg -v ":$" >/dev/null; then
    # Non-word chars detected (excluding empty lines)
    fail "contractsUsingLibAsset.txt contains unexpected characters"
  else
    pass "contractsUsingLibAsset.txt format OK"
  fi
else
  info "contractsUsingLibAsset.txt not found – skipping"
fi

# 3) contractsToRedeploy.txt should contain only contract names (one per line) and no log text
if [[ -f contractsToRedeploy.txt ]]; then
  info "Validating contractsToRedeploy.txt"
  if rg -n "^(Checking|Summary:|Contracts|deployment|dates|for|skipped:|needing)$" contractsToRedeploy.txt >/dev/null; then
    fail "contractsToRedeploy.txt contains log lines – should contain only contract names"
  fi
  # Ensure every non-empty line is a known deployed contract
  BAD_LINES=0
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    if ! is_in_deployments "$line"; then
      fail "contractsToRedeploy.txt contains unknown contract: $line"; BAD_LINES=1
    fi
  done < contractsToRedeploy.txt
  [[ $BAD_LINES -eq 0 ]] && pass "contractsToRedeploy.txt contents OK"
else
  info "contractsToRedeploy.txt not found – skipping"
fi

# 4) redeployLogs.json valid and contains entries for each to-redeploy contract
if [[ -f redeployLogs.json ]]; then
  info "Validating redeployLogs.json"
  if ! jq . redeployLogs.json >/dev/null 2>&1; then
    fail "redeployLogs.json is not valid JSON"
  else
    # Validate entries
    TO_REDEPLOY=()
    while IFS= read -r c; do
      TO_REDEPLOY+=("$c")
    done < <(rg -v "^$" --no-filename contractsToRedeploy.txt 2>/dev/null || true)
    if [[ ${#TO_REDEPLOY[@]} -gt 0 ]]; then
      for c in "${TO_REDEPLOY[@]}"; do
        [[ -z "$c" ]] && continue
        local_entry=$(jq -r --arg c "$c" '.[$c]' redeployLogs.json)
        if [[ "$local_entry" == "null" || -z "$local_entry" ]]; then
          fail "redeployLogs.json missing entry for $c"
          continue
        fi
        old=$(jq -r --arg c "$c" '.[$c].oldAddress // ""' redeployLogs.json)
        new=$(jq -r --arg c "$c" '.[$c].newAddress // ""' redeployLogs.json)
        if ! [[ "$old" =~ ^0x[0-9a-fA-F]{40}$ ]] && [[ "$old" != "" ]]; then
          fail "$c oldAddress invalid: $old"
        fi
        if ! [[ "$new" =~ ^0x[0-9a-fA-F]{40}$ ]] && [[ "$new" != "" ]]; then
          fail "$c newAddress invalid: $new"
        fi
      done
    fi
    pass "redeployLogs.json format OK"
  fi
else
  info "redeployLogs.json not found – skipping"
fi

# 5) diamondCutCalldata.tmp sanity
if [[ -f diamondCutCalldata.tmp ]]; then
  info "Validating diamondCutCalldata.tmp"
  if rg -n '^CALLDATA=0x[0-9a-fA-F]+$' diamondCutCalldata.tmp >/dev/null; then
    pass "diamondCutCalldata.tmp contains CALLDATA line"
  else
    # Try to extract Cuts JSON block and validate
    awk '/^# Cuts JSON/{flag=1;next} /^# Summary/{flag=0} flag{print}' diamondCutCalldata.tmp > /tmp/_cuts.json || true
    if [[ -s /tmp/_cuts.json ]] && jq . /tmp/_cuts.json >/dev/null 2>&1; then
      # Ensure actions are valid and selectors look like bytes4
      if jq -e 'all(.[]; (.action==0 or .action==1 or .action==2) and (.selectors|type=="array"))' /tmp/_cuts.json >/dev/null 2>&1; then
        pass "diamondCutCalldata.tmp Cuts JSON valid"
      else
        fail "diamondCutCalldata.tmp Cuts JSON invalid structure"
      fi
    else
      fail "diamondCutCalldata.tmp missing CALLDATA and Cuts JSON"
    fi
  fi
else
  info "diamondCutCalldata.tmp not found – skipping"
fi

# 6) peripheryUpdateCalldata.tmp sanity
if [[ -f peripheryUpdateCalldata.tmp ]]; then
  info "Validating peripheryUpdateCalldata.tmp"
  if rg -n '^CALLDATA_[0-9]+=0x[0-9a-fA-F]+\\$' peripheryUpdateCalldata.tmp >/dev/null; then
    pass "peripheryUpdateCalldata.tmp contains individual calldata lines"
  else
    info "peripheryUpdateCalldata.tmp has no individual calldata lines (possibly no periphery updates)"
  fi
else
  info "peripheryUpdateCalldata.tmp not found – skipping"
fi

# 7) outdatedFacets files
if [[ -f outdatedFacets.txt ]]; then
  info "Validating outdatedFacets.txt"
  # Not strict; just ensure lines with ContractName:0x...
  if rg -n '^[# ]*[A-Za-z0-9_]+:0x[0-9a-fA-F]{40}$' outdatedFacets.txt >/dev/null; then
    pass "outdatedFacets.txt contains facet candidates"
  else
    info "outdatedFacets.txt contains no removal candidates or format differs"
  fi
fi

if [[ $EXIT_CODE -eq 0 ]]; then
  info "QA checks passed"
else
  info "QA checks found issues"
fi

exit $EXIT_CODE
