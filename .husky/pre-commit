#!/usr/bin/env bash
export HUSKY_SHELL="${HUSKY_SHELL:-bash}"
. "$(dirname -- "$0")/_/husky.sh"

# Early exit: Check if there are any staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)
if [ -z "$STAGED_FILES" ]; then
  echo "No files staged for commit. Skipping pre-commit checks."
  exit 0
fi

GIT_ROOT=$(git rev-parse --show-toplevel)
cd "$GIT_ROOT" || exit 1

# Determine what types of files changed for conditional execution (optimized single pass)
HAS_SOL_FILES="no"
HAS_TS_JS_FILES="no"
HAS_TYPE_FILES="no"

echo "$STAGED_FILES" | grep -qE '\.sol$' && HAS_SOL_FILES="yes" && HAS_TYPE_FILES="yes"
echo "$STAGED_FILES" | grep -qE '\.(ts|js|tsx)$' && HAS_TS_JS_FILES="yes" && HAS_TYPE_FILES="yes"

# Create temp directory for parallel execution
TEMP_DIR=$(mktemp -d)
trap "rm -rf '$TEMP_DIR' 2>/dev/null" EXIT INT TERM

FORGE_OUTPUT="$TEMP_DIR/forge.out"
FORGE_EXIT="$TEMP_DIR/forge.exit"
TYPECHAIN_OUTPUT="$TEMP_DIR/typechain.out"
TYPECHAIN_EXIT="$TEMP_DIR/typechain.exit"
TSC_OUTPUT="$TEMP_DIR/tsc.out"
TSC_EXIT="$TEMP_DIR/tsc.exit"
LINT_STAGED_OUTPUT="$TEMP_DIR/lint-staged.out"
LINT_STAGED_EXIT="$TEMP_DIR/lint-staged.exit"

DISABLE_WITH_COMMENT="pre-commit-checker: not a secret"
ETH_PRIVATE_KEY_PATTERN='(^|[^0-9a-fA-F])[0-9a-fA-F]{64}([^0-9a-fA-F]|$)'
KNOWN_FALSE_POSITIVES=(
  "true"
  "false"
  "none"
  ""
  "verifyContract"
)
EXCLUDED_PATHS=(
  "deployments/_deployments_log_file.json"
  "config/networks.json"
  "lib/"
  "safe/cancun/out/"
  "safe/london/out/"
  "bun.lock"
  ".bun/"
)

ENV_SECRET_KEYS=()
ENV_SECRET_VALUES=()
SECRET_FOUND=0
PRIVATE_KEY_FOUND=0
SECRET_RESULTS=""

# Helper function to print section header
print_section() {
  printf '\n\033[1m━━━ %s ━━━\033[0m\n' "$1"
}

# Helper function to print status
print_status() {
  local status=$1
  local message=$2
  if [ "$status" = "success" ]; then
    printf '\033[32m✓\033[0m %s\n' "$message"
  elif [ "$status" = "warning" ]; then
    # Print the full line in yellow (easy to notice)
    printf '\033[33m⚠ %s\033[0m\n' "$message"
  elif [ "$status" = "skip" ]; then
    printf '\033[33m⊘\033[0m %s\n' "$message"
  elif [ "$status" = "error" ]; then
    # Print the full line in red (easy to notice)
    printf '\033[31m✗ %s\033[0m\n' "$message"
  else
    printf '  %s\n' "$message"
  fi
}

# Helper function to filter verbose output
filter_output() {
  local tool=$1
  local content=$2

  case "$tool" in
    forge)
      # Only show errors, suppress compilation details
      echo "$content" | grep -E "(Error|Failed|error|failed)" || true
      ;;
    typechain)
      # Show only errors and summary, suppress verbose output
      echo "$content" | grep -vE "^\$ |^Resolving|^Resolved|^Saved|^Cleaned|^Cleaned duplicate" | grep -E "(Successfully|Error|error|Failed|failed)" || true
      ;;
    lint-staged)
      # Suppress verbose lint-staged output, keep only errors and important messages
      echo "$content" | grep -vE "^\[(STARTED|COMPLETED)\]" | grep -vE "^Preparing lint-staged" | grep -vE "^Running tasks" | grep -vE "^Applying modifications" | grep -vE "^Cleaning up" | grep -E "(error|Error|failed|Failed|warning|Warning)" || true
      ;;
    tsc)
      # Show only errors
      echo "$content" | grep -vE "^$" | head -20 || true
      ;;
    *)
      echo "$content"
      ;;
  esac
}

# Helper function to wait for PIDs and exit on failure
wait_and_check() {
  local pid=$1
  local exit_file=$2
  local output_file=$3
  local error_msg=$4
  local tool_name=$5

  if [ -z "$pid" ]; then
    return 0
  fi

  wait "$pid" 2>/dev/null
  local exit_code=$(cat "$exit_file" 2>/dev/null || echo "1")

  if [ "$exit_code" -ne 0 ] && [ -f "$output_file" ]; then
    # Show filtered output only on errors
    if [ -n "$tool_name" ]; then
      filter_output "$tool_name" "$(cat "$output_file")"
    else
      cat "$output_file"
    fi
  fi

  if [ "$exit_code" -ne 0 ]; then
    [ -n "$error_msg" ] && printf '\n\033[31m%s\033[0m\n\n' "$error_msg"
    return 1
  fi
  return 0
}

is_excluded_path() {
  local FILE="$1"

  for EXCLUDED_PATH in "${EXCLUDED_PATHS[@]}"; do
    if [[ "$FILE" == "$EXCLUDED_PATH"* ]]; then
      return 0
    fi
  done

  return 1
}

is_known_false_positive_match() {
  local FILE="$1"
  local LINE_NUMBER="$2"

  local PREV_LINE=""
  local CURR_LINE=""

  if [ "$LINE_NUMBER" -gt 1 ]; then
    PREV_LINE=$(sed -n "$((LINE_NUMBER - 1))p" "$FILE")
  fi

  CURR_LINE=$(sed -n "${LINE_NUMBER}p" "$FILE")

  if printf '%s\n%s\n' "$PREV_LINE" "$CURR_LINE" | grep -q "$DISABLE_WITH_COMMENT"; then
    return 0
  fi

  return 1
}

prepare_env_secrets() {
  local ENV_FILE="$GIT_ROOT/.env"
  local ENV_SECRETS_FILE="$TEMP_DIR/env_secrets"

  if [ ! -f "$ENV_FILE" ]; then
    return
  fi

  grep -v '^#' "$ENV_FILE" | sed 's/#.*//' | grep -v '^[[:space:]]*$' | sed 's/[[:space:]]*$//' > "$ENV_SECRETS_FILE"

  while IFS= read -r SECRET_LINE || [ -n "$SECRET_LINE" ]; do
    local KEY=${SECRET_LINE%%=*}
    local VALUE=${SECRET_LINE#*=}

    KEY=$(printf '%s' "$KEY" | sed 's/[[:space:]]*$//')
    VALUE=$(printf '%s' "$VALUE" | sed -e 's/^["'\''"]*//' -e 's/["'\''"]*$//' -e 's/[[:space:]]*$//')

    local IS_FALSE_POSITIVE=false
    for FALSE_POSITIVE in "${KNOWN_FALSE_POSITIVES[@]}"; do
      if [ "$VALUE" = "$FALSE_POSITIVE" ]; then
        IS_FALSE_POSITIVE=true
        break
      fi
    done

    if [ -z "$VALUE" ] || [ "$IS_FALSE_POSITIVE" = true ]; then
      continue
    fi

    ENV_SECRET_KEYS+=("$KEY")
    ENV_SECRET_VALUES+=("$VALUE")
  done < "$ENV_SECRETS_FILE"
}

does_file_contain_dot_env_secret() {
  local STAGED_FILE="$1"
  local DISPLAY_PATH="$2"
  local MATCHES=""
  local INDEX=0
  local TOTAL=${#ENV_SECRET_VALUES[@]}

  while [ $INDEX -lt $TOTAL ]; do
    local VALUE="${ENV_SECRET_VALUES[$INDEX]}"
    local KEY="${ENV_SECRET_KEYS[$INDEX]}"

    while IFS= read -r LINE || [ -n "$LINE" ]; do
      local LINE_NUMBER=${LINE%%:*}

      if is_known_false_positive_match "$STAGED_FILE" "$LINE_NUMBER"; then
        continue
      fi

      MATCHES+="[$DISPLAY_PATH:$LINE_NUMBER] Secret from .env file found (key: $KEY)\n"
    done < <(grep -F -n -- "$VALUE" "$STAGED_FILE" || true)

    INDEX=$((INDEX + 1))
  done

  printf "%b" "$MATCHES"
}

does_file_contain_potential_private_key() {
  local STAGED_FILE="$1"
  local DISPLAY_PATH="$2"
  local MATCHES=""

  while IFS= read -r LINE || [ -n "$LINE" ]; do
    if [ -z "$LINE" ]; then
      continue
    fi

    local LINE_NUMBER=${LINE%%:*}
    local LINE_CONTENT=${LINE#*:}

    if is_known_false_positive_match "$STAGED_FILE" "$LINE_NUMBER"; then
      continue
    fi

    MATCHES+="Potential private key found:\n$DISPLAY_PATH:$LINE_NUMBER:$LINE_CONTENT\n\n"
  done < <(grep -E -n -- "$ETH_PRIVATE_KEY_PATTERN" "$STAGED_FILE" || true)

  printf "%b" "$MATCHES"
}

run_secret_checks() {
  SECRET_FOUND=0
  PRIVATE_KEY_FOUND=0
  SECRET_RESULTS=""

  while IFS= read -r -d '' FILE; do
    if is_excluded_path "$FILE"; then
      continue
    fi

    local STAGED_COPY
    STAGED_COPY=$(mktemp "$TEMP_DIR/staged.XXXXXX")

    if ! git show ":$FILE" > "$STAGED_COPY" 2>/dev/null; then
      rm -f "$STAGED_COPY"
      continue
    fi

    local RESULT_SECRET
    RESULT_SECRET=$(does_file_contain_dot_env_secret "$STAGED_COPY" "$FILE")
    if [ -n "$RESULT_SECRET" ]; then
      SECRET_RESULTS+="$RESULT_SECRET\n"
      SECRET_FOUND=1
    fi

    local RESULT_PRIVKEY
    RESULT_PRIVKEY=$(does_file_contain_potential_private_key "$STAGED_COPY" "$FILE")
    if [ -n "$RESULT_PRIVKEY" ]; then
      SECRET_RESULTS+="$RESULT_PRIVKEY\n"
      PRIVATE_KEY_FOUND=1
    fi

    rm -f "$STAGED_COPY"
  done < <(git diff --cached --name-only --diff-filter=ACM -z)
}

prepare_env_secrets

# Start forge build and lint-staged in parallel (they're independent initially)
FORGE_PID=""
LINT_STAGED_PID=""

print_section "Pre-commit Checks"

# Start parallel tasks
if [ "$HAS_SOL_FILES" = "yes" ]; then
  print_status "info" "Building contracts with forge..."
  (forge build --skip test > "$FORGE_OUTPUT" 2>&1; echo $? > "$FORGE_EXIT") &
  FORGE_PID=$!
else
  print_status "skip" "Skipping forge build (no Solidity files changed)"
  echo 0 > "$FORGE_EXIT"
fi

if [ "$HAS_TYPE_FILES" = "yes" ]; then
  print_status "info" "Running lint-staged (formatting & linting)..."
  (bun lint-staged > "$LINT_STAGED_OUTPUT" 2>&1; echo $? > "$LINT_STAGED_EXIT") &
  LINT_STAGED_PID=$!
else
  print_status "skip" "Skipping lint-staged (no lintable files changed)"
  echo 0 > "$LINT_STAGED_EXIT"
fi

# Wait for forge build if it was started
if [ -n "$FORGE_PID" ]; then
  if ! wait_and_check "$FORGE_PID" "$FORGE_EXIT" "$FORGE_OUTPUT" "Forge build failed. Aborting commit." "forge"; then
    [ -n "$LINT_STAGED_PID" ] && wait "$LINT_STAGED_PID" 2>/dev/null
    exit 1
  fi
  print_status "success" "Forge build completed"
fi

# Run typechain generation (only if forge succeeded and we have Solidity files)
if [ "$HAS_SOL_FILES" = "yes" ]; then
  print_status "info" "Generating TypeChain types..."
  (bun typechain:incremental > "$TYPECHAIN_OUTPUT" 2>&1; echo $? > "$TYPECHAIN_EXIT") &
  TYPECHAIN_PID=$!

  if ! wait_and_check "$TYPECHAIN_PID" "$TYPECHAIN_EXIT" "$TYPECHAIN_OUTPUT" "TypeChain generation failed. Aborting commit." "typechain"; then
    [ -n "$LINT_STAGED_PID" ] && wait "$LINT_STAGED_PID" 2>/dev/null
    exit 1
  fi
  # Extract and show summary from typechain output (filter verbose lines)
  TYPECHAIN_SUMMARY=$(grep -E "(Successfully|typings)" "$TYPECHAIN_OUTPUT" 2>/dev/null | grep -vE "^\$ " | head -1 || echo "TypeChain types generated")
  print_status "success" "$TYPECHAIN_SUMMARY"
fi

# TypeScript compilation check (only if both TS/JS files changed AND typechain was regenerated)
if [ "$HAS_TS_JS_FILES" = "yes" ] && [ "$HAS_SOL_FILES" = "yes" ]; then
  print_status "info" "Checking TypeScript compilation..."
  (bunx tsc-files --noEmit > "$TSC_OUTPUT" 2>&1; echo $? > "$TSC_EXIT") &
  TSC_PID=$!

  if ! wait_and_check "$TSC_PID" "$TSC_EXIT" "$TSC_OUTPUT" "" "tsc"; then
    [ -n "$LINT_STAGED_PID" ] && wait "$LINT_STAGED_PID" 2>/dev/null
    printf '\n\033[31mTypeScript compilation failed.\033[0m\n'
    printf 'This may indicate outdated TypeChain types.\n'
    printf 'Please run \033[1mbun typechain\033[0m manually and fix any type errors before committing.\n\n'
    exit 1
  fi
  print_status "success" "TypeScript compilation passed"
fi

# Wait for lint-staged if it was started
if [ -n "$LINT_STAGED_PID" ]; then
  if ! wait_and_check "$LINT_STAGED_PID" "$LINT_STAGED_EXIT" "$LINT_STAGED_OUTPUT" "Lint-staged failed. Aborting commit." "lint-staged"; then
    exit 1
  fi
  print_status "success" "Lint-staged completed"
fi

print_status "info" "Checking for secrets and private keys..."
run_secret_checks

if [ -n "$SECRET_RESULTS" ]; then
  echo ""
  echo "-------------------------------------- RESULTS: ---------------------------------------------––"
  printf '%b' "$SECRET_RESULTS"
  echo "---------------------------------------------------------------------------------------------––"
fi

if [ "$SECRET_FOUND" -eq 1 ]; then
  print_status "error" "Secret value(s) from .env found. This code cannot be committed."
  print_status "error" "Remove the secrets and try to commit again"
  echo ""
  exit 1
fi

if [ "$PRIVATE_KEY_FOUND" -eq 1 ]; then
  print_status "warning" "Potential Ethereum private keys found"
  echo ""
  print_status "warning" "NEXT STEPS"
  print_status "warning" "Check each match carefully and make sure that no sensitive information is being committed"
  print_status "warning" "If it did happen, undo the commit with 'git reset --soft HEAD~1', remove the secret(s) and commit again."
  print_status "error" "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! BEFORE PUSHING TO GITHUB !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  echo ""
  print_status "success" "Secret check completed (warnings only)"
else
  print_status "success" "Secret check passed"
fi

printf '\n\033[1m━━━ All pre-commit checks passed! ━━━\033[0m\n'
exit 0
