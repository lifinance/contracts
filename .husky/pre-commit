#!/usr/bin/env bash
export HUSKY_SHELL="${HUSKY_SHELL:-bash}"
. "$(dirname -- "$0")/_/husky.sh"

# Early exit: Check if there are any staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
if [ -z "$STAGED_FILES" ]; then
  echo "No files staged for commit. Skipping pre-commit checks."
  exit 0
fi

GIT_ROOT=$(git rev-parse --show-toplevel)
cd "$GIT_ROOT" || exit 1

# Determine what types of files changed for conditional execution (optimized single pass)
HAS_SOL_FILES="no"
HAS_TS_JS_FILES="no"

# Check staged files for Solidity and TypeScript/JavaScript extensions
echo "$STAGED_FILES" | grep -qE '\.sol$' && HAS_SOL_FILES="yes"
echo "$STAGED_FILES" | grep -qE '\.(ts|js|tsx)$' && HAS_TS_JS_FILES="yes"

# Create temp directory for parallel execution
# Try portable form first, fall back to macOS-specific, then mkdir fallback
TEMP_DIR=$(mktemp -d 2>/dev/null) || TEMP_DIR=$(mktemp -d -t precommit 2>/dev/null) || {
  TEMP_DIR="${TMPDIR:-/tmp}/precommit.$$.$(date +%s).$RANDOM"
  mkdir -p "$TEMP_DIR"
}
trap "rm -rf '$TEMP_DIR' 2>/dev/null" EXIT INT TERM

FORGE_OUTPUT="$TEMP_DIR/forge.out"
FORGE_EXIT="$TEMP_DIR/forge.exit"
TYPECHAIN_OUTPUT="$TEMP_DIR/typechain.out"
TYPECHAIN_EXIT="$TEMP_DIR/typechain.exit"
TSC_OUTPUT="$TEMP_DIR/tsc.out"
TSC_EXIT="$TEMP_DIR/tsc.exit"
LINT_STAGED_OUTPUT="$TEMP_DIR/lint-staged.out"
LINT_STAGED_EXIT="$TEMP_DIR/lint-staged.exit"

DISABLE_WITH_COMMENT="pre-commit-checker: not a secret"
ETH_PRIVATE_KEY_PATTERN='(^|[^0-9a-fA-F])[0-9a-fA-F]{64}([^0-9a-fA-F]|$)'
KNOWN_FALSE_POSITIVES=(
  "true"
  "false"
  "none"
  ""
  "verifyContract"
)
EXCLUDED_PATHS=(
  "deployments/_deployments_log_file.json"
  "config/networks.json"
  "lib/"
  "safe/cancun/out/"
  "safe/london/out/"
  "bun.lock"
  ".bun/"
)

ENV_SECRET_KEYS=()
ENV_SECRET_VALUES=()
SECRET_FOUND=0
PRIVATE_KEY_FOUND=0
SECRET_RESULTS=""

# Helper function to print section header
print_section() {
  printf '\n\033[1m━━━ %s ━━━\033[0m\n' "$1"
}

# Helper function to print status
print_status() {
  local status=$1
  local message=$2
  if [ "$status" = "success" ]; then
    printf '\033[32m✓\033[0m %s\n' "$message"
  elif [ "$status" = "warning" ]; then
    # Print the full line in yellow (easy to notice)
    printf '\033[33m⚠ %s\033[0m\n' "$message"
  elif [ "$status" = "skip" ]; then
    printf '\033[33m⊘\033[0m %s\n' "$message"
  elif [ "$status" = "error" ]; then
    # Print the full line in red (easy to notice)
    printf '\033[31m✗ %s\033[0m\n' "$message"
  else
    printf '  %s\n' "$message"
  fi
}

# Helper function to colorize error output
colorize_output() {
  local tool=$1
  local content=$2

  case "$tool" in
    lint-staged)
      # Colorize lint-staged output: file paths in cyan, errors in red, warnings in yellow
      if [ -z "$content" ]; then
        echo "$content"
      else
        # Use $'...' syntax for proper escape sequence interpretation
        echo "$content" | while IFS= read -r line || [ -n "$line" ]; do
          # Colorize file paths (lines that are primarily file paths ending in .sol/.ts/.js/.tsx)
          if echo "$line" | grep -qE '\.(sol|ts|js|tsx)$'; then
            printf $'\033[1;36m%s\033[0m\n' "$line"
            continue
          fi

          # Colorize line numbers (format: number:number)
          line=$(echo "$line" | sed $'s|\\([0-9][0-9]*:[0-9][0-9]*\\)|\033[33m\\1\033[0m|g')

          # Colorize error keyword (standalone word)
          line=$(echo "$line" | sed $'s| error | \033[1;31merror\033[0m |g')
          line=$(echo "$line" | sed $'s|^error |\033[1;31merror\033[0m |')
          line=$(echo "$line" | sed $'s| error$| \033[1;31merror\033[0m|')
          line=$(echo "$line" | sed $'s| Error | \033[1;31mError\033[0m |g')
          line=$(echo "$line" | sed $'s|^Error |\033[1;31mError\033[0m |')
          line=$(echo "$line" | sed $'s| Error$| \033[1;31mError\033[0m|')

          # Colorize warning keyword
          line=$(echo "$line" | sed $'s| warning | \033[1;33mwarning\033[0m |g')
          line=$(echo "$line" | sed $'s|^warning |\033[1;33mwarning\033[0m |')
          line=$(echo "$line" | sed $'s| warning$| \033[1;33mwarning\033[0m|')
          line=$(echo "$line" | sed $'s| Warning | \033[1;33mWarning\033[0m |g')
          line=$(echo "$line" | sed $'s|^Warning |\033[1;33mWarning\033[0m |')
          line=$(echo "$line" | sed $'s| Warning$| \033[1;33mWarning\033[0m|')

          # Colorize problem/problems
          line=$(echo "$line" | sed $'s|problem|\033[1;31m&\033[0m|g')

          # Colorize symbols
          line=$(echo "$line" | sed $'s|✖|\033[1;31m✖\033[0m|g')
          line=$(echo "$line" | sed $'s|⚠|\033[1;33m⚠\033[0m|g')

          printf '%s\n' "$line"
        done
      fi
      ;;
    forge)
      # Colorize forge output: file paths in cyan, errors in red
      if [ -z "$content" ]; then
        echo "$content"
      else
        echo "$content" | sed \
          -e "s|\(--> [^:]*:[0-9]\+:[0-9]\+\)|\033[1;36m\1\033[0m|g" \
          -e "s|\(Error\|Failed\|error\|failed\)|\033[1;31m\1\033[0m|g"
      fi
      ;;
    tsc)
      # Colorize TypeScript output: file paths in cyan, errors in red
      if [ -z "$content" ]; then
        echo "$content"
      else
        echo "$content" | sed \
          -e "s|\([^ ]*\.\(ts\|js\|tsx\)\)|\033[1;36m\1\033[0m|g" \
          -e "s|\(error TS[0-9]\+\)|\033[1;31m\1\033[0m|g"
      fi
      ;;
    *)
      echo "$content"
      ;;
  esac
}

# Helper function to filter verbose output while preserving error context
filter_output() {
  local tool=$1
  local content=$2

  case "$tool" in
    forge)
      # Show errors with full context (file paths, line numbers, error messages)
      # Forge errors have a specific structure with file paths (-->), code snippets (|), and indicators (^)
      # We keep lines containing: error keywords, file paths, code context, or line numbers
      echo "$content" | grep -E "(Error|Failed|error|failed|-->|^\s*\||^\s*\^|^\s*[0-9]+\s*\|)" || true
      ;;
    typechain)
      # Show errors and summary, suppress only the most verbose lines
      echo "$content" | grep -vE "^\$ |^Resolving|^Resolved|^Saved|^Cleaned|^Cleaned duplicate" | grep -E "(Successfully|Error|error|Failed|failed|at |\.ts:|\.js:)" || true
      ;;
    lint-staged)
      # Show only the actual error content, filter out all lint-staged status noise
      # Keep: file paths, line numbers, error messages, warnings, problem counts
      echo "$content" | grep -vE "\[(STARTED|COMPLETED|SKIPPED|FAILED)\]" | \
        grep -vE "Preparing lint-staged" | \
        grep -vE "Running tasks" | \
        grep -vE "Applying modifications" | \
        grep -vE "Cleaning up" | \
        grep -vE "Reverting to original" | \
        grep -vE "Skipped because" | \
        grep -vE "Hiding unstaged" | \
        grep -vE "Restoring unstaged" | \
        grep -vE "package\.json" | \
        grep -vE "\*\.\{ts,js\}" | \
        grep -vE "\*\.sol" | \
        grep -vE "bash -c" | \
        grep -vE "error: \"lint-staged\"" | \
        grep -vE "A new version of Solhint" | \
        grep -vE "Please consider updating" | \
        grep -vE "===> Join SOLHINT" | \
        grep -vE "^<===" | \
        grep -vE "^---" | \
        grep -vE "^$" | \
        grep -vE "^\[solhint\] Warning:" || true
      ;;
    tsc)
      # Show full error output (no line limit), preserve file paths and line numbers
      echo "$content" | grep -vE "^$" || true
      ;;
    *)
      echo "$content"
      ;;
  esac
}

# Helper function to wait for PIDs and exit on failure
wait_and_check() {
  local pid=$1
  local exit_file=$2
  local output_file=$3
  local error_msg=$4
  local tool_name=$5

  if [ -z "$pid" ]; then
    return 0
  fi

  wait "$pid" 2>/dev/null
  local exit_code=$(cat "$exit_file" 2>/dev/null || echo "1")

  if [ "$exit_code" -ne 0 ] && [ -f "$output_file" ]; then
    # Print blank line and error header for visibility
    printf '\n'
    printf '\033[1;31m━━━ %s Error Output ━━━\033[0m\n' "${tool_name:-Error}"
    printf '\n'

    # Show filtered output with full context and colorization
    if [ -n "$tool_name" ]; then
      local filtered_output
      filtered_output=$(filter_output "$tool_name" "$(cat "$output_file")")
      if [ -n "$filtered_output" ]; then
        # Colorize the output for better visibility
        colorize_output "$tool_name" "$filtered_output"
      else
        # If filtering removed everything, show raw output (might be needed for debugging)
        printf '\033[33mWarning: Filtering removed all output. Showing raw output:\033[0m\n'
        cat "$output_file"
      fi
    else
      cat "$output_file"
    fi

    # Print blank line and footer
    printf '\n'
    printf '\033[1;31m━━━ End of %s Error Output ━━━\033[0m\n' "${tool_name:-Error}"
    printf '\n'
  fi

  if [ "$exit_code" -ne 0 ]; then
    [ -n "$error_msg" ] && printf '\033[31m%s\033[0m\n\n' "$error_msg"
    return 1
  fi
  return 0
}

is_excluded_path() {
  local FILE="$1"

  for EXCLUDED_PATH in "${EXCLUDED_PATHS[@]}"; do
    if [[ "$FILE" == "$EXCLUDED_PATH"* ]]; then
      return 0
    fi
  done

  return 1
}

is_known_false_positive_match() {
  local FILE="$1"
  local LINE_NUMBER="$2"

  local PREV_LINE=""
  local CURR_LINE=""

  if [ "$LINE_NUMBER" -gt 1 ]; then
    PREV_LINE=$(sed -n "$((LINE_NUMBER - 1))p" "$FILE")
  fi

  CURR_LINE=$(sed -n "${LINE_NUMBER}p" "$FILE")

  if printf '%s\n%s\n' "$PREV_LINE" "$CURR_LINE" | grep -q "$DISABLE_WITH_COMMENT"; then
    return 0
  fi

  return 1
}

prepare_env_secrets() {
  local ENV_FILE="$GIT_ROOT/.env"
  local ENV_SECRETS_FILE="$TEMP_DIR/env_secrets"

  if [ ! -f "$ENV_FILE" ]; then
    return
  fi

  grep -v '^#' "$ENV_FILE" | sed 's/#.*//' | grep -v '^[[:space:]]*$' | sed 's/[[:space:]]*$//' > "$ENV_SECRETS_FILE"

  while IFS= read -r SECRET_LINE || [ -n "$SECRET_LINE" ]; do
    local KEY=${SECRET_LINE%%=*}
    local VALUE=${SECRET_LINE#*=}

    KEY=$(printf '%s' "$KEY" | sed 's/[[:space:]]*$//')
    VALUE=$(printf '%s' "$VALUE" | sed -e 's/^["'\''"]*//' -e 's/["'\''"]*$//' -e 's/[[:space:]]*$//')

    local IS_FALSE_POSITIVE=false
    for FALSE_POSITIVE in "${KNOWN_FALSE_POSITIVES[@]}"; do
      if [ "$VALUE" = "$FALSE_POSITIVE" ]; then
        IS_FALSE_POSITIVE=true
        break
      fi
    done

    if [ -z "$VALUE" ] || [ "$IS_FALSE_POSITIVE" = true ]; then
      continue
    fi

    ENV_SECRET_KEYS+=("$KEY")
    ENV_SECRET_VALUES+=("$VALUE")
  done < "$ENV_SECRETS_FILE"
}

does_file_contain_dot_env_secret() {
  local STAGED_FILE="$1"
  local DISPLAY_PATH="$2"
  local MATCHES=""
  local INDEX=0
  local TOTAL=${#ENV_SECRET_VALUES[@]}

  while [ $INDEX -lt $TOTAL ]; do
    local VALUE="${ENV_SECRET_VALUES[$INDEX]}"
    local KEY="${ENV_SECRET_KEYS[$INDEX]}"

    while IFS= read -r LINE || [ -n "$LINE" ]; do
      local LINE_NUMBER=${LINE%%:*}

      if is_known_false_positive_match "$STAGED_FILE" "$LINE_NUMBER"; then
        continue
      fi

      MATCHES+="[$DISPLAY_PATH:$LINE_NUMBER] Secret from .env file found (key: $KEY)\n"
    done < <(grep -F -n -- "$VALUE" "$STAGED_FILE" || true)

    INDEX=$((INDEX + 1))
  done

  printf "%b" "$MATCHES"
}

does_file_contain_potential_private_key() {
  local STAGED_FILE="$1"
  local DISPLAY_PATH="$2"
  local MATCHES=""

  while IFS= read -r LINE || [ -n "$LINE" ]; do
    if [ -z "$LINE" ]; then
      continue
    fi

    local LINE_NUMBER=${LINE%%:*}
    local LINE_CONTENT=${LINE#*:}

    if is_known_false_positive_match "$STAGED_FILE" "$LINE_NUMBER"; then
      continue
    fi

    MATCHES+="Potential private key found:\n$DISPLAY_PATH:$LINE_NUMBER:$LINE_CONTENT\n\n"
  done < <(grep -E -n -- "$ETH_PRIVATE_KEY_PATTERN" "$STAGED_FILE" || true)

  printf "%b" "$MATCHES"
}

run_secret_checks() {
  SECRET_FOUND=0
  PRIVATE_KEY_FOUND=0
  SECRET_RESULTS=""

  while IFS= read -r -d '' FILE; do
    if is_excluded_path "$FILE"; then
      continue
    fi

    local STAGED_COPY
    STAGED_COPY=$(mktemp "$TEMP_DIR/staged.XXXXXX")

    if ! git show ":$FILE" > "$STAGED_COPY" 2>/dev/null; then
      rm -f "$STAGED_COPY"
      continue
    fi

    local RESULT_SECRET
    RESULT_SECRET=$(does_file_contain_dot_env_secret "$STAGED_COPY" "$FILE")
    if [ -n "$RESULT_SECRET" ]; then
      SECRET_RESULTS+="$RESULT_SECRET\n"
      SECRET_FOUND=1
    fi

    local RESULT_PRIVKEY
    RESULT_PRIVKEY=$(does_file_contain_potential_private_key "$STAGED_COPY" "$FILE")
    if [ -n "$RESULT_PRIVKEY" ]; then
      SECRET_RESULTS+="$RESULT_PRIVKEY\n"
      PRIVATE_KEY_FOUND=1
    fi

    rm -f "$STAGED_COPY"
  done < <(git diff --cached --name-only --diff-filter=ACMR -z)
}

prepare_env_secrets

# Run secret checks early before heavy work
print_status "info" "Checking for secrets and private keys..."
run_secret_checks

if [ -n "$SECRET_RESULTS" ]; then
  echo ""
  echo "-------------------------------------- RESULTS: ---------------------------------------------––"
  printf '%b' "$SECRET_RESULTS"
  echo "---------------------------------------------------------------------------------------------––"
fi

if [ "$SECRET_FOUND" -eq 1 ]; then
  print_status "error" "Secret value(s) from .env found. This code cannot be committed."
  print_status "error" "Remove the secrets and try to commit again"
  echo ""
  exit 1
fi

if [ "$PRIVATE_KEY_FOUND" -eq 1 ]; then
  print_status "warning" "Potential Ethereum private keys found"
  echo ""
  print_status "warning" "NEXT STEPS"
  print_status "warning" "Check each match carefully and make sure that no sensitive information is being committed"
  print_status "warning" "If it did happen, undo the commit with 'git reset --soft HEAD~1', remove the secret(s) and commit again."
  print_status "error" "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! BEFORE PUSHING TO GITHUB !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  echo ""
  print_status "success" "Secret check completed (warnings only)"
else
  print_status "success" "Secret check passed"
fi

# Start forge build and lint-staged in parallel (they're independent initially)
FORGE_PID=""
LINT_STAGED_PID=""
TSC_PID=""

print_section "Pre-commit Checks"

# Start parallel tasks
if [ "$HAS_SOL_FILES" = "yes" ]; then
  print_status "info" "Building contracts with forge..."
  (forge build --skip test > "$FORGE_OUTPUT" 2>&1; echo $? > "$FORGE_EXIT") &
  FORGE_PID=$!
else
  print_status "skip" "Skipping forge build (no Solidity files changed)"
  echo 0 > "$FORGE_EXIT"
fi

print_status "info" "Running lint-staged (formatting & linting)..."
(bun lint-staged > "$LINT_STAGED_OUTPUT" 2>&1; echo $? > "$LINT_STAGED_EXIT") &
LINT_STAGED_PID=$!

# If we have TS/JS files but no Solidity files, start TypeScript compilation in parallel
# (it doesn't need to wait for typechain in this case)
if [ "$HAS_TS_JS_FILES" = "yes" ] && [ "$HAS_SOL_FILES" = "no" ]; then
  print_status "info" "Checking TypeScript compilation..."
  (bunx tsc-files --noEmit > "$TSC_OUTPUT" 2>&1; echo $? > "$TSC_EXIT") &
  TSC_PID=$!
fi

# Wait for forge build if it was started
if [ -n "$FORGE_PID" ]; then
  if ! wait_and_check "$FORGE_PID" "$FORGE_EXIT" "$FORGE_OUTPUT" "Forge build failed. Aborting commit." "forge"; then
    [ -n "$LINT_STAGED_PID" ] && wait "$LINT_STAGED_PID" 2>/dev/null
    [ -n "$TSC_PID" ] && wait "$TSC_PID" 2>/dev/null
    exit 1
  fi
  print_status "success" "Forge build completed"
fi

# Run typechain generation (only if forge succeeded and we have Solidity files)
if [ "$HAS_SOL_FILES" = "yes" ]; then
  print_status "info" "Generating TypeChain types..."
  (bun typechain:incremental > "$TYPECHAIN_OUTPUT" 2>&1; echo $? > "$TYPECHAIN_EXIT") &
  TYPECHAIN_PID=$!

  if ! wait_and_check "$TYPECHAIN_PID" "$TYPECHAIN_EXIT" "$TYPECHAIN_OUTPUT" "TypeChain generation failed. Aborting commit." "typechain"; then
    [ -n "$LINT_STAGED_PID" ] && wait "$LINT_STAGED_PID" 2>/dev/null
    [ -n "$TSC_PID" ] && wait "$TSC_PID" 2>/dev/null
    exit 1
  fi
  # Extract and show summary from typechain output (filter verbose lines)
  TYPECHAIN_SUMMARY=$(grep -E "(Successfully|typings)" "$TYPECHAIN_OUTPUT" 2>/dev/null | grep -vE "^\$ " | head -1 || echo "TypeChain types generated")
  print_status "success" "$TYPECHAIN_SUMMARY"
fi

# TypeScript compilation check (only if TS/JS files changed)
# If we have Solidity files, we need to wait for typechain (already done above)
# If we don't have Solidity files, tsc is already running in parallel
if [ "$HAS_TS_JS_FILES" = "yes" ] && [ "$HAS_SOL_FILES" = "yes" ]; then
  print_status "info" "Checking TypeScript compilation..."
  (bunx tsc-files --noEmit > "$TSC_OUTPUT" 2>&1; echo $? > "$TSC_EXIT") &
  TSC_PID=$!
fi

# Wait for all remaining parallel tasks (tsc and lint-staged)
# Check if tsc is running and wait for it
if [ -n "$TSC_PID" ]; then
  if ! wait_and_check "$TSC_PID" "$TSC_EXIT" "$TSC_OUTPUT" "" "tsc"; then
    [ -n "$LINT_STAGED_PID" ] && wait "$LINT_STAGED_PID" 2>/dev/null
    printf '\n\033[31mTypeScript compilation failed.\033[0m\n'
    printf 'This may indicate outdated TypeChain types.\n'
    printf 'Please run \033[1mbun typechain\033[0m manually and fix any type errors before committing.\n\n'
    exit 1
  fi
  print_status "success" "TypeScript compilation passed"
fi

# Wait for lint-staged if it was started
if [ -n "$LINT_STAGED_PID" ]; then
  if ! wait_and_check "$LINT_STAGED_PID" "$LINT_STAGED_EXIT" "$LINT_STAGED_OUTPUT" "Lint-staged failed. Aborting commit." "lint-staged"; then
    exit 1
  fi
  print_status "success" "Lint-staged completed"
fi

printf '\n\033[1m━━━ All pre-commit checks passed! ━━━\033[0m\n'
exit 0
