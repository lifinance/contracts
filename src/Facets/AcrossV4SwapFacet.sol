// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity ^0.8.17;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ILiFi } from "../Interfaces/ILiFi.sol";
import { IAcrossSpokePoolV4 } from "../Interfaces/IAcrossSpokePoolV4.sol";
import { ISpokePoolPeriphery } from "../Interfaces/ISpokePoolPeriphery.sol";
import { ISponsoredCCTPSrcPeriphery } from "../Interfaces/ISponsoredCCTPSrcPeriphery.sol";
import { ISponsoredOFTSrcPeriphery } from "../Interfaces/ISponsoredOFTSrcPeriphery.sol";
import { LibAsset } from "../Libraries/LibAsset.sol";
import { LibSwap } from "../Libraries/LibSwap.sol";
import { ReentrancyGuard } from "../Helpers/ReentrancyGuard.sol";
import { SwapperV2 } from "../Helpers/SwapperV2.sol";
import { Validatable } from "../Helpers/Validatable.sol";
import { InvalidConfig, InformationMismatch, InvalidReceiver, InvalidNonEVMReceiver, InvalidCallData } from "../Errors/GenericErrors.sol";
import { LiFiData } from "../Helpers/LiFiData.sol";

/// @title AcrossV4SwapFacet
/// @author LI.FI (https://li.fi)
/// @notice Provides functionality for bridging through Across Protocol using the Swap API
/// @dev This contract does not custody user funds. Any native tokens received are either forwarded
///      to the underlying Across contracts or refunded to the sender via the refundExcessNative modifier.
///      IMPORTANT: This facet is calldata-driven and expects ABI-encoded calldata generated by trusted
///      infrastructure (e.g., LI.FI backend / Across Swap API). Supplying arbitrary calldata (especially for
///      SpokePoolPeriphery swap routes) can lead to loss of funds.
/// @custom:version 1.0.0
contract AcrossV4SwapFacet is
    ILiFi,
    ReentrancyGuard,
    SwapperV2,
    Validatable,
    LiFiData
{
    /// Storage ///

    /// @notice The contract address of the SpokePoolPeriphery on the source chain
    ISpokePoolPeriphery public immutable SPOKE_POOL_PERIPHERY;

    /// @notice The contract address of the SpokePool on the source chain
    address public immutable SPOKE_POOL;

    /// @notice The contract address of the SponsoredOFTSrcPeriphery on the source chain
    address public immutable SPONSORED_OFT_SRC_PERIPHERY;

    /// @notice The contract address of the SponsoredCCTPSrcPeriphery on the source chain
    address public immutable SPONSORED_CCTP_SRC_PERIPHERY;

    /// @notice The Across custom chain ID for Solana
    uint256 public constant ACROSS_CHAIN_ID_SOLANA = 34268394551451;

    /// @notice The base for the outputAmountMultiplier (to allow room for adjustments in both directions)
    uint256 public constant MULTIPLIER_BASE = 1e18;

    /// Types ///

    /// @notice The Across Swap API contract that should be called
    enum SwapApiTarget {
        SpokePool,
        SpokePoolPeriphery,
        SponsoredOFTSrcPeriphery,
        SponsoredCCTPSrcPeriphery
    }

    /// @notice Data specific to Across V4 Swap API bridging (enum + opaque calldata)
    /// @param swapApiTarget Which Across contract should be called (0-3)
    /// @param callData ABI-encoded calldata for the selected target contract (no selector)
    struct AcrossV4SwapFacetData {
        SwapApiTarget swapApiTarget;
        bytes callData;
    }

    /// Constructor ///

    /// @notice Initialize the contract
    /// @param _spokePoolPeriphery The contract address of the SpokePoolPeriphery
    /// @param _spokePool The contract address of the SpokePool
    /// @param _sponsoredOftSrcPeriphery The contract address of the SponsoredOFTSrcPeriphery
    /// @param _sponsoredCctpSrcPeriphery The contract address of the SponsoredCCTPSrcPeriphery
    constructor(
        ISpokePoolPeriphery _spokePoolPeriphery,
        address _spokePool,
        address _sponsoredOftSrcPeriphery,
        address _sponsoredCctpSrcPeriphery
    ) {
        if (
            address(_spokePoolPeriphery) == address(0) ||
            _spokePool == address(0)
        ) {
            revert InvalidConfig();
        }

        SPOKE_POOL_PERIPHERY = _spokePoolPeriphery;
        SPOKE_POOL = _spokePool;
        SPONSORED_OFT_SRC_PERIPHERY = _sponsoredOftSrcPeriphery;
        SPONSORED_CCTP_SRC_PERIPHERY = _sponsoredCctpSrcPeriphery;
    }

    /// External Methods ///

    /// @notice Bridges tokens via Across using the Swap API
    /// @param _bridgeData The core information needed for bridging
    /// @param _acrossV4SwapFacetData Data specific to Across V4 Swap API (enum + calldata)
    function startBridgeTokensViaAcrossV4Swap(
        ILiFi.BridgeData memory _bridgeData,
        AcrossV4SwapFacetData calldata _acrossV4SwapFacetData
    )
        external
        payable
        nonReentrant
        refundExcessNative(payable(msg.sender))
        validateBridgeData(_bridgeData)
        doesNotContainSourceSwaps(_bridgeData)
        doesNotContainDestinationCalls(_bridgeData)
    {
        LibAsset.depositAsset(
            _bridgeData.sendingAssetId,
            _bridgeData.minAmount
        );
        _startBridge(_bridgeData, _acrossV4SwapFacetData, 0);
    }

    /// @notice Performs a swap before bridging via Across using the Swap API
    /// @param _bridgeData The core information needed for bridging
    /// @param _swapData An array of swap related data for performing swaps before bridging
    /// @param _acrossV4SwapFacetData Data specific to Across V4 Swap API (enum + calldata)
    function swapAndStartBridgeTokensViaAcrossV4Swap(
        ILiFi.BridgeData memory _bridgeData,
        LibSwap.SwapData[] calldata _swapData,
        AcrossV4SwapFacetData calldata _acrossV4SwapFacetData
    )
        external
        payable
        nonReentrant
        refundExcessNative(payable(msg.sender))
        validateBridgeData(_bridgeData)
        containsSourceSwaps(_bridgeData)
        doesNotContainDestinationCalls(_bridgeData)
    {
        // deposit funds and execute swaps / fee collection, if applicable
        uint256 preSwapAmount = _bridgeData.minAmount;
        _bridgeData.minAmount = _depositAndSwap(
            _bridgeData.transactionId,
            _bridgeData.minAmount,
            _swapData,
            payable(msg.sender)
        );

        // depending on if we have positive slippage, we take a different path from here
        // these helpers were introduced to prevent stack-too-deep error
        if (_bridgeData.minAmount > preSwapAmount) {
            // non-zero sentinel: enables positive-slippage handling
            _startBridge(_bridgeData, _acrossV4SwapFacetData, preSwapAmount);
        } else {
            // zero sentinel: no positive-slippage handling
            _startBridge(_bridgeData, _acrossV4SwapFacetData, 0);
        }
    }

    /// Internal Methods ///

    /// @dev Contains the business logic for bridging via Across Swap API using target+calldata
    /// @param _bridgeData The core information needed for bridging
    /// @param _acrossV4SwapFacetData Data specific to Across V4 Swap API (enum + calldata)
    /// @param _preSwapAmount If non-zero, indicates the pre-swap amount for positive-slippage handling (0 disables it)
    function _startBridge(
        ILiFi.BridgeData memory _bridgeData,
        AcrossV4SwapFacetData calldata _acrossV4SwapFacetData,
        uint256 _preSwapAmount
    ) internal {
        SwapApiTarget swapApiTarget = _acrossV4SwapFacetData.swapApiTarget;
        bytes calldata callData = _acrossV4SwapFacetData.callData;

        // Positive slippage handling:
        // - Unsigned calldata-based flows (SpokePool/SpokePoolPeriphery): we can adjust encoded amounts.
        // - Sponsored flows (signed quotes): we must not change the signed amount; instead refund any surplus.

        // call the respective deposit function based on the swapApiTarget
        if (swapApiTarget == SwapApiTarget.SpokePool) {
            _callSpokePoolDeposit(_bridgeData, callData, _preSwapAmount);
        } else if (swapApiTarget == SwapApiTarget.SpokePoolPeriphery) {
            _callSpokePoolPeripherySwapAndBridge(
                _bridgeData,
                callData,
                _preSwapAmount
            );
        } else if (swapApiTarget == SwapApiTarget.SponsoredOFTSrcPeriphery) {
            _callSponsoredOftDeposit(_bridgeData, callData, _preSwapAmount);
        } else if (swapApiTarget == SwapApiTarget.SponsoredCCTPSrcPeriphery) {
            _callSponsoredCctpDepositForBurn(
                _bridgeData,
                callData,
                _preSwapAmount
            );
        } else {
            revert InvalidCallData();
        }

        emit LiFiTransferStarted(_bridgeData);
    }

    /// @dev Decodes and executes an Across SpokePool deposit using ABI-encoded params.
    /// @param _bridgeData The core information needed for bridging
    /// @param _callData ABI-encoded deposit params (no selector)
    /// @param _preSwapAmount If non-zero, indicates the pre-swap amount for positive-slippage handling (0 disables it)
    function _callSpokePoolDeposit(
        ILiFi.BridgeData memory _bridgeData,
        bytes calldata _callData,
        uint256 _preSwapAmount
    ) internal {
        IAcrossSpokePoolV4.DepositParams memory params = abi.decode(
            _callData,
            (IAcrossSpokePoolV4.DepositParams)
        );

        // If this is the positive-slippage path, adjust the amounts after decoding but before validation.
        if (_preSwapAmount != 0) {
            // Derive output/input ratio from the quote calldata itself (includes fees + decimal differences).
            uint256 outputAmountMultiplier = (params.outputAmount *
                MULTIPLIER_BASE) / _preSwapAmount;
            params.inputAmount = _bridgeData.minAmount;
            params.outputAmount =
                (_bridgeData.minAmount * outputAmountMultiplier) /
                MULTIPLIER_BASE;
        }

        _validateDestinationChainId(
            _bridgeData.destinationChainId,
            params.destinationChainId
        );

        // NOTE: Do only use this facet if you trust the Across Swap API.
        // Across uses a receiver contract on dst chain to execute destination calldata.
        // We cannot validate the final receiver address here since its somewhere encoded in DepositParams.message.
        _validateReceiverAndEmitNonEvmEvent(
            _bridgeData,
            params.recipient,
            false // do not ensure that params.recipient matches bridgeData.receiver (would fail)
        );

        // Validate depositor/refund address to prevent lost funds
        if (params.depositor == bytes32(0)) {
            revert InvalidCallData();
        }

        // Validate amount matches bridgeData
        _validateAmount(params.inputAmount, _bridgeData.minAmount);

        // Validate asset matches for ERC20 flows
        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {
            address decodedInputToken = address(
                uint160(uint256(params.inputToken))
            );
            if (decodedInputToken != _bridgeData.sendingAssetId) {
                revert InformationMismatch();
            }

            LibAsset.maxApproveERC20(
                IERC20(_bridgeData.sendingAssetId),
                SPOKE_POOL,
                _bridgeData.minAmount
            );
        }

        uint256 msgValue = LibAsset.isNativeAsset(_bridgeData.sendingAssetId)
            ? _bridgeData.minAmount
            : 0;
        // NOTE: Single-use helper to avoid "stack too deep" in `_callSpokePoolDeposit` (deposit has many args).
        _depositToSpokePool(params, msgValue);
    }

    /// @dev Decodes and executes an Across SpokePoolPeriphery swap+bridge using ABI-encoded params.
    /// @param _bridgeData The core information needed for bridging
    /// @param _callData ABI-encoded swap+deposit params (no selector)
    /// @param _preSwapAmount If non-zero, indicates the pre-swap amount for positive-slippage handling (0 disables it)
    function _callSpokePoolPeripherySwapAndBridge(
        ILiFi.BridgeData memory _bridgeData,
        bytes calldata _callData,
        uint256 _preSwapAmount
    ) internal {
        ISpokePoolPeriphery.SwapAndDepositData memory swapAndDepositData = abi
            .decode(_callData, (ISpokePoolPeriphery.SwapAndDepositData));

        // If this is the positive-slippage path, adjust the amounts after decoding but before validation.
        if (_preSwapAmount != 0) {
            uint256 outputAmountMultiplier = (swapAndDepositData
                .depositData
                .outputAmount * MULTIPLIER_BASE) / _preSwapAmount;

            // Adjust outputAmount based on the updated minAmount and derived multiplier.
            swapAndDepositData.depositData.outputAmount =
                (_bridgeData.minAmount * outputAmountMultiplier) /
                MULTIPLIER_BASE;

            // Adjust minExpectedInputTokenAmount proportionally.
            swapAndDepositData.minExpectedInputTokenAmount =
                (swapAndDepositData.minExpectedInputTokenAmount *
                    _bridgeData.minAmount) /
                _preSwapAmount;

            swapAndDepositData.swapTokenAmount = _bridgeData.minAmount;
        }

        // Validate the embedded spoke pool matches the configured spoke pool.
        if (swapAndDepositData.spokePool != SPOKE_POOL) {
            revert InformationMismatch();
        }

        _validateDestinationChainId(
            _bridgeData.destinationChainId,
            swapAndDepositData.depositData.destinationChainId
        );

        // NOTE: Do only use this facet if you trust the Across Swap API.
        // Across uses a receiver contract on dst chain to execute destination calldata.
        // We cannot validate the final receiver address here since its somewhere encoded in DepositParams.message.
        _validateReceiverAndEmitNonEvmEvent(
            _bridgeData,
            swapAndDepositData.depositData.recipient,
            false // do not ensure that swapAndDepositData.depositData.recipient matches _bridgeData.receiver (would fail)
        );

        // Validate depositor/refund address to prevent lost funds
        if (swapAndDepositData.depositData.depositor == address(0)) {
            revert InvalidCallData();
        }

        // Validate amount matches bridgeData
        _validateAmount(
            swapAndDepositData.swapTokenAmount,
            _bridgeData.minAmount
        );

        uint256 msgValue;
        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {
            msgValue = _bridgeData.minAmount;
        } else {
            // For ERC20, ensure swapToken matches sendingAssetId (what the diamond holds).
            if (swapAndDepositData.swapToken != _bridgeData.sendingAssetId) {
                revert InformationMismatch();
            }

            // register max approval in case current approval is insufficient
            LibAsset.maxApproveERC20(
                IERC20(_bridgeData.sendingAssetId),
                address(SPOKE_POOL_PERIPHERY),
                _bridgeData.minAmount
            );
        }

        SPOKE_POOL_PERIPHERY.swapAndBridge{ value: msgValue }(
            swapAndDepositData
        );
    }

    /// @dev Decodes and executes a Sponsored OFT source periphery deposit using ABI-encoded quote+signature.
    /// @param _bridgeData The core information needed for bridging
    /// @param _callData ABI-encoded (Quote, signature) tuple (no selector)
    function _callSponsoredOftDeposit(
        ILiFi.BridgeData memory _bridgeData,
        bytes calldata _callData,
        uint256 _preSwapAmount
    ) internal {
        // Sponsored OFT flow is ERC20-based (token is pulled via transferFrom(msg.sender,...)).
        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {
            revert InvalidCallData();
        }

        (
            ISponsoredOFTSrcPeriphery.Quote memory quote,
            bytes memory signature
        ) = abi.decode(_callData, (ISponsoredOFTSrcPeriphery.Quote, bytes));

        // If this is the positive-slippage path, refund any surplus and bridge the originally quoted amount.
        // We MUST NOT change the signed quote amount, otherwise the signature would become invalid.
        if (_preSwapAmount != 0) {
            uint256 refundAmount = _bridgeData.minAmount - _preSwapAmount;
            // Refund to quote refundRecipient (Across-sponsored refunds are paid to this address).
            LibAsset.transferERC20(
                _bridgeData.sendingAssetId,
                quote.unsignedParams.refundRecipient,
                refundAmount
            );
            _bridgeData.minAmount = _preSwapAmount;
        }

        _validateReceiverAndEmitNonEvmEvent(
            _bridgeData,
            quote.signedParams.finalRecipient,
            true
        );

        // Validate refund address to prevent lost funds
        if (quote.unsignedParams.refundRecipient == address(0)) {
            revert InvalidCallData();
        }

        // Validate amount matches bridgeData
        _validateAmount(quote.signedParams.amountLD, _bridgeData.minAmount);

        LibAsset.maxApproveERC20(
            IERC20(_bridgeData.sendingAssetId),
            SPONSORED_OFT_SRC_PERIPHERY,
            _bridgeData.minAmount
        );

        ISponsoredOFTSrcPeriphery(SPONSORED_OFT_SRC_PERIPHERY).deposit{
            value: msg.value
        }(quote, signature);
    }

    /// @dev Decodes and executes a Sponsored CCTP source periphery depositForBurn using ABI-encoded quote+signature.
    /// @param _bridgeData The core information needed for bridging
    /// @param _callData ABI-encoded (SponsoredCCTPQuote, signature) tuple (no selector)
    function _callSponsoredCctpDepositForBurn(
        ILiFi.BridgeData memory _bridgeData,
        bytes calldata _callData,
        uint256 _preSwapAmount
    ) internal {
        (
            ISponsoredCCTPSrcPeriphery.SponsoredCCTPQuote memory quote,
            bytes memory signature
        ) = abi.decode(
                _callData,
                (ISponsoredCCTPSrcPeriphery.SponsoredCCTPQuote, bytes)
            );

        // If this is the positive-slippage path, refund any surplus and bridge the originally quoted amount.
        // We MUST NOT change the signed quote amount, otherwise the signature would become invalid.
        if (_preSwapAmount != 0) {
            uint256 refundAmount = _bridgeData.minAmount - _preSwapAmount;
            // Sponsored CCTP quote does not include a refund recipient; refund to the caller.
            LibAsset.transferERC20(
                _bridgeData.sendingAssetId,
                msg.sender,
                refundAmount
            );
            _bridgeData.minAmount = _preSwapAmount;
        }

        // Validate destination mapping (LiFi chainId -> CCTP domain) to prevent offchain/onchain mismatch.
        if (
            quote.destinationDomain !=
            _chainIdToCctpDomainId(_bridgeData.destinationChainId)
        ) {
            revert InformationMismatch();
        }

        _validateReceiverAndEmitNonEvmEvent(
            _bridgeData,
            quote.finalRecipient,
            true
        );

        // depositForBurn is not payable
        if (msg.value != 0) revert InvalidCallData();

        // Validate amount matches bridgeData
        _validateAmount(quote.amount, _bridgeData.minAmount);

        // Validate burnToken matches bridgeData asset
        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {
            revert InvalidCallData();
        }
        address burnToken = address(uint160(uint256(quote.burnToken)));
        if (burnToken != _bridgeData.sendingAssetId) {
            revert InformationMismatch();
        }

        LibAsset.maxApproveERC20(
            IERC20(_bridgeData.sendingAssetId),
            SPONSORED_CCTP_SRC_PERIPHERY,
            _bridgeData.minAmount
        );

        ISponsoredCCTPSrcPeriphery(SPONSORED_CCTP_SRC_PERIPHERY)
            .depositForBurn(quote, signature);
    }

    /// @dev Performs the actual SpokePool deposit call (split out to avoid "stack too deep").
    /// @param _params Decoded deposit params
    /// @param _msgValue Native value to forward with the deposit call
    function _depositToSpokePool(
        IAcrossSpokePoolV4.DepositParams memory _params,
        uint256 _msgValue
    ) internal {
        IAcrossSpokePoolV4(SPOKE_POOL).deposit{ value: _msgValue }(
            _params.depositor,
            _params.recipient,
            _params.inputToken,
            _params.outputToken,
            _params.inputAmount,
            _params.outputAmount,
            _params.destinationChainId,
            _params.exclusiveRelayer,
            _params.quoteTimestamp,
            _params.fillDeadline,
            _params.exclusivityParameter,
            _params.message
        );
    }

    /// @notice Converts LiFi internal (non-EVM) chain IDs to Across chain IDs
    ///         For EVM chainIds there is no need to convert, they will just returned as-is
    /// @param _destinationChainId The LiFi chain ID to convert
    function _getAcrossChainId(
        uint256 _destinationChainId
    ) internal pure returns (uint256) {
        // currently only Solana has a custom chainId
        if (_destinationChainId == LIFI_CHAIN_ID_SOLANA) {
            return ACROSS_CHAIN_ID_SOLANA;
        } else {
            return _destinationChainId;
        }
    }

    /// @dev Validates and emits the non-EVM receiver event when bridging to non-EVM destinations.
    /// @param _bridgeData The core information needed for bridging
    /// @param _recipient The recipient bytes32 decoded from calldata
    /// @param _enforceEvmMatch If true, enforces that `_recipient` matches `_bridgeData.receiver` for EVM destinations
    function _validateReceiverAndEmitNonEvmEvent(
        ILiFi.BridgeData memory _bridgeData,
        bytes32 _recipient,
        bool _enforceEvmMatch
    ) internal {
        // non-EVM destination path
        if (_bridgeData.receiver == NON_EVM_ADDRESS) {
            if (_recipient == bytes32(0)) revert InvalidNonEVMReceiver();
            emit BridgeToNonEVMChainBytes32(
                _bridgeData.transactionId,
                _bridgeData.destinationChainId,
                _recipient
            );
            return;
        }

        if (_recipient == bytes32(0)) revert InvalidReceiver();
        if (
            _enforceEvmMatch &&
            _recipient != _convertAddressToBytes32(_bridgeData.receiver)
        ) {
            revert InvalidReceiver();
        }
    }

    /// @dev Validates that a decoded amount matches the bridgeData minAmount.
    /// @param _provided The amount decoded from calldata
    /// @param _expected The expected amount (bridgeData.minAmount)
    function _validateAmount(
        uint256 _provided,
        uint256 _expected
    ) internal pure {
        if (_provided != _expected) {
            revert InformationMismatch();
        }
    }

    /// @dev Validates that the decoded Across destination chain ID matches the expected Across chain ID.
    /// @param _lifiDestinationChainId The LiFi destination chain ID
    /// @param _acrossDestinationChainId The Across destination chain ID decoded from calldata
    function _validateDestinationChainId(
        uint256 _lifiDestinationChainId,
        uint256 _acrossDestinationChainId
    ) internal pure {
        if (
            _acrossDestinationChainId !=
            _getAcrossChainId(_lifiDestinationChainId)
        ) {
            revert InformationMismatch();
        }
    }

    /// @notice Get CCTP domain ID for destination chain
    /// @dev For Sponsored CCTP flows, the quote uses Circle domains (not EVM chainIds). We validate that the
    ///      provided `BridgeData.destinationChainId` maps to the same Circle domain as in the signed quote.
    ///      Reference: https://developers.circle.com/cctp/cctp-supported-blockchains#cctp-v2-supported-domains
    /// @param _chainId LI.FI destination chain id
    /// @return CCTP domain ID recognized by Circle TokenMessenger / CCTP periphery
    // solhint-disable-next-line code-complexity
    function _chainIdToCctpDomainId(
        uint256 _chainId
    ) internal pure returns (uint32) {
        // Mainnet chain IDs
        if (_chainId == 1) return 0; // Ethereum
        if (_chainId == 43114) return 1; // Avalanche
        if (_chainId == 10) return 2; // OP Mainnet
        if (_chainId == 42161) return 3; // Arbitrum
        if (_chainId == LIFI_CHAIN_ID_SOLANA) return 5; // Solana
        if (_chainId == 8453) return 6; // Base
        if (_chainId == 137) return 7; // Polygon PoS
        if (_chainId == 130) return 10; // Unichain
        if (_chainId == 59144) return 11; // Linea
        if (_chainId == 81224) return 12; // Codex
        if (_chainId == 146) return 13; // Sonic
        if (_chainId == 480) return 14; // World Chain
        if (_chainId == 1329) return 16; // Sei
        if (_chainId == 50) return 18; // XDC
        if (_chainId == 999) return 19; // HyperEVM
        if (_chainId == 1337) return 19; // HyperCore (via HyperEVM)
        if (_chainId == 57073) return 21; // Ink
        if (_chainId == 98866) return 22; // Plume
        revert InvalidCallData();
    }

    /// @notice Converts an address to a bytes32
    /// @param _address The address to convert
    function _convertAddressToBytes32(
        address _address
    ) internal pure returns (bytes32) {
        return bytes32(uint256(uint160(_address)));
    }
}
