// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity ^0.8.17;

import { ILiFi } from "../Interfaces/ILiFi.sol";
import { LibAsset } from "../Libraries/LibAsset.sol";
import { LibSwap } from "../Libraries/LibSwap.sol";
import { ReentrancyGuard } from "../Helpers/ReentrancyGuard.sol";
import { SwapperV2 } from "../Helpers/SwapperV2.sol";
import { Validatable } from "../Helpers/Validatable.sol";

/// @title NEARIntentsFacet
/// @author LI.FI (https://li.fi)
/// @notice Provides functionality for bridging through NEAR Intents Protocol
/// @custom:version 1.0.0
/// @dev This facet does NOT verify intent signatures on-chain. All verification
///      happens on intents.near. This facet simply transfers tokens to deposit
///      addresses generated by the Bridge API.
contract NEARIntentsFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {
    /// Types ///

    /// @notice NEAR Intents specific parameters
    /// @param quoteId Unique identifier from 1Click API quote response
    /// @param depositAddress EVM address to send tokens (from Bridge API)
    /// @param deadline Unix timestamp when quote expires (refunds begin if unfulfilled)
    /// @param minAmountOut Minimum output amount on destination (slippage protection)
    struct NEARIntentsData {
        bytes32 quoteId;
        address depositAddress;
        uint256 deadline;
        uint256 minAmountOut;
    }

    /// Storage ///

    /// @notice Namespace for diamond storage
    bytes32 internal constant NAMESPACE =
        keccak256("com.lifi.facets.nearintents");

    /// @notice Diamond storage structure (minimal - only replay protection)
    struct Storage {
        /// @dev Mapping to prevent duplicate quote usage (quoteId => consumed)
        mapping(bytes32 => bool) consumedQuoteIds;
    }

    /// Events ///

    /// @notice Emitted when a bridge operation starts via NEAR Intents
    /// @param transactionId Unique transaction identifier
    /// @param quoteId NEAR Intents quote identifier
    /// @param depositAddress Address tokens were sent to
    /// @param sendingAssetId Token being bridged
    /// @param amount Amount being bridged
    /// @param deadline Quote expiration timestamp
    event NEARIntentsBridgeStarted(
        bytes32 indexed transactionId,
        bytes32 indexed quoteId,
        address indexed depositAddress,
        address sendingAssetId,
        uint256 amount,
        uint256 deadline
    );

    /// Errors ///

    /// @notice Thrown when trying to use a quote that was already consumed
    error QuoteAlreadyConsumed();

    /// @notice Thrown when the quote deadline has passed
    error QuoteExpired();

    /// @notice Thrown when the deposit address is zero
    error InvalidDepositAddress();

    /// @notice Thrown when native token transfer fails
    error NativeTransferFailed();

    /// Modifiers ///

    /// @dev Validates quote parameters
    /// @param _nearData Data specific to NEAR Intents
    modifier onlyValidQuote(NEARIntentsData calldata _nearData) {
        _validateQuote(_nearData);
        _;
    }

    /// External Methods ///

    /// @notice Bridges tokens via NEAR Intents
    /// @param _bridgeData The core information needed for bridging
    /// @param _nearData Data specific to NEAR Intents
    function startBridgeTokensViaNEARIntents(
        ILiFi.BridgeData calldata _bridgeData,
        NEARIntentsData calldata _nearData
    )
        external
        payable
        nonReentrant
        onlyValidQuote(_nearData)
        refundExcessNative(payable(msg.sender))
        validateBridgeData(_bridgeData)
        doesNotContainSourceSwaps(_bridgeData)
        doesNotContainDestinationCalls(_bridgeData)
    {
        LibAsset.depositAsset(
            _bridgeData.sendingAssetId,
            _bridgeData.minAmount
        );
        _startBridge(_bridgeData, _nearData);
    }

    /// @notice Performs a swap before bridging via NEAR Intents
    /// @param _bridgeData The core information needed for bridging
    /// @param _swapData An array of swap related data for performing swaps
    /// @param _nearData Data specific to NEAR Intents
    function swapAndStartBridgeTokensViaNEARIntents(
        ILiFi.BridgeData memory _bridgeData,
        LibSwap.SwapData[] calldata _swapData,
        NEARIntentsData calldata _nearData
    )
        external
        payable
        nonReentrant
        onlyValidQuote(_nearData)
        refundExcessNative(payable(msg.sender))
        containsSourceSwaps(_bridgeData)
        doesNotContainDestinationCalls(_bridgeData)
        validateBridgeData(_bridgeData)
    {
        _bridgeData.minAmount = _depositAndSwap(
            _bridgeData.transactionId,
            _bridgeData.minAmount,
            _swapData,
            payable(msg.sender)
        );
        _startBridge(_bridgeData, _nearData);
    }

    /// View Functions ///

    /// @notice Check if a quote has been consumed
    /// @param _quoteId The quote ID to check
    /// @return consumed Whether the quote has been used
    function isQuoteConsumed(
        bytes32 _quoteId
    ) external view returns (bool consumed) {
        return getStorage().consumedQuoteIds[_quoteId];
    }

    /// Internal Methods ///

    /// @dev Contains the business logic for bridging via NEAR Intents
    /// @param _bridgeData The core information needed for bridging
    /// @param _nearData Data specific to NEAR Intents
    function _startBridge(
        ILiFi.BridgeData memory _bridgeData,
        NEARIntentsData calldata _nearData
    ) internal {
        Storage storage s = getStorage();

        // Mark quote as consumed BEFORE external interactions (CEI pattern)
        s.consumedQuoteIds[_nearData.quoteId] = true;

        // Transfer tokens to the deposit address generated by Bridge API
        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {
            // Native token transfer
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, ) = _nearData.depositAddress.call{
                value: _bridgeData.minAmount
            }("");
            if (!success) revert NativeTransferFailed();
        } else {
            // ERC20 transfer
            LibAsset.transferAsset(
                _bridgeData.sendingAssetId,
                payable(_nearData.depositAddress),
                _bridgeData.minAmount
            );
        }

        // Emit events (reduce stack depth by avoiding complex struct access in emit)
        _emitEvents(_bridgeData, _nearData);
    }

    /// @dev Emits bridge events
    /// @param _bridgeData The core information needed for bridging
    /// @param _nearData Data specific to NEAR Intents
    function _emitEvents(
        ILiFi.BridgeData memory _bridgeData,
        NEARIntentsData calldata _nearData
    ) private {
        emit NEARIntentsBridgeStarted(
            _bridgeData.transactionId,
            _nearData.quoteId,
            _nearData.depositAddress,
            _bridgeData.sendingAssetId,
            _bridgeData.minAmount,
            _nearData.deadline
        );

        emit LiFiTransferStarted(_bridgeData);
    }

    /// Private Methods ///

    /// @dev Validates quote parameters
    /// @param _nearData Data specific to NEAR Intents
    function _validateQuote(NEARIntentsData calldata _nearData) private view {
        Storage storage s = getStorage();

        // Prevent replay attacks
        if (s.consumedQuoteIds[_nearData.quoteId]) {
            revert QuoteAlreadyConsumed();
        }

        // Ensure quote hasn't expired
        if (block.timestamp >= _nearData.deadline) {
            revert QuoteExpired();
        }

        // Ensure deposit address is valid
        if (_nearData.depositAddress == address(0)) {
            revert InvalidDepositAddress();
        }
    }

    /// @dev Gets the diamond storage for this facet
    /// @return s The storage struct
    function getStorage() private pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}
