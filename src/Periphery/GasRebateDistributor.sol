// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import { TransferrableOwnership } from "../Helpers/TransferrableOwnership.sol";
import { MerkleProof } from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import { NativeAssetTransferFailed } from "../Errors/GenericErrors.sol";
import { LibAsset, IERC20 } from "../Libraries/LibAsset.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { console2 } from "forge-std/console2.sol";

/// @title GasRebateDistributor
/// @author LI.FI (https://li.fi)
/// @notice Contract to distribute gas rebates from a LI.FI marketing campaign
/// @custom:version 1.0.0
contract GasRebateDistributor is TransferrableOwnership {
    /// Storage ///

    /// stores the root of the merkle tree that contains info about which account can claim which amount in which token
    bytes32 public merkleRoot;
    /// (account => latestClaimedMerkleRootVersion) mapping from account to the latest merkle root version that was claimed by this address
    mapping(address => uint8) private _hasClaimed;
    /// stores the current version of the merkle root
    uint8 private _currentMerkleRootVersion;
    /// stores the timestamp until the claims of the current merkle root can be claimed
    uint256 public claimDeadline;
    /// address of the ERC20 token in which gas rebates are paid out
    address public tokenAddress;

    /// Errors ///

    error AlreadyClaimed();
    error InvalidProof();
    error ClaimDeadlineExpired();

    /// Events ///

    event Claimed(
        address indexed account,
        address indexed tokenAddress,
        uint256 amount
    );

    /// Constructor
    constructor(
        address owner_,
        bytes32 merkleRoot_,
        uint256 deadline,
        address tokenAddress_
    ) TransferrableOwnership(owner_) {
        merkleRoot = merkleRoot_;
        claimDeadline = deadline;
        tokenAddress = tokenAddress_;
        _currentMerkleRootVersion = 1;
    }

    /// EXTERNAL FUNCTIONS ///

    /// @notice Allows the caller of this function to claim the specified amount if presented with a valid merkle proof
    /// @param amount the amount that should be claimed
    /// @param merkleProof the merkle proof required to verify the claim (this proof is generated by LI.FI backend)
    function claim(
        uint256 amount,
        bytes32[] calldata merkleProof
    ) public virtual {
        // check if account claimed already for the current merkle root version
        if (_hasClaimed[msg.sender] == _currentMerkleRootVersion)
            revert AlreadyClaimed();

        // check if claim deadline is expired
        if (block.timestamp > claimDeadline) revert ClaimDeadlineExpired();

        console2.log("msg.sender: ", msg.sender);
        console2.log("tokenAddress: ", tokenAddress);
        console2.log("amount: ", amount);
        console2.log("merkleRoot: ");
        console2.logBytes32(merkleRoot);
        console2.log("merkleProof: ");
        console2.logBytes32(merkleProof[0]);

        // Verify the merkle proof
        bytes32 node = keccak256(abi.encodePacked(msg.sender, amount));
        if (!MerkleProof.verify(merkleProof, merkleRoot, node))
            revert InvalidProof();

        // Mark the account as claimed for the current merkle root version
        _hasClaimed[msg.sender] = _currentMerkleRootVersion;

        // send specified and validated amount of tokens to caller
        LibAsset.transferAsset(tokenAddress, payable(msg.sender), amount);

        emit Claimed(msg.sender, tokenAddress, amount);
    }

    /// ADMIN FUNCTIONS ///

    /// @notice Sends all unclaimed token balance(s) to the specified address
    /// @param to the address unclaimed funds should be sent to
    function withdrawUnclaimed(
        address[] calldata tokenAddresses,
        address to
    ) public onlyOwner {
        for (uint i; i < tokenAddresses.length; ) {
            // get current balance
            uint256 balance = IERC20(tokenAddresses[i]).balanceOf(
                address(this)
            );

            // send specified and validated amount of tokens to caller
            SafeERC20.safeTransfer(IERC20(tokenAddresses[i]), to, balance);

            // gas-efficient way to increase loop index
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Updates the merkle root and its version to allow wallets that have previously claimed to claim again, if permitted
    /// @param merkleRoot_ the root of the merkle tree that contains all claimable amounts
    /// @param deadline timestamp until claims for this merkle root are claimable
    /// @param tokenAddress_ address of the gas rebate token
    function updateMerkleRoot(
        bytes32 merkleRoot_,
        uint256 deadline,
        address tokenAddress_
    ) public onlyOwner {
        // update the merkle root
        merkleRoot = merkleRoot_;

        // update tokenAddress
        tokenAddress = tokenAddress_;

        // update the claimable-until deadline
        claimDeadline = deadline;

        // increase the merkle root version
        _currentMerkleRootVersion++;
    }
}
