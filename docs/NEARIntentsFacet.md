# NEARIntentsFacet

## Overview

The NEARIntentsFacet enables bridging tokens through the NEAR Intents Protocol. Unlike traditional bridge protocols, NEAR Intents uses an intent-based settlement system where users specify desired outcomes and solvers compete to fulfill them.

## Architecture

### Key Difference from Other Bridges

NEAR Intents performs **all verification on NEAR mainnet** (`intents.near` contract), not on EVM. This facet:

1. Validates oracle-signed quotes (prevents deposit address spoofing)
2. Transfers tokens to Bridge API-generated deposit addresses
3. Emits events for off-chain tracking

### Oracle Signature

The `bridgeOracle` signs quote parameters to prove:

- The deposit address was genuinely generated by the NEAR Intents Bridge API
- The quote terms (amounts, deadline) are authentic

This prevents malicious actors from substituting fake deposit addresses.

## How It Works

1. **Get Quote**: Frontend calls 1Click API to get a quote with deposit address
2. **Get Oracle Signature**: Backend oracle signs the quote parameters
3. **Execute Bridge**: User calls facet with signed quote data
4. **Settlement**: NEAR Intents protocol settles the intent on NEAR mainnet
5. **Delivery**: Solver delivers tokens to destination

## Public Methods

### startBridgeTokensViaNEARIntents

Bridges tokens directly without swapping.

```solidity
function startBridgeTokensViaNEARIntents(
  ILiFi.BridgeData calldata _bridgeData,
  NEARIntentsData calldata _nearData
) external payable;
```

**Parameters:**

- `_bridgeData`: Core bridge information (receiver, amount, destination chain, etc.)
- `_nearData`: NEAR Intents specific data (see below)

### swapAndStartBridgeTokensViaNEARIntents

Swaps tokens before bridging.

```solidity
function swapAndStartBridgeTokensViaNEARIntents(
  ILiFi.BridgeData memory _bridgeData,
  LibSwap.SwapData[] calldata _swapData,
  NEARIntentsData calldata _nearData
) external payable;
```

**Parameters:**

- `_bridgeData`: Core bridge information
- `_swapData`: Array of swap operations to perform before bridging
- `_nearData`: NEAR Intents specific data

### isQuoteConsumed

Check if a quote has already been used.

```solidity
function isQuoteConsumed(
  bytes32 _quoteId
) external view returns (bool consumed);
```

## NEARIntentsData Parameters

| Parameter       | Type    | Description                                  |
| --------------- | ------- | -------------------------------------------- |
| quoteId         | bytes32 | Unique identifier from 1Click API            |
| depositAddress  | address | EVM address to send tokens (from Bridge API) |
| deadline        | uint256 | Unix timestamp when quote expires            |
| minAmountOut    | uint256 | Minimum output amount (slippage protection)  |
| oracleSignature | bytes   | Oracle's signature verifying quote terms     |

## Events

### NEARIntentsBridgeStarted

Emitted when a bridge transaction starts.

```solidity
event NEARIntentsBridgeStarted(
  bytes32 indexed transactionId,
  bytes32 indexed quoteId,
  address indexed depositAddress,
  address sendingAssetId,
  uint256 amount,
  uint256 deadline
);
```

### LiFiTransferStarted

Standard LiFi event emitted for all bridge transactions.

```solidity
event LiFiTransferStarted(ILiFi.BridgeData bridgeData);
```

## Errors

| Error                      | Description                                      |
| -------------------------- | ------------------------------------------------ |
| `QuoteAlreadyConsumed()`   | The quote ID has already been used               |
| `QuoteExpired()`           | The quote deadline has passed                    |
| `InvalidOracleSignature()` | The oracle signature is invalid or doesn't match |
| `InvalidDepositAddress()`  | The deposit address is zero                      |
| `NativeTransferFailed()`   | Native token transfer to deposit address failed  |
| `InvalidConfig()`          | Constructor called with zero oracle address      |

## Supported Chains

- Ethereum Mainnet
- Arbitrum
- Base
- Polygon
- Optimism
- BNB Chain
- Gnosis
- Aurora
- Avalanche

## Refunds

Refunds are handled automatically by the NEAR Intents protocol:

- If deadline passes without fulfillment, assets are refunded
- Refund destination is specified in the original quote
- Monitor status via 1Click API status endpoint

## Security Considerations

### Quote Replay Protection

Each `quoteId` can only be used once, preventing replay attacks.

### Deadline Validation

Expired quotes are rejected on-chain, ensuring fresh quotes only.

### Oracle Verification

Only quotes signed by the authorized oracle are accepted. The oracle address is immutable and set at deployment.

### Signature Malleability Protection

The facet includes protection against ECDSA signature malleability by validating the `s` value is in the lower half of the curve order.

### Oracle Trust Model

The bridge oracle is a trusted component. If oracle rotation is needed:

1. Deploy a new facet instance with the new oracle address
2. Perform a diamond cut to replace the old facet
3. The oracle address cannot be changed after deployment (immutable)

## Gas Estimates

| Operation                                  | Estimated Gas  |
| ------------------------------------------ | -------------- |
| `startBridgeTokensViaNEARIntents` (ERC20)  | ~70,000-80,000 |
| `startBridgeTokensViaNEARIntents` (Native) | ~50,000-60,000 |
| `swapAndStartBridgeTokensViaNEARIntents`   | Varies by swap |

The facet is gas-efficient because:

- No complex on-chain verification (done on NEAR)
- Minimal storage operations (only quote ID mapping)
- Direct token transfers to deposit address

## Integration Example

```solidity
// 1. Get quote from 1Click API
// 2. Get oracle signature from backend
// 3. Prepare bridge data
ILiFi.BridgeData memory bridgeData = ILiFi.BridgeData({
    transactionId: keccak256(abi.encodePacked(msg.sender, block.timestamp)),
    bridge: "near-intents",
    integrator: "your-integrator-name",
    referrer: address(0),
    sendingAssetId: tokenAddress,
    receiver: destinationAddress,
    minAmount: amount,
    destinationChainId: targetChainId,
    hasSourceSwaps: false,
    hasDestinationCall: false
});

// 4. Prepare NEAR Intents data
NEARIntentsFacet.NEARIntentsData memory nearData = NEARIntentsFacet.NEARIntentsData({
    quoteId: quoteIdFromAPI,
    depositAddress: depositAddressFromAPI,
    deadline: deadlineFromAPI,
    minAmountOut: minAmountOutFromAPI,
    oracleSignature: signatureFromBackend
});

// 5. Approve tokens
IERC20(tokenAddress).approve(facetAddress, amount);

// 6. Execute bridge
NEARIntentsFacet(facetAddress).startBridgeTokensViaNEARIntents(
    bridgeData,
    nearData
);
```

## Oracle Signature Format

The oracle signs the following data:

```solidity
bytes32 messageHash = keccak256(
    abi.encodePacked(
        quoteId,
        depositAddress,
        sendingAssetId,
        minAmount,
        minAmountOut,
        deadline,
        block.chainid
    )
);
```

The signature must be an Ethereum signed message hash:

```solidity
bytes32 ethSignedMessageHash = keccak256(
    abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash)
);
```

## Development Notes

### Testing

Run the test suite:

```bash
forge test --match-contract NEARIntentsFacetTest
```

### Deployment

Deploy using the deployment script:

```bash
forge script script/deploy/facets/DeployNEARIntentsFacet.s.sol:DeployScript --rpc-url $RPC_URL --broadcast
```

Ensure the oracle address is correctly configured in `config/nearintents.json` before deployment.

## Version History

- **1.0.0**: Initial release
