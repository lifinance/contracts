---
name: Diamond facets
description: Facet-only requirements and validations
globs:
  - 'src/Facets/**/*.sol'
---

## Facet Requirements ([CONV:FACET-REQS])

- Location: `src/Facets/`; name contains `Facet`.
- Required functions: `_startBridge` (internal), `swapAndStartBridgeTokensVia{FacetName}`, `startBridgeTokensVia{FacetName}`.
- Modifiers: `nonReentrant`, `refundExcessNative`, `validateBridgeData`, `doesNotContainSourceSwaps`/`doesContainSourceSwaps`, `doesNotContainDestinationCalls`/`doesContainDestinationCalls`.
- Parameter handling:
  - `receiverAddress` first in `{facetName}Data`, must match `bridgeData.receiver` (EVM).
  - Validate `targetChainId` vs `bridgeData.destinationChain` (EVMâ†”EVM).
- Use LibAsset/LibSwap/LibAllowList + Validatable/SwapperV2; reserve native fees via `_depositAndSwap` variants when needed.
- Positive slippage handling: When a bridge has a `minAmountOut` (or similar) parameter (e.g., `outputAmount` in AcrossV4), it must be updated in `swapAndStartBridgeTokensVia{FacetName}` to account for positive slippage from swaps. After `_depositAndSwap` updates `_bridgeData.minAmount`, adjust the bridge's minAmountOut parameter proportionally (accounting for decimal differences if applicable). See `AcrossFacetV4.sol` lines 137-147 for reference implementation.

## Non-EVM Support

- Use `bytes` for non-EVM receivers; must be non-zero.
- For non-EVM flows, `bridgeData.receiver == NON_EVM_ADDRESS`.
- For facets with `{facetName}Data.receiverAddress` field (e.g., `_glacisData.receiverAddress`), validate `{facetName}Data.receiverAddress != bytes32(0)` for non-EVM chains and revert with `InvalidNonEVMReceiver()` if zero.
