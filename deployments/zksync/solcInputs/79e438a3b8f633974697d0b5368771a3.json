{
  "language": "Solidity",
  "sources": {
    "lib/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _castLogPayloadViewToPure(\n        function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IBridge {\n    function send(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    function sendNative(\n        address _receiver,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external payable;\n\n    function relay(\n        bytes calldata _relayRequest,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function transfers(bytes32 transferId) external view returns (bool);\n\n    function withdraws(bytes32 withdrawId) external view returns (bool);\n\n    function withdraw(\n        bytes calldata _wdmsg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msg signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes memory _msg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IOriginalTokenVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IOriginalTokenVault {\n    /**\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external;\n\n    /**\n     * @notice Lock native token as original token to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function depositNative(\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external payable;\n\n    /**\n     * @notice Withdraw locked original tokens triggered by a burn at a remote chain's PeggedTokenBridge.\n     * @param _request The serialized Withdraw protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the bridge's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdraw(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IOriginalTokenVaultV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IOriginalTokenVaultV2 {\n    /**\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    /**\n     * @notice Lock native token as original token to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function depositNative(\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external payable returns (bytes32);\n\n    /**\n     * @notice Withdraw locked original tokens triggered by a burn at a remote chain's PeggedTokenBridge.\n     * @param _request The serialized Withdraw protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the bridge's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdraw(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external returns (bytes32);\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IPeggedTokenBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IPeggedTokenBridge {\n    /**\n     * @notice Burn tokens to trigger withdrawal at a remote chain's OriginalTokenVault\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _withdrawAccount account who withdraw original tokens on the remote chain\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function burn(\n        address _token,\n        uint256 _amount,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) external;\n\n    /**\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\n     * @param _request The serialized Mint protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function mint(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IPeggedTokenBridgeV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IPeggedTokenBridgeV2 {\n    /**\n     * @notice Burn pegged tokens to trigger a cross-chain withdrawal of the original tokens at a remote chain's\n     * OriginalTokenVault, or mint at another remote chain\n     * @param _token The pegged token address.\n     * @param _amount The amount to burn.\n     * @param _toChainId If zero, withdraw from original vault; otherwise, the remote chain to mint tokens.\n     * @param _toAccount The account to receive tokens on the remote chain\n     * @param _nonce A number to guarantee unique depositId. Can be timestamp in practice.\n     */\n    function burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _toAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    // same with `burn` above, use openzeppelin ERC20Burnable interface\n    function burnFrom(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _toAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    /**\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\n     * @param _request The serialized Mint protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function mint(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external returns (bytes32);\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/message/interfaces/IMessageBus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"../libraries/MsgDataTypes.sol\";\n\ninterface IMessageBus {\n    /**\n     * @notice Send a message to a contract on another chain.\n     * Sender needs to make sure the uniqueness of the message Id, which is computed as\n     * hash(type.MessageOnly, sender, receiver, srcChainId, srcTxHash, dstChainId, message).\n     * If messages with the same Id are sent, only one of them will succeed at dst chain..\n     * A fee is charged in the native gas token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessage(\n        address _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable;\n\n    // same as above, except that receiver is an non-evm chain address,\n    function sendMessage(\n        bytes calldata _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable;\n\n    /**\n     * @notice Send a message associated with a token transfer to a contract on another chain.\n     * If messages with the same srcTransferId are sent, only one of them will succeed at dst chain..\n     * A fee is charged in the native token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _srcBridge The bridge contract to send the transfer with.\n     * @param _srcTransferId The transfer ID.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes calldata _message\n    ) external payable;\n\n    /**\n     * @notice Execute a message not associated with a transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.RouteInfo calldata _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Execute a message with a successful transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransfer(\n        bytes calldata _message,\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Execute a message with a refunded transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransferRefund(\n        bytes calldata _message, // the same message associated with the original transfer\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     * @param _cumulativeFee The cumulative fee credited to the account. Tracked by SGN.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A withdrawal must be\n     * signed-off by +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdrawFee(\n        address _account,\n        uint256 _cumulativeFee,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    /**\n     * @notice Calculates the required fee for the message.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     @ @return The required fee.\n     */\n    function calcFee(bytes calldata _message) external view returns (uint256);\n\n    function liquidityBridge() external view returns (address);\n\n    function pegBridge() external view returns (address);\n\n    function pegBridgeV2() external view returns (address);\n\n    function pegVault() external view returns (address);\n\n    function pegVaultV2() external view returns (address);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/message/interfaces/IMessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IMessageReceiverApp {\n    enum ExecutionStatus {\n        Fail, // execution failed, finalized\n        Success, // execution succeeded, finalized\n        Retry // execution rejected, can retry later\n    }\n\n    /**\n     * @notice Called by MessageBus to execute a message\n     * @param _sender The address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        address _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    // same as above, except that sender is an non-evm chain address,\n    // otherwise same as above.\n    function executeMessage(\n        bytes calldata _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Called by MessageBus to execute a message with an associated token transfer.\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransfer(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Only called by MessageBus if\n     *         1. executeMessageWithTransfer reverts, or\n     *         2. executeMessageWithTransfer returns ExecutionStatus.Fail\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferFallback(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Called by MessageBus to process refund of the original transfer from this contract.\n     * The contract is guaranteed to have received the refund before this function is called.\n     * @param _token The token address of the original transfer\n     * @param _amount The amount of the original transfer\n     * @param _message The same message associated with the original transfer\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/message/libraries/MessageSenderLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"../../../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../../../../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../interfaces/IBridge.sol\";\nimport \"../../interfaces/IOriginalTokenVault.sol\";\nimport \"../../interfaces/IOriginalTokenVaultV2.sol\";\nimport \"../../interfaces/IPeggedTokenBridge.sol\";\nimport \"../../interfaces/IPeggedTokenBridgeV2.sol\";\nimport \"../interfaces/IMessageBus.sol\";\nimport \"./MsgDataTypes.sol\";\n\nlibrary MessageSenderLib {\n    using SafeERC20 for IERC20;\n\n    // ============== Internal library functions called by apps ==============\n\n    /**\n     * @notice Sends a message to an app on another chain via MessageBus without an associated transfer.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     * @param _messageBus The address of the MessageBus on this chain.\n     * @param _fee The fee amount to pay to MessageBus.\n     */\n    function sendMessage(\n        address _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        address _messageBus,\n        uint256 _fee\n    ) internal {\n        IMessageBus(_messageBus).sendMessage{value: _fee}(_receiver, _dstChainId, _message);\n    }\n\n    // Send message to non-evm chain with bytes for receiver address,\n    // otherwise same as above.\n    function sendMessage(\n        bytes calldata _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        address _messageBus,\n        uint256 _fee\n    ) internal {\n        IMessageBus(_messageBus).sendMessage{value: _fee}(_receiver, _dstChainId, _message);\n    }\n\n    /**\n     * @notice Sends a message to an app on another chain via MessageBus with an associated transfer.\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     * Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount or the\n     * transfer can be refunded. Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     * @param _bridgeSendType One of the {MsgDataTypes.BridgeSendType} enum.\n     * @param _messageBus The address of the MessageBus on this chain.\n     * @param _fee The fee amount to pay to MessageBus.\n     * @return The transfer ID.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        bytes memory _message,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        address _messageBus,\n        uint256 _fee\n    ) internal returns (bytes32) {\n        (bytes32 transferId, address bridge) = sendTokenTransfer(\n            _receiver,\n            _token,\n            _amount,\n            _dstChainId,\n            _nonce,\n            _maxSlippage,\n            _bridgeSendType,\n            _messageBus\n        );\n        if (_message.length > 0) {\n            IMessageBus(_messageBus).sendMessageWithTransfer{value: _fee}(\n                _receiver,\n                _dstChainId,\n                bridge,\n                transferId,\n                _message\n            );\n        }\n        return transferId;\n    }\n\n    /**\n     * @notice Sends a token transfer via a bridge.\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     * Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount or the\n     * transfer can be refunded.\n     * @param _bridgeSendType One of the {MsgDataTypes.BridgeSendType} enum.\n     */\n    function sendTokenTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        address _messageBus\n    ) internal returns (bytes32 transferId, address bridge) {\n        if (_bridgeSendType == MsgDataTypes.BridgeSendType.Liquidity) {\n            bridge = IMessageBus(_messageBus).liquidityBridge();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IBridge(bridge).send(_receiver, _token, _amount, _dstChainId, _nonce, _maxSlippage);\n            transferId = computeLiqBridgeTransferId(_receiver, _token, _amount, _dstChainId, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegDeposit) {\n            bridge = IMessageBus(_messageBus).pegVault();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IOriginalTokenVault(bridge).deposit(_token, _amount, _dstChainId, _receiver, _nonce);\n            transferId = computePegV1DepositId(_receiver, _token, _amount, _dstChainId, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegBurn) {\n            bridge = IMessageBus(_messageBus).pegBridge();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IPeggedTokenBridge(bridge).burn(_token, _amount, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n            transferId = computePegV1BurnId(_receiver, _token, _amount, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2Deposit) {\n            bridge = IMessageBus(_messageBus).pegVaultV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IOriginalTokenVaultV2(bridge).deposit(_token, _amount, _dstChainId, _receiver, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2Burn) {\n            bridge = IMessageBus(_messageBus).pegBridgeV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IPeggedTokenBridgeV2(bridge).burn(_token, _amount, _dstChainId, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2BurnFrom) {\n            bridge = IMessageBus(_messageBus).pegBridgeV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IPeggedTokenBridgeV2(bridge).burnFrom(_token, _amount, _dstChainId, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n        } else {\n            revert(\"bridge type not supported\");\n        }\n    }\n\n    function computeLiqBridgeTransferId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(address(this), _receiver, _token, _amount, _dstChainId, _nonce, uint64(block.chainid))\n            );\n    }\n\n    function computePegV1DepositId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(address(this), _token, _amount, _dstChainId, _receiver, _nonce, uint64(block.chainid))\n            );\n    }\n\n    function computePegV1BurnId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(address(this), _token, _amount, _receiver, _nonce, uint64(block.chainid)));\n    }\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/message/libraries/MsgDataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary MsgDataTypes {\n    string constant ABORT_PREFIX = \"MSG::ABORT:\";\n\n    // bridge operation type at the sender side (src chain)\n    enum BridgeSendType {\n        Null,\n        Liquidity,\n        PegDeposit,\n        PegBurn,\n        PegV2Deposit,\n        PegV2Burn,\n        PegV2BurnFrom\n    }\n\n    // bridge operation type at the receiver side (dst chain)\n    enum TransferType {\n        Null,\n        LqRelay, // relay through liquidity bridge\n        LqWithdraw, // withdraw from liquidity bridge\n        PegMint, // mint through pegged token bridge\n        PegWithdraw, // withdraw from original token vault\n        PegV2Mint, // mint through pegged token bridge v2\n        PegV2Withdraw // withdraw from original token vault v2\n    }\n\n    enum MsgType {\n        MessageWithTransfer,\n        MessageOnly\n    }\n\n    enum TxStatus {\n        Null,\n        Success,\n        Fail,\n        Fallback,\n        Pending // transient state within a transaction\n    }\n\n    struct TransferInfo {\n        TransferType t;\n        address sender;\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 wdseq; // only needed for LqWithdraw (refund)\n        uint64 srcChainId;\n        bytes32 refId;\n        bytes32 srcTxHash; // src chain msg tx hash\n    }\n\n    struct RouteInfo {\n        address sender;\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash; // src chain msg tx hash\n    }\n\n    // used for msg from non-evm chains with longer-bytes address\n    struct RouteInfo2 {\n        bytes sender;\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash;\n    }\n\n    // combination of RouteInfo and RouteInfo2 for easier processing\n    struct Route {\n        address sender; // from RouteInfo\n        bytes senderBytes; // from RouteInfo2\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash;\n    }\n\n    struct MsgWithTransferExecutionParams {\n        bytes message;\n        TransferInfo transfer;\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n\n    struct BridgeTransferParams {\n        bytes request;\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "src/Errors/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror AlreadyInitialized();\nerror CannotAuthoriseSelf();\nerror CannotBridgeToSameNetwork();\nerror ContractCallNotAllowed();\nerror CumulativeSlippageTooHigh(uint256 minAmount, uint256 receivedAmount);\nerror ExternalCallFailed();\nerror InformationMismatch();\nerror InsufficientBalance(uint256 required, uint256 balance);\nerror InvalidAmount();\nerror InvalidCallData();\nerror InvalidConfig();\nerror InvalidContract();\nerror InvalidDestinationChain();\nerror InvalidFallbackAddress();\nerror InvalidReceiver();\nerror InvalidSendingToken();\nerror NativeAssetNotSupported();\nerror NativeAssetTransferFailed();\nerror NoSwapDataProvided();\nerror NoSwapFromZeroBalance();\nerror NotAContract();\nerror NotInitialized();\nerror NoTransferToNullAddress();\nerror NullAddrIsNotAnERC20Token();\nerror NullAddrIsNotAValidSpender();\nerror OnlyContractOwner();\nerror RecoveryAddressCannotBeZero();\nerror ReentrancyError();\nerror TokenNotSupported();\nerror UnAuthorized();\nerror UnsupportedChainId(uint256 chainId);\nerror WithdrawFailed();\nerror ZeroAmount();\n"
    },
    "src/Facets/AccessManagerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { CannotAuthoriseSelf } from \"../Errors/GenericErrors.sol\";\n\n/// @title Access Manager Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for managing method level access control\n/// @custom:version 1.0.0\ncontract AccessManagerFacet {\n    /// Events ///\n\n    event ExecutionAllowed(address indexed account, bytes4 indexed method);\n    event ExecutionDenied(address indexed account, bytes4 indexed method);\n\n    /// External Methods ///\n\n    /// @notice Sets whether a specific address can call a method\n    /// @param _selector The method selector to set access for\n    /// @param _executor The address to set method access for\n    /// @param _canExecute Whether or not the address can execute the specified method\n    function setCanExecute(\n        bytes4 _selector,\n        address _executor,\n        bool _canExecute\n    ) external {\n        if (_executor == address(this)) {\n            revert CannotAuthoriseSelf();\n        }\n        LibDiamond.enforceIsContractOwner();\n        _canExecute\n            ? LibAccess.addAccess(_selector, _executor)\n            : LibAccess.removeAccess(_selector, _executor);\n        if (_canExecute) {\n            emit ExecutionAllowed(_executor, _selector);\n        } else {\n            emit ExecutionDenied(_executor, _selector);\n        }\n    }\n\n    /// @notice Check if a method can be executed by a specific address\n    /// @param _selector The method selector to check\n    /// @param _executor The address to check\n    function addressCanExecuteMethod(\n        bytes4 _selector,\n        address _executor\n    ) external view returns (bool) {\n        return LibAccess.accessStorage().execAccess[_selector][_executor];\n    }\n}\n"
    },
    "src/Facets/AcrossFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAcrossSpokePool } from \"../Interfaces/IAcrossSpokePool.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Across Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Across Protocol\n/// @custom:version 2.0.0\ncontract AcrossFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the spoke pool on the source chain.\n    IAcrossSpokePool private immutable spokePool;\n\n    /// @notice The WETH address on the current chain.\n    address private immutable wrappedNative;\n\n    /// Types ///\n\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals.\n    /// @param quoteTimestamp The timestamp associated with the suggested fee.\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid.\n    struct AcrossData {\n        int64 relayerFeePct;\n        uint32 quoteTimestamp;\n        bytes message;\n        uint256 maxCount;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _spokePool The contract address of the spoke pool on the source chain.\n    /// @param _wrappedNative The address of the wrapped native token on the source chain.\n    constructor(IAcrossSpokePool _spokePool, address _wrappedNative) {\n        spokePool = _spokePool;\n        wrappedNative = _wrappedNative;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _acrossData data specific to Across\n    function startBridgeTokensViaAcross(\n        ILiFi.BridgeData memory _bridgeData,\n        AcrossData calldata _acrossData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _acrossData);\n    }\n\n    /// @notice Performs a swap before bridging via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _acrossData data specific to Across\n    function swapAndStartBridgeTokensViaAcross(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AcrossData calldata _acrossData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _acrossData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _acrossData data specific to Across\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AcrossData calldata _acrossData\n    ) internal {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            spokePool.deposit{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                wrappedNative,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _acrossData.relayerFeePct,\n                _acrossData.quoteTimestamp,\n                _acrossData.message,\n                _acrossData.maxCount\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(spokePool),\n                _bridgeData.minAmount\n            );\n            spokePool.deposit(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _acrossData.relayerFeePct,\n                _acrossData.quoteTimestamp,\n                _acrossData.message,\n                _acrossData.maxCount\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/AcrossFacetPacked.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IAcrossSpokePool } from \"../Interfaces/IAcrossSpokePool.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { AcrossFacet } from \"./AcrossFacet.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { SafeERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { console2 } from \"../../lib/forge-std/src/console2.sol\";\n\n/// @title AcrossFacetPacked\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Across in a gas-optimized way\n/// @custom:version 1.0.0\ncontract AcrossFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    bytes public constant ACROSS_REFERRER_DELIMITER = hex\"d00dfeeddeadbeef\";\n    uint8 private constant ACROSS_REFERRER_ADDRESS_LENGTH = 20;\n    uint256 private constant REFERRER_OFFSET = 28;\n\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    IAcrossSpokePool private immutable spokePool;\n\n    /// @notice The WETH address on the current chain.\n    address private immutable wrappedNative;\n\n    /// Events ///\n\n    event LiFiAcrossTransfer(bytes8 _transactionId);\n    event CallExecutedAndFundsWithdrawn();\n\n    /// Errors ///\n\n    error WithdrawFailed();\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract\n    /// @param _spokePool The contract address of the spoke pool on the source chain\n    /// @param _wrappedNative The address of the wrapped native token on the source chain\n    /// @param _owner The address of the contract owner\n    constructor(\n        IAcrossSpokePool _spokePool,\n        address _wrappedNative,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        spokePool = _spokePool;\n        wrappedNative = _wrappedNative;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Across spoke pool Router to spend the specified token\n    /// @param tokensToApprove The tokens to approve to the Across spoke pool\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        for (uint256 i; i < tokensToApprove.length; i++) {\n            // Give Across spoke pool approval to pull tokens from this facet\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(spokePool),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges native tokens via Across (packed implementation)\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaAcrossNativePacked() external payable {\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = msg.data.length - REFERRER_OFFSET;\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit{ value: msg.value }(\n            address(bytes20(msg.data[12:32])), // receiver\n            wrappedNative, // wrappedNative address\n            msg.value, // minAmount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            int64(uint64(bytes8(msg.data[36:44]))), // int64 relayerFeePct\n            uint32(bytes4(msg.data[44:48])), // uint32 quoteTimestamp\n            msg.data[80:calldataEndsAt], // bytes message (due to variable length positioned at the end of the calldata)\n            uint256(bytes32(msg.data[48:80])) // uint256 maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges native tokens via Across (minimal implementation)\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function startBridgeTokensViaAcrossNativeMin(\n        bytes32 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes calldata message,\n        uint256 maxCount\n    ) external payable {\n        // call Across spoke pool to bridge assets\n        spokePool.deposit{ value: msg.value }(\n            receiver,\n            wrappedNative,\n            msg.value,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message,\n            maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via Across (packed implementation)\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaAcrossERC20Packed() external payable {\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = msg.data.length - REFERRER_OFFSET;\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit(\n            address(bytes20(msg.data[12:32])), // receiver\n            address(bytes20(msg.data[32:52])), // sendingAssetID\n            minAmount,\n            uint64(uint32(bytes4(msg.data[68:72]))), // destinationChainId\n            int64(uint64(bytes8(msg.data[72:80]))), // int64 relayerFeePct\n            uint32(bytes4(msg.data[80:84])), // uint32 quoteTimestamp\n            msg.data[116:calldataEndsAt], // bytes message (due to variable length positioned at the end of the calldata)\n            uint256(bytes32(msg.data[84:116])) // uint256 maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Across (minimal implementation)\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param sendingAssetId The address of the asset/token to be bridged\n    /// @param minAmount The amount to be bridged\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function startBridgeTokensViaAcrossERC20Min(\n        bytes32 transactionId,\n        address sendingAssetId,\n        uint256 minAmount,\n        address receiver,\n        uint64 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes calldata message,\n        uint256 maxCount\n    ) external payable {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit(\n            receiver,\n            sendingAssetId,\n            minAmount,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message,\n            maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Encodes calldata that can be used to call the native 'packed' function\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function encode_startBridgeTokensViaAcrossNativePacked(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        uint256 maxCount,\n        bytes calldata message\n    ) external pure returns (bytes memory) {\n        // there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPacked\n                    .startBridgeTokensViaAcrossNativePacked\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes8(uint64(relayerFeePct)),\n                bytes4(quoteTimestamp),\n                bytes32(maxCount),\n                message\n            );\n    }\n\n    /// @notice Encodes calldata that can be used to call the ERC20 'packed' function\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId The address of the asset/token to be bridged\n    /// @param minAmount The amount to be bridged\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function encode_startBridgeTokensViaAcrossERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes calldata message,\n        uint256 maxCount\n    ) external pure returns (bytes memory) {\n        // there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPacked\n                    .startBridgeTokensViaAcrossERC20Packed\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(uint32(destinationChainId)),\n                bytes8(uint64(relayerFeePct)),\n                bytes4(uint32(quoteTimestamp)),\n                bytes32(maxCount),\n                message\n            );\n    }\n\n    /// @notice Decodes calldata that is meant to be used for calling the native 'packed' function\n    /// @param data the calldata to be decoded\n    function decode_startBridgeTokensViaAcrossNativePacked(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            BridgeData memory bridgeData,\n            AcrossFacet.AcrossData memory acrossData\n        )\n    {\n        require(\n            data.length >= 108,\n            \"invalid calldata (must have length > 108)\"\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = data.length - REFERRER_OFFSET;\n\n        // extract bridgeData\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[32:36])));\n\n        // extract acrossData\n        acrossData.relayerFeePct = int64(uint64(bytes8(data[36:44])));\n        acrossData.quoteTimestamp = uint32(bytes4(data[44:48]));\n        acrossData.maxCount = uint256(bytes32(data[48:80]));\n        acrossData.message = data[80:calldataEndsAt];\n\n        return (bridgeData, acrossData);\n    }\n\n    /// @notice Decodes calldata that is meant to be used for calling the ERC20 'packed' function\n    /// @param data the calldata to be decoded\n    function decode_startBridgeTokensViaAcrossERC20Packed(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            BridgeData memory bridgeData,\n            AcrossFacet.AcrossData memory acrossData\n        )\n    {\n        require(\n            data.length >= 144,\n            \"invalid calldata (must have length > 144)\"\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = data.length - REFERRER_OFFSET;\n\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.sendingAssetId = address(bytes20(data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(data[52:68])));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[68:72])));\n\n        // extract acrossData\n        acrossData.relayerFeePct = int64(uint64(bytes8(data[72:80])));\n        acrossData.quoteTimestamp = uint32(bytes4(data[80:84]));\n        acrossData.maxCount = uint256(bytes32(data[84:116]));\n        acrossData.message = data[116:calldataEndsAt];\n\n        return (bridgeData, acrossData);\n    }\n\n    /// @notice Execute calldata and withdraw asset\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to address to withdraw to\n    /// @param _amount amount of asset to withdraw\n    function executeCallAndWithdraw(\n        address _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        // execute calldata\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _callTo.call(_callData);\n\n        // check success of call\n        if (success) {\n            // call successful - withdraw the asset\n            LibAsset.transferAsset(_assetAddress, payable(_to), _amount);\n            emit CallExecutedAndFundsWithdrawn();\n        } else {\n            // call unsuccessful - revert\n            revert WithdrawFailed();\n        }\n    }\n}\n"
    },
    "src/Facets/AllBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAllBridge } from \"../Interfaces/IAllBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\n/// @title Allbridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through AllBridge\n/// @custom:version 2.0.0\ncontract AllBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// @notice The contract address of the AllBridge router on the source chain.\n    IAllBridge private immutable allBridge;\n\n    /// @notice The struct for the AllBridge data.\n    /// @param fees The amount of token to pay the messenger and the bridge\n    /// @param recipient The address of the token receiver after bridging.\n    /// @param destinationChainId The destination chain id.\n    /// @param receiveToken The token to receive on the destination chain.\n    /// @param nonce A random nonce to associate with the tx.\n    /// @param messenger The messenger protocol enum\n    /// @param payFeeWithSendingAsset Whether to pay the relayer fee with the sending asset or not\n    struct AllBridgeData {\n        uint256 fees;\n        bytes32 recipient;\n        uint256 destinationChainId;\n        bytes32 receiveToken;\n        uint256 nonce;\n        IAllBridge.MessengerProtocol messenger;\n        bool payFeeWithSendingAsset;\n    }\n\n    /// @notice Initializes the AllBridge contract\n    /// @param _allBridge The address of the AllBridge contract\n    constructor(IAllBridge _allBridge) {\n        allBridge = _allBridge;\n    }\n\n    /// @notice Bridge tokens to another chain via AllBridge\n    /// @param _bridgeData The bridge data struct\n    function startBridgeTokensViaAllBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AllBridgeData calldata _allBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _allBridgeData);\n    }\n\n    /// @notice Bridge tokens to another chain via AllBridge\n    /// @param _bridgeData The bridge data struct\n    /// @param _swapData The swap data struct\n    /// @param _allBridgeData The AllBridge data struct\n    function swapAndStartBridgeTokensViaAllBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AllBridgeData calldata _allBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _allBridgeData);\n    }\n\n    /// @notice Bridge tokens to another chain via AllBridge\n    /// @param _bridgeData The bridge data struct\n    /// @param _allBridgeData The allBridge data struct for AllBridge specicific data\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AllBridgeData calldata _allBridgeData\n    ) internal {\n        LibAsset.maxApproveERC20(\n            IERC20(_bridgeData.sendingAssetId),\n            address(allBridge),\n            _bridgeData.minAmount\n        );\n\n        if (_allBridgeData.payFeeWithSendingAsset) {\n            allBridge.swapAndBridge(\n                bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                _bridgeData.minAmount,\n                _allBridgeData.recipient,\n                _allBridgeData.destinationChainId,\n                _allBridgeData.receiveToken,\n                _allBridgeData.nonce,\n                _allBridgeData.messenger,\n                _allBridgeData.fees\n            );\n        } else {\n            allBridge.swapAndBridge{ value: _allBridgeData.fees }(\n                bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                _bridgeData.minAmount,\n                _allBridgeData.recipient,\n                _allBridgeData.destinationChainId,\n                _allBridgeData.receiveToken,\n                _allBridgeData.nonce,\n                _allBridgeData.messenger,\n                0\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/AmarokFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IConnextHandler } from \"../Interfaces/IConnextHandler.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Amarok Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Connext Amarok\n/// @custom:version 2.0.0\ncontract AmarokFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the connext handler on the source chain.\n    IConnextHandler private immutable connextHandler;\n\n    /// @param callData The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\n    /// @param callTo The address of the contract on dest chain that will receive bridged funds and execute data\n    /// @param relayerFee The amount of relayer fee the tx called xcall with\n    /// @param slippageTol Maximum acceptable slippage in BPS. For example, a value of 30 means 0.3% slippage\n    /// @param delegate Destination delegate address\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param payFeeWithSendingAsset Whether to pay the relayer fee with the sending asset or not\n    struct AmarokData {\n        bytes callData;\n        address callTo;\n        uint256 relayerFee;\n        uint256 slippageTol;\n        address delegate;\n        uint32 destChainDomainId;\n        bool payFeeWithSendingAsset;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _connextHandler The contract address of the connext handler on the source chain.\n    constructor(IConnextHandler _connextHandler) {\n        connextHandler = _connextHandler;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Amarok\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _amarokData Data specific to bridge\n    function startBridgeTokensViaAmarok(\n        BridgeData calldata _bridgeData,\n        AmarokData calldata _amarokData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n        noNativeAsset(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _amarokData);\n\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _amarokData);\n    }\n\n    /// @notice Performs a swap before bridging via Amarok\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _amarokData Data specific to Amarok\n    function swapAndStartBridgeTokensViaAmarok(\n        BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AmarokData calldata _amarokData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n        noNativeAsset(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _amarokData);\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _amarokData.relayerFee\n        );\n\n        _startBridge(_bridgeData, _amarokData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Amarok\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _amarokData Data specific to Amarok\n    function _startBridge(\n        BridgeData memory _bridgeData,\n        AmarokData calldata _amarokData\n    ) private {\n        // give max approval for token to Amarok bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(_bridgeData.sendingAssetId),\n            address(connextHandler),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        if (_amarokData.payFeeWithSendingAsset) {\n            connextHandler.xcall(\n                _amarokData.destChainDomainId,\n                _amarokData.callTo,\n                _bridgeData.sendingAssetId,\n                _amarokData.delegate,\n                _bridgeData.minAmount - _amarokData.relayerFee,\n                _amarokData.slippageTol,\n                _amarokData.callData,\n                _amarokData.relayerFee\n            );\n        } else {\n            connextHandler.xcall{ value: _amarokData.relayerFee }(\n                _amarokData.destChainDomainId,\n                _amarokData.callTo,\n                _bridgeData.sendingAssetId,\n                _amarokData.delegate,\n                _bridgeData.minAmount,\n                _amarokData.slippageTol,\n                _amarokData.callData\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        AmarokData calldata _amarokData\n    ) private pure {\n        if (\n            (_amarokData.callData.length > 0) != _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n}\n"
    },
    "src/Facets/AmarokFacetPacked.sol": {
      "content": "// // SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IConnextHandler } from \"../Interfaces/IConnextHandler.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { AmarokFacet } from \"../../src/Facets/AmarokFacet.sol\";\nimport { console2 } from \"../../lib/forge-std/src/console2.sol\";\n\n/// @title AmarokFacetPacked\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Amarok in a gas-optimized way\n/// @custom:version 1.0.0\ncontract AmarokFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage\n\n    /// @notice The contract address of the connext handler on the source chain.\n    IConnextHandler private immutable connextHandler;\n\n    /// Events ///\n\n    event LiFiAmarokTransfer(bytes8 _transactionId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _connextHandler The contract address of the connext handler on the source chain.\n    /// @param _owner The contract owner to approve tokens.\n    constructor(\n        IConnextHandler _connextHandler,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        connextHandler = _connextHandler;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Amarok bridge to spend the specified token\n    /// @param tokensToApprove The tokens to approve to approve to the Amarok bridge\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        uint256 numTokens = tokensToApprove.length;\n\n        for (uint256 i; i < numTokens; i++) {\n            // Give Amarok approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(connextHandler),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges ERC20 tokens via Amarok\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset() external {\n        // extract parameters that are used multiple times in this function\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n        address receiver = address(bytes20(msg.data[12:32]));\n        uint256 relayerFee = uint64(uint32(bytes4(msg.data[76:92])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Amarok bridge\n        connextHandler.xcall(\n            uint32(bytes4(msg.data[68:72])), // _destChainDomainId\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount - relayerFee,\n            uint256(uint128(uint64(uint32(bytes4(msg.data[72:76]))))), // slippageTol\n            \"\", // calldata (not required)\n            relayerFee\n        );\n\n        emit LiFiAmarokTransfer(bytes8(msg.data[4:12]));\n    }\n\n    function startBridgeTokensViaAmarokERC20PackedPayFeeWithNative()\n        external\n        payable\n    {\n        // extract parameters that are used multiple times in this function\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n        address receiver = address(bytes20(msg.data[12:32]));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Amarok bridge\n        connextHandler.xcall{ value: msg.value }(\n            uint32(bytes4(msg.data[68:72])), // destChainDomainId\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount,\n            uint256(uint128(uint64(uint32(bytes4(msg.data[72:76]))))), // slippageTol\n            \"\" // calldata (not required)\n        );\n\n        emit LiFiAmarokTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Maximum acceptable slippage in BPS. For example, a value of 30 means 0.3% slippage\n    /// @param relayerFee The amount of relayer fee the tx called xcall with\n    function startBridgeTokensViaAmarokERC20MinPayFeeWithAsset(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol,\n        uint256 relayerFee\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        connextHandler.xcall(\n            destChainDomainId,\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount - relayerFee,\n            slippageTol,\n            \"\", // calldata (not required)\n            relayerFee\n        );\n\n        emit LiFiAmarokTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Maximum acceptable slippage in BPS. For example, a value of 30 means 0.3% slippage\n    function startBridgeTokensViaAmarokERC20MinPayFeeWithNative(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol\n    ) external payable {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        connextHandler.xcall{ value: msg.value }(\n            destChainDomainId,\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount,\n            slippageTol,\n            \"\" // calldata (not required)\n        );\n\n        emit LiFiAmarokTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Encode call data to bridge ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n    /// @param relayerFee The amount of relayer fee the tx called xcall with\n    function encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol,\n        uint256 relayerFee\n    ) external pure returns (bytes memory) {\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n        require(\n            slippageTol <= type(uint32).max,\n            \"slippageTol value passed too big to fit in uint32\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                AmarokFacetPacked\n                    .startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset\n                    .selector,\n                bytes8(transactionId), // we only use 8 bytes of the 32bytes txId in order to save gas\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(destChainDomainId),\n                bytes4(uint32(slippageTol)),\n                bytes16(uint128(relayerFee))\n            );\n    }\n\n    /// @notice Encode call data to bridge ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n    function encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol\n    ) external pure returns (bytes memory) {\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n        require(\n            slippageTol <= type(uint32).max,\n            \"slippageTol value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AmarokFacetPacked\n                    .startBridgeTokensViaAmarokERC20PackedPayFeeWithNative\n                    .selector,\n                bytes8(transactionId), // we only use 8 bytes of the 32bytes txId in order to save gas\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(destChainDomainId),\n                bytes4(uint32(slippageTol))\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, AmarokFacet.AmarokData memory)\n    {\n        require(\n            _data.length >= 92,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        AmarokFacet.AmarokData memory amarokData;\n\n        uint32 destChainDomainId = uint32(bytes4(_data[68:72]));\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = getChainIdForDomain(destChainDomainId);\n        bridgeData.sendingAssetId = address(bytes20(_data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[52:68])));\n\n        amarokData.callData = \"\";\n        amarokData.callTo = bridgeData.receiver;\n        amarokData.destChainDomainId = destChainDomainId;\n        amarokData.slippageTol = uint32(bytes4(_data[72:76]));\n        amarokData.relayerFee = uint256(uint128(bytes16(_data[76:92])));\n        amarokData.delegate = bridgeData.receiver;\n        amarokData.payFeeWithSendingAsset = true;\n\n        return (bridgeData, amarokData);\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaAmarokERC20PackedPayFeeWithNative\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, AmarokFacet.AmarokData memory)\n    {\n        require(\n            _data.length >= 76,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        AmarokFacet.AmarokData memory amarokData;\n\n        uint32 destChainDomainId = uint32(bytes4(_data[68:72]));\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = getChainIdForDomain(destChainDomainId);\n        bridgeData.sendingAssetId = address(bytes20(_data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[52:68])));\n\n        amarokData.callData = \"\";\n        amarokData.callTo = bridgeData.receiver;\n        amarokData.destChainDomainId = destChainDomainId;\n        amarokData.slippageTol = uint256(\n            uint128(uint32(bytes4(_data[72:76])))\n        );\n        amarokData.delegate = bridgeData.receiver;\n        amarokData.payFeeWithSendingAsset = false;\n\n        return (bridgeData, amarokData);\n    }\n\n    function getChainIdForDomain(\n        uint32 domainId\n    ) public pure returns (uint32 chainId) {\n        if (domainId == 6648936) return 1;\n        // ETH\n        else if (domainId == 1886350457) return 137;\n        // POL\n        else if (domainId == 6450786) return 56;\n        // BSC\n        else if (domainId == 1869640809) return 10;\n        // OPT\n        else if (domainId == 6778479) return 100;\n        // GNO/DAI\n        else if (domainId == 1634886255) return 42161;\n        // ARB\n        else if (domainId == 1818848877) return 59144; // LIN\n    }\n}\n"
    },
    "src/Facets/ArbitrumBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IGatewayRouter } from \"../Interfaces/IGatewayRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidAmount } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Arbitrum Bridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Arbitrum Bridge\n/// @custom:version 1.0.0\ncontract ArbitrumBridgeFacet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @notice The contract address of the gateway router on the source chain.\n    IGatewayRouter private immutable gatewayRouter;\n\n    /// @notice The contract address of the inbox on the source chain.\n    IGatewayRouter private immutable inbox;\n\n    /// Types ///\n\n    /// @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee.\n    /// @param maxGas Max gas deducted from user's L2 balance to cover L2 execution.\n    /// @param maxGasPrice price bid for L2 execution.\n    struct ArbitrumData {\n        uint256 maxSubmissionCost;\n        uint256 maxGas;\n        uint256 maxGasPrice;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _gatewayRouter The contract address of the gateway router on the source chain.\n    /// @param _inbox The contract address of the inbox on the source chain.\n    constructor(IGatewayRouter _gatewayRouter, IGatewayRouter _inbox) {\n        gatewayRouter = _gatewayRouter;\n        inbox = _inbox;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Arbitrum Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _arbitrumData Data for gateway router address, asset id and amount\n    function startBridgeTokensViaArbitrumBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        ArbitrumData calldata _arbitrumData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        uint256 cost = _arbitrumData.maxSubmissionCost +\n            _arbitrumData.maxGas *\n            _arbitrumData.maxGasPrice;\n\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _arbitrumData, cost);\n    }\n\n    /// @notice Performs a swap before bridging via Arbitrum Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _arbitrumData Data for gateway router address, asset id and amount\n    function swapAndStartBridgeTokensViaArbitrumBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        ArbitrumData calldata _arbitrumData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        uint256 cost = _arbitrumData.maxSubmissionCost +\n            _arbitrumData.maxGas *\n            _arbitrumData.maxGasPrice;\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            cost\n        );\n\n        _startBridge(_bridgeData, _arbitrumData, cost);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Arbitrum Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _arbitrumData Data for gateway router address, asset id and amount\n    /// @param _cost Additional amount of native asset for the fee\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        ArbitrumData calldata _arbitrumData,\n        uint256 _cost\n    ) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            inbox.unsafeCreateRetryableTicket{\n                value: _bridgeData.minAmount + _cost\n            }(\n                _bridgeData.receiver,\n                _bridgeData.minAmount, // l2CallValue\n                _arbitrumData.maxSubmissionCost,\n                _bridgeData.receiver, // excessFeeRefundAddress\n                _bridgeData.receiver, // callValueRefundAddress\n                _arbitrumData.maxGas,\n                _arbitrumData.maxGasPrice,\n                \"\"\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                gatewayRouter.getGateway(_bridgeData.sendingAssetId),\n                _bridgeData.minAmount\n            );\n            gatewayRouter.outboundTransfer{ value: _cost }(\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _arbitrumData.maxGas,\n                _arbitrumData.maxGasPrice,\n                abi.encode(_arbitrumData.maxSubmissionCost, \"\")\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/CalldataVerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { AmarokFacet } from \"./AmarokFacet.sol\";\nimport { StargateFacet } from \"./StargateFacet.sol\";\nimport { CelerIMFacetBase, CelerIM } from \"../../src/Helpers/CelerIMFacetBase.sol\";\nimport { StandardizedCallFacet } from \"../../src/Facets/StandardizedCallFacet.sol\";\nimport { LibBytes } from \"../Libraries/LibBytes.sol\";\n\n/// @title Calldata Verification Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for verifying calldata\n/// @custom:version 1.1.1\ncontract CalldataVerificationFacet {\n    using LibBytes for bytes;\n\n    /// @notice Extracts the bridge data from the calldata\n    /// @param data The calldata to extract the bridge data from\n    /// @return bridgeData The bridge data extracted from the calldata\n    function extractBridgeData(\n        bytes calldata data\n    ) external pure returns (ILiFi.BridgeData memory bridgeData) {\n        bridgeData = _extractBridgeData(data);\n    }\n\n    /// @notice Extracts the swap data from the calldata\n    /// @param data The calldata to extract the swap data from\n    /// @return swapData The swap data extracted from the calldata\n    function extractSwapData(\n        bytes calldata data\n    ) external pure returns (LibSwap.SwapData[] memory swapData) {\n        swapData = _extractSwapData(data);\n    }\n\n    /// @notice Extracts the bridge data and swap data from the calldata\n    /// @param data The calldata to extract the bridge data and swap data from\n    /// @return bridgeData The bridge data extracted from the calldata\n    /// @return swapData The swap data extracted from the calldata\n    function extractData(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            ILiFi.BridgeData memory bridgeData,\n            LibSwap.SwapData[] memory swapData\n        )\n    {\n        bridgeData = _extractBridgeData(data);\n        if (bridgeData.hasSourceSwaps) {\n            swapData = _extractSwapData(data);\n        }\n    }\n\n    /// @notice Extracts the main parameters from the calldata\n    /// @param data The calldata to extract the main parameters from\n    /// @return bridge The bridge extracted from the calldata\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return amount The min amountfrom the calldata\n    /// @return destinationChainId The destination chain id extracted from the calldata\n    /// @return hasSourceSwaps Whether the calldata has source swaps\n    /// @return hasDestinationCall Whether the calldata has a destination call\n    function extractMainParameters(\n        bytes calldata data\n    )\n        public\n        pure\n        returns (\n            string memory bridge,\n            address sendingAssetId,\n            address receiver,\n            uint256 amount,\n            uint256 destinationChainId,\n            bool hasSourceSwaps,\n            bool hasDestinationCall\n        )\n    {\n        ILiFi.BridgeData memory bridgeData = _extractBridgeData(data);\n\n        if (bridgeData.hasSourceSwaps) {\n            LibSwap.SwapData[] memory swapData = _extractSwapData(data);\n            sendingAssetId = swapData[0].sendingAssetId;\n            amount = swapData[0].fromAmount;\n        } else {\n            sendingAssetId = bridgeData.sendingAssetId;\n            amount = bridgeData.minAmount;\n        }\n\n        return (\n            bridgeData.bridge,\n            sendingAssetId,\n            bridgeData.receiver,\n            amount,\n            bridgeData.destinationChainId,\n            bridgeData.hasSourceSwaps,\n            bridgeData.hasDestinationCall\n        );\n    }\n\n    /// @notice Extracts the generic swap parameters from the calldata\n    /// @param data The calldata to extract the generic swap parameters from\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return amount The amount extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return receivingAssetId The receiving asset id extracted from the calldata\n    /// @return receivingAmount The receiving amount extracted from the calldata\n    function extractGenericSwapParameters(\n        bytes calldata data\n    )\n        public\n        pure\n        returns (\n            address sendingAssetId,\n            uint256 amount,\n            address receiver,\n            address receivingAssetId,\n            uint256 receivingAmount\n        )\n    {\n        LibSwap.SwapData[] memory swapData;\n        bytes memory callData = data;\n\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // standardizedCall\n            callData = abi.decode(data[4:], (bytes));\n        }\n        (, , , receiver, receivingAmount, swapData) = abi.decode(\n            callData.slice(4, callData.length - 4),\n            (bytes32, string, string, address, uint256, LibSwap.SwapData[])\n        );\n\n        sendingAssetId = swapData[0].sendingAssetId;\n        amount = swapData[0].fromAmount;\n        receivingAssetId = swapData[swapData.length - 1].receivingAssetId;\n        return (\n            sendingAssetId,\n            amount,\n            receiver,\n            receivingAssetId,\n            receivingAmount\n        );\n    }\n\n    /// @notice Validates the calldata\n    /// @param data The calldata to validate\n    /// @param bridge The bridge to validate or empty string to ignore\n    /// @param sendingAssetId The sending asset id to validate\n    ///        or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF to ignore\n    /// @param receiver The receiver to validate\n    ///        or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF to ignore\n    /// @param amount The amount to validate or type(uint256).max to ignore\n    /// @param destinationChainId The destination chain id to validate\n    ///        or type(uint256).max to ignore\n    /// @param hasSourceSwaps Whether the calldata has source swaps\n    /// @param hasDestinationCall Whether the calldata has a destination call\n    /// @return isValid Whether the calldata is validate\n    function validateCalldata(\n        bytes calldata data,\n        string calldata bridge,\n        address sendingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 destinationChainId,\n        bool hasSourceSwaps,\n        bool hasDestinationCall\n    ) external pure returns (bool isValid) {\n        ILiFi.BridgeData memory bridgeData;\n        (\n            bridgeData.bridge,\n            bridgeData.sendingAssetId,\n            bridgeData.receiver,\n            bridgeData.minAmount,\n            bridgeData.destinationChainId,\n            bridgeData.hasSourceSwaps,\n            bridgeData.hasDestinationCall\n        ) = extractMainParameters(data);\n        return\n            // Check bridge\n            (keccak256(abi.encodePacked(bridge)) ==\n                keccak256(abi.encodePacked(\"\")) ||\n                keccak256(abi.encodePacked(bridgeData.bridge)) ==\n                keccak256(abi.encodePacked(bridge))) &&\n            // Check sendingAssetId\n            (sendingAssetId == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.sendingAssetId == sendingAssetId) &&\n            // Check receiver\n            (receiver == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.receiver == receiver) &&\n            // Check amount\n            (amount == type(uint256).max || bridgeData.minAmount == amount) &&\n            // Check destinationChainId\n            (destinationChainId == type(uint256).max ||\n                bridgeData.destinationChainId == destinationChainId) &&\n            // Check hasSourceSwaps\n            bridgeData.hasSourceSwaps == hasSourceSwaps &&\n            // Check hasDestinationCall\n            bridgeData.hasDestinationCall == hasDestinationCall;\n    }\n\n    /// @notice Validates the destination calldata\n    /// @param data The calldata to validate\n    /// @param callTo The call to address to validate\n    /// @param dstCalldata The destination calldata to validate\n    /// @return isValid Whether the destination calldata is validate\n    function validateDestinationCalldata(\n        bytes calldata data,\n        bytes calldata callTo,\n        bytes calldata dstCalldata\n    ) external pure returns (bool isValid) {\n        bytes memory callData = data;\n\n        // Handle standardizedCall\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            callData = abi.decode(data[4:], (bytes));\n        }\n\n        bytes4 selector = abi.decode(callData, (bytes4));\n\n        // Case: Amarok\n        if (selector == AmarokFacet.startBridgeTokensViaAmarok.selector) {\n            (, AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AmarokFacet.AmarokData)\n            );\n\n            return\n                keccak256(dstCalldata) == keccak256(amarokData.callData) &&\n                abi.decode(callTo, (address)) == amarokData.callTo;\n        }\n        if (\n            selector == AmarokFacet.swapAndStartBridgeTokensViaAmarok.selector\n        ) {\n            (, , AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], AmarokFacet.AmarokData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(amarokData.callData) &&\n                abi.decode(callTo, (address)) == amarokData.callTo;\n        }\n\n        // Case: Stargate\n        if (selector == StargateFacet.startBridgeTokensViaStargate.selector) {\n            (, StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, StargateFacet.StargateData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(stargateData.callData) &&\n                keccak256(callTo) == keccak256(stargateData.callTo);\n        }\n        if (\n            selector ==\n            StargateFacet.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    StargateFacet.StargateData\n                )\n            );\n            return\n                keccak256(dstCalldata) == keccak256(stargateData.callData) &&\n                keccak256(callTo) == keccak256(stargateData.callTo);\n        }\n        // Case: Celer\n        if (\n            selector == CelerIMFacetBase.startBridgeTokensViaCelerIM.selector\n        ) {\n            (, CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, CelerIM.CelerIMData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(celerIMData.callData) &&\n                keccak256(callTo) == keccak256(celerIMData.callTo);\n        }\n        if (\n            selector ==\n            CelerIMFacetBase.swapAndStartBridgeTokensViaCelerIM.selector\n        ) {\n            (, , CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], CelerIM.CelerIMData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(celerIMData.callData) &&\n                keccak256(callTo) == keccak256(celerIMData.callTo);\n        }\n\n        // All other cases\n        return false;\n    }\n\n    /// Internal Methods ///\n\n    /// @notice Extracts the bridge data from the calldata\n    /// @param data The calldata to extract the bridge data from\n    /// @return bridgeData The bridge data extracted from the calldata\n    function _extractBridgeData(\n        bytes calldata data\n    ) internal pure returns (ILiFi.BridgeData memory bridgeData) {\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // StandardizedCall\n            bytes memory unwrappedData = abi.decode(data[4:], (bytes));\n            bridgeData = abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            );\n            return bridgeData;\n        }\n        // normal call\n        bridgeData = abi.decode(data[4:], (ILiFi.BridgeData));\n    }\n\n    /// @notice Extracts the swap data from the calldata\n    /// @param data The calldata to extract the swap data from\n    /// @return swapData The swap data extracted from the calldata\n    function _extractSwapData(\n        bytes calldata data\n    ) internal pure returns (LibSwap.SwapData[] memory swapData) {\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // standardizedCall\n            bytes memory unwrappedData = abi.decode(data[4:], (bytes));\n            (, swapData) = abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[])\n            );\n            return swapData;\n        }\n        // normal call\n        (, swapData) = abi.decode(\n            data[4:],\n            (ILiFi.BridgeData, LibSwap.SwapData[])\n        );\n    }\n}\n"
    },
    "src/Facets/CBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { CannotBridgeToSameNetwork } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { ContractCallNotAllowed, ExternalCallFailed } from \"../Errors/GenericErrors.sol\";\n\n/// @title CBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CBridge\n/// @custom:version 1.0.0\ncontract CBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    ICBridge private immutable cBridge;\n\n    /// Types ///\n\n    /// @param maxSlippage The max slippage accepted, given as percentage in point (pip).\n    /// @param nonce A number input to guarantee uniqueness of transferId.\n    ///              Can be timestamp in practice.\n    struct CBridgeData {\n        uint32 maxSlippage;\n        uint64 nonce;\n    }\n\n    /// Events ///\n    event CBridgeRefund(\n        address indexed _assetAddress,\n        address indexed _to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _cBridge The contract address of the cbridge on the source chain.\n    constructor(ICBridge _cBridge) {\n        cBridge = _cBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _cBridgeData data specific to CBridge\n    function startBridgeTokensViaCBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        CBridgeData calldata _cBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _cBridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via CBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _cBridgeData data specific to CBridge\n    function swapAndStartBridgeTokensViaCBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData calldata _cBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _cBridgeData);\n    }\n\n    /// @notice Triggers a cBridge refund with calldata produced by cBridge API\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to Address to withdraw to\n    /// @param _amount Amount of asset to withdraw\n    function triggerRefund(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        // make sure that callTo address is either of the cBridge addresses\n        if (address(cBridge) != _callTo) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        bool success;\n        (success, ) = _callTo.call(_callData);\n        if (!success) {\n            revert ExternalCallFailed();\n        }\n\n        // forward funds to _to address and emit event\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit CBridgeRefund(_assetAddress, sendTo, _amount);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _cBridgeData data specific to CBridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        CBridgeData calldata _cBridgeData\n    ) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            cBridge.sendNative{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(cBridge),\n                _bridgeData.minAmount\n            );\n            // solhint-disable check-send-result\n            cBridge.send(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/CBridgeFacetPacked.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { CBridgeFacet } from \"./CBridgeFacet.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ContractCallNotAllowed, ExternalCallFailed } from \"../Errors/GenericErrors.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title CBridge Facet Packed\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CBridge\n/// @custom:version 1.0.3\ncontract CBridgeFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    ICBridge private immutable cBridge;\n\n    /// Events ///\n\n    event LiFiCBridgeTransfer(bytes8 _transactionId);\n\n    event CBridgeRefund(\n        address indexed _assetAddress,\n        address indexed _to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _cBridge The contract address of the cbridge on the source chain.\n    constructor(\n        ICBridge _cBridge,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        cBridge = _cBridge;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the CBridge Router to spend the specified token\n    /// @param tokensToApprove The tokens to approve to the CBridge Router\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        for (uint256 i; i < tokensToApprove.length; i++) {\n            // Give CBridge approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(cBridge),\n                type(uint256).max\n            );\n        }\n    }\n\n    // This is needed to receive native asset if a refund asset is a native asset\n    receive() external payable {}\n\n    /// @notice Triggers a cBridge refund with calldata produced by cBridge API\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to Address to withdraw to\n    /// @param _amount Amount of asset to withdraw\n    function triggerRefund(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        // make sure that callTo address is either of the cBridge addresses\n        if (address(cBridge) != _callTo) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        bool success;\n        (success, ) = _callTo.call(_callData);\n        if (!success) {\n            revert ExternalCallFailed();\n        }\n\n        // forward funds to _to address and emit event\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit CBridgeRefund(_assetAddress, sendTo, _amount);\n    }\n\n    /// @notice Bridges Native tokens via cBridge (packed)\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaCBridgeNativePacked() external payable {\n        cBridge.sendNative{ value: msg.value }(\n            address(bytes20(msg.data[12:32])), // receiver\n            msg.value, // amount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            uint64(uint32(bytes4(msg.data[36:40]))), // nonce\n            uint32(bytes4(msg.data[40:44])) // maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(msg.data[4:12])); // transactionId\n    }\n\n    /// @notice Bridges native tokens via cBridge\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param nonce A number input to guarantee uniqueness of transferId.\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function startBridgeTokensViaCBridgeNativeMin(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external payable {\n        cBridge.sendNative{ value: msg.value }(\n            receiver,\n            msg.value,\n            destinationChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via cBridge\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaCBridgeERC20Packed() external {\n        address sendingAssetId = address(bytes20(msg.data[36:56]));\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        cBridge.send(\n            address(bytes20(msg.data[12:32])), // receiver\n            sendingAssetId, // sendingAssetId\n            amount, // amount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            uint64(uint32(bytes4(msg.data[72:76]))), // nonce\n            uint32(bytes4(msg.data[76:80])) // maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via cBridge\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param amount Amount of the source asset to bridge\n    /// @param nonce A number input to guarantee uniqueness of transferId\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function startBridgeTokensViaCBridgeERC20Min(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        address sendingAssetId,\n        uint256 amount,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        cBridge.send(\n            receiver,\n            sendingAssetId,\n            amount,\n            destinationChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(transactionId));\n    }\n\n    /// Encoder/Decoders ///\n\n    /// @notice Encodes calldata for startBridgeTokensViaCBridgeNativePacked\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param nonce A number input to guarantee uniqueness of transferId.\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function encode_startBridgeTokensViaCBridgeNativePacked(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            nonce <= type(uint32).max,\n            \"nonce value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                CBridgeFacetPacked\n                    .startBridgeTokensViaCBridgeNativePacked\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes4(uint32(nonce)),\n                bytes4(maxSlippage)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaCBridgeNativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaCBridgeNativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, CBridgeFacet.CBridgeData memory)\n    {\n        require(\n            _data.length >= 44,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        CBridgeFacet.CBridgeData memory cBridgeData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(_data[32:36])));\n        cBridgeData.nonce = uint64(uint32(bytes4(_data[36:40])));\n        cBridgeData.maxSlippage = uint32(bytes4(_data[40:44]));\n\n        return (bridgeData, cBridgeData);\n    }\n\n    /// @notice Encodes calldata for startBridgeTokensViaCBridgeERC20Packed\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param nonce A number input to guarantee uniqueness of transferId\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function encode_startBridgeTokensViaCBridgeERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            nonce <= type(uint32).max,\n            \"nonce value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                CBridgeFacetPacked\n                    .startBridgeTokensViaCBridgeERC20Packed\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(uint32(nonce)),\n                bytes4(maxSlippage)\n            );\n    }\n\n    function decode_startBridgeTokensViaCBridgeERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, CBridgeFacet.CBridgeData memory)\n    {\n        require(_data.length >= 80, \"data passed is not the correct length\");\n\n        BridgeData memory bridgeData;\n        CBridgeFacet.CBridgeData memory cBridgeData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        cBridgeData.nonce = uint64(uint32(bytes4(_data[72:76])));\n        cBridgeData.maxSlippage = uint32(bytes4(_data[76:80]));\n\n        return (bridgeData, cBridgeData);\n    }\n}\n"
    },
    "src/Facets/CelerCircleBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICircleBridgeProxy } from \"../Interfaces/ICircleBridgeProxy.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title CelerCircleBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CelerCircleBridge\n/// @custom:version 1.0.1\ncontract CelerCircleBridgeFacet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @notice The address of the CircleBridgeProxy on the current chain.\n    ICircleBridgeProxy private immutable circleBridgeProxy;\n\n    /// @notice The USDC address on the current chain.\n    address private immutable usdc;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _circleBridgeProxy The address of the CircleBridgeProxy on the current chain.\n    /// @param _usdc The address of USDC on the current chain.\n    constructor(ICircleBridgeProxy _circleBridgeProxy, address _usdc) {\n        circleBridgeProxy = _circleBridgeProxy;\n        usdc = _usdc;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CelerCircleBridge\n    /// @param _bridgeData Data containing core information for bridging\n    function startBridgeTokensViaCelerCircleBridge(\n        BridgeData calldata _bridgeData\n    )\n        external\n        nonReentrant\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        LibAsset.depositAsset(usdc, _bridgeData.minAmount);\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via CelerCircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaCelerCircleBridge(\n        BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CelerCircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    function _startBridge(BridgeData memory _bridgeData) private {\n        require(\n            _bridgeData.destinationChainId <= type(uint64).max,\n            \"_bridgeData.destinationChainId passed is too big to fit in uint64\"\n        );\n\n        // give max approval for token to CelerCircleBridge bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(usdc),\n            address(circleBridgeProxy),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        circleBridgeProxy.depositForBurn(\n            _bridgeData.minAmount,\n            uint64(_bridgeData.destinationChainId),\n            bytes32(uint256(uint160(_bridgeData.receiver))),\n            usdc\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/CelerIMFacetImmutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { CelerIMFacetBase, IMessageBus, MsgDataTypes, IERC20, CelerIM } from \"../Helpers/CelerIMFacetBase.sol\";\n\n/// @title CelerIMFacetImmutable\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging tokens and data through CBridge\n/// @notice This contract is exclusively used for immutable diamond contracts\n/// @custom:version 2.0.0\ncontract CelerIMFacetImmutable is CelerIMFacetBase {\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _messageBus The contract address of the cBridge Message Bus\n    /// @param _relayerOwner The address that will become the owner of the RelayerCelerIM contract\n    /// @param _diamondAddress The address of the diamond contract that will be connected with the RelayerCelerIM\n    /// @param _cfUSDC The contract address of the Celer Flow USDC\n    constructor(\n        IMessageBus _messageBus,\n        address _relayerOwner,\n        address _diamondAddress,\n        address _cfUSDC\n    ) CelerIMFacetBase(_messageBus, _relayerOwner, _diamondAddress, _cfUSDC) {}\n}\n"
    },
    "src/Facets/CelerIMFacetMutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { CelerIMFacetBase, IMessageBus, MsgDataTypes, IERC20, CelerIM } from \"../Helpers/CelerIMFacetBase.sol\";\n\n/// @title CelerIMFacetMutable\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging tokens and data through CBridge\n/// @notice This contract is exclusively used for mutable diamond contracts\n/// @custom:version 2.0.0\ncontract CelerIMFacetMutable is CelerIMFacetBase {\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _messageBus The contract address of the cBridge Message Bus\n    /// @param _relayerOwner The address that will become the owner of the RelayerCelerIM contract\n    /// @param _diamondAddress The address of the diamond contract that will be connected with the RelayerCelerIM\n    /// @param _cfUSDC The contract address of the Celer Flow USDC\n    constructor(\n        IMessageBus _messageBus,\n        address _relayerOwner,\n        address _diamondAddress,\n        address _cfUSDC\n    ) CelerIMFacetBase(_messageBus, _relayerOwner, _diamondAddress, _cfUSDC) {}\n}\n"
    },
    "src/Facets/CircleBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ITokenMessenger } from \"../Interfaces/ITokenMessenger.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title CircleBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CircleBridge\n/// @custom:version 1.0.0\ncontract CircleBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The address of the TokenMessenger on the source chain.\n    ITokenMessenger private immutable tokenMessenger;\n\n    /// @notice The USDC address on the source chain.\n    address private immutable usdc;\n\n    /// @param dstDomain The CircleBridge-specific domainId of the destination chain\n    struct CircleBridgeData {\n        uint32 dstDomain;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _tokenMessenger The address of the TokenMessenger on the source chain.\n    /// @param _usdc The address of USDC on the source chain.\n    constructor(ITokenMessenger _tokenMessenger, address _usdc) {\n        tokenMessenger = _tokenMessenger;\n        usdc = _usdc;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CircleBridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _circleBridgeData Data specific to bridge\n    function startBridgeTokensViaCircleBridge(\n        BridgeData calldata _bridgeData,\n        CircleBridgeData calldata _circleBridgeData\n    )\n        external\n        nonReentrant\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        LibAsset.depositAsset(usdc, _bridgeData.minAmount);\n        _startBridge(_bridgeData, _circleBridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via CircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _circleBridgeData Data specific to CircleBridge\n    function swapAndStartBridgeTokensViaCircleBridge(\n        BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        CircleBridgeData calldata _circleBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _circleBridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _circleBridgeData Data specific to CircleBridge\n    function _startBridge(\n        BridgeData memory _bridgeData,\n        CircleBridgeData calldata _circleBridgeData\n    ) private {\n        // give max approval for token to CircleBridge bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(usdc),\n            address(tokenMessenger),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        tokenMessenger.depositForBurn(\n            _bridgeData.minAmount,\n            _circleBridgeData.dstDomain,\n            bytes32(uint256(uint160(_bridgeData.receiver))),\n            usdc\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/DeBridgeDlnFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { IDlnSource } from \"../Interfaces/IDlnSource.sol\";\n\n/// @title DeBridgeDLN Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through DeBridge DLN\n/// @custom:version 1.0.0\ncontract DeBridgeDlnFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    address internal constant NON_EVM_ADDRESS =\n        0x11f111f111f111F111f111f111F111f111f111F1;\n    IDlnSource public immutable dlnSource;\n\n    /// Types ///\n\n    /// @param receivingAssetId The address of the asset to receive\n    /// @param receiver The address of the receiver\n    /// @param minAmountOut The minimum amount to receive on the destination chain\n    struct DeBridgeDlnData {\n        bytes receivingAssetId;\n        bytes receiver;\n        uint256 minAmountOut;\n    }\n\n    /// Events ///\n\n    event DlnOrderCreated(bytes32 indexed orderId);\n\n    event BridgeToNonEVMChain(\n        bytes32 indexed transactionId,\n        uint256 indexed destinationChainId,\n        bytes receiver\n    );\n\n    /// Constructor ///\n\n    /// @notice Constructor for the contract.\n    /// @param _dlnSource The address of the DLN order creation contract\n    constructor(IDlnSource _dlnSource) {\n        dlnSource = _dlnSource;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via DeBridgeDLN\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _deBridgeDlnData Data specific to DeBridgeDLN\n    function startBridgeTokensViaDeBridgeDln(\n        ILiFi.BridgeData memory _bridgeData,\n        DeBridgeDlnData calldata _deBridgeDlnData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(\n            _bridgeData,\n            _deBridgeDlnData,\n            dlnSource.globalFixedNativeFee()\n        );\n    }\n\n    /// @notice Performs a swap before bridging via DeBridgeDLN\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _deBridgeDlnData Data specific to DeBridgeDLN\n    function swapAndStartBridgeTokensViaDeBridgeDln(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        DeBridgeDlnData calldata _deBridgeDlnData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        uint256 fee = dlnSource.globalFixedNativeFee();\n        address assetId = _bridgeData.sendingAssetId;\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            LibAsset.isNativeAsset(assetId) ? 0 : fee\n        );\n        _startBridge(_bridgeData, _deBridgeDlnData, fee);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via DeBridgeDLN\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _deBridgeDlnData Data specific to DeBridgeDLN\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        DeBridgeDlnData calldata _deBridgeDlnData,\n        uint256 _fee\n    ) internal {\n        IDlnSource.OrderCreation memory orderCreation = IDlnSource\n            .OrderCreation({\n                giveTokenAddress: _bridgeData.sendingAssetId,\n                giveAmount: _bridgeData.minAmount,\n                takeTokenAddress: _deBridgeDlnData.receivingAssetId,\n                takeAmount: _deBridgeDlnData.minAmountOut,\n                takeChainId: _bridgeData.destinationChainId,\n                receiverDst: _deBridgeDlnData.receiver,\n                givePatchAuthoritySrc: _bridgeData.receiver,\n                orderAuthorityAddressDst: _deBridgeDlnData.receiver,\n                allowedTakerDst: \"\",\n                externalCall: \"\",\n                allowedCancelBeneficiarySrc: \"\"\n            });\n\n        bytes32 orderId;\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Give the DLN Source approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(dlnSource),\n                _bridgeData.minAmount\n            );\n\n            orderId = dlnSource.createOrder{ value: _fee }(\n                orderCreation,\n                \"\",\n                0,\n                \"\"\n            );\n        } else {\n            orderCreation.giveAmount = orderCreation.giveAmount - _fee;\n            orderId = dlnSource.createOrder{ value: _bridgeData.minAmount }(\n                orderCreation,\n                \"\",\n                0,\n                \"\"\n            );\n        }\n\n        emit DlnOrderCreated(orderId);\n\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _deBridgeDlnData.receiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/DeBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IDeBridgeGate } from \"../Interfaces/IDeBridgeGate.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { InformationMismatch, InvalidAmount } from \"../Errors/GenericErrors.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title DeBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through DeBridge Protocol\n/// @custom:version 1.0.0\ncontract DeBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the DeBridge Gate on the source chain.\n    IDeBridgeGate private immutable deBridgeGate;\n\n    /// Types ///\n\n    /// @param executionFee Fee paid to the transaction executor.\n    /// @param flags Flags set specific flows for call data execution.\n    /// @param fallbackAddress Receiver of the tokens if the call fails.\n    /// @param data Message/Call data to be passed to the receiver\n    ///             on the destination chain during the external call execution.\n    struct SubmissionAutoParamsTo {\n        uint256 executionFee;\n        uint256 flags;\n        bytes fallbackAddress;\n        bytes data;\n    }\n\n    /// @param nativeFee Native fee for the bridging when useAssetFee is false.\n    /// @param useAssetFee Use assets fee for pay protocol fix (work only for specials token)\n    /// @param referralCode Referral code.\n    /// @param autoParams Structure that enables passing arbitrary messages and call data.\n    struct DeBridgeData {\n        uint256 nativeFee;\n        bool useAssetFee;\n        uint32 referralCode;\n        SubmissionAutoParamsTo autoParams;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _deBridgeGate The contract address of the DeBridgeGate on the source chain.\n    constructor(IDeBridgeGate _deBridgeGate) {\n        deBridgeGate = _deBridgeGate;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via DeBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _deBridgeData data specific to DeBridge\n    function startBridgeTokensViaDeBridge(\n        ILiFi.BridgeData calldata _bridgeData,\n        DeBridgeData calldata _deBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _deBridgeData);\n\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _deBridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via DeBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _deBridgeData data specific to DeBridge\n    function swapAndStartBridgeTokensViaDeBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        DeBridgeData calldata _deBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _deBridgeData);\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _deBridgeData.nativeFee\n        );\n\n        _startBridge(_bridgeData, _deBridgeData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via DeBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _deBridgeData data specific to DeBridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        DeBridgeData calldata _deBridgeData\n    ) internal {\n        IDeBridgeGate.ChainSupportInfo memory config = deBridgeGate\n            .getChainToConfig(_bridgeData.destinationChainId);\n        uint256 nativeFee = config.fixedNativeFee == 0\n            ? deBridgeGate.globalFixedNativeFee()\n            : config.fixedNativeFee;\n\n        if (_deBridgeData.nativeFee != nativeFee) {\n            revert InvalidAmount();\n        }\n\n        bool isNative = LibAsset.isNativeAsset(_bridgeData.sendingAssetId);\n        uint256 nativeAssetAmount = _deBridgeData.nativeFee;\n\n        if (isNative) {\n            nativeAssetAmount += _bridgeData.minAmount;\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(deBridgeGate),\n                _bridgeData.minAmount\n            );\n        }\n\n        // solhint-disable-next-line check-send-result\n        deBridgeGate.send{ value: nativeAssetAmount }(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount,\n            _bridgeData.destinationChainId,\n            abi.encodePacked(_bridgeData.receiver),\n            \"\",\n            _deBridgeData.useAssetFee,\n            _deBridgeData.referralCode,\n            abi.encode(_deBridgeData.autoParams)\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        DeBridgeData calldata _deBridgeData\n    ) private pure {\n        if (\n            (_deBridgeData.autoParams.data.length > 0) !=\n            _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n}\n"
    },
    "src/Facets/DexManagerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { LibAllowList } from \"../Libraries/LibAllowList.sol\";\nimport { CannotAuthoriseSelf } from \"../Errors/GenericErrors.sol\";\n\n/// @title Dex Manager Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Facet contract for managing approved DEXs to be used in swaps.\n/// @custom:version 1.0.0\ncontract DexManagerFacet {\n    /// Events ///\n\n    event DexAdded(address indexed dexAddress);\n    event DexRemoved(address indexed dexAddress);\n    event FunctionSignatureApprovalChanged(\n        bytes4 indexed functionSignature,\n        bool indexed approved\n    );\n\n    /// External Methods ///\n\n    /// @notice Register the address of a DEX contract to be approved for swapping.\n    /// @param _dex The address of the DEX contract to be approved.\n    function addDex(address _dex) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        if (_dex == address(this)) {\n            revert CannotAuthoriseSelf();\n        }\n\n        LibAllowList.addAllowedContract(_dex);\n\n        emit DexAdded(_dex);\n    }\n\n    /// @notice Batch register the address of DEX contracts to be approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be approved.\n    function batchAddDex(address[] calldata _dexs) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _dexs.length;\n\n        for (uint256 i = 0; i < length; ) {\n            address dex = _dexs[i];\n            if (dex == address(this)) {\n                revert CannotAuthoriseSelf();\n            }\n            if (LibAllowList.contractIsAllowed(dex)) continue;\n            LibAllowList.addAllowedContract(dex);\n            emit DexAdded(dex);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Unregister the address of a DEX contract approved for swapping.\n    /// @param _dex The address of the DEX contract to be unregistered.\n    function removeDex(address _dex) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        LibAllowList.removeAllowedContract(_dex);\n        emit DexRemoved(_dex);\n    }\n\n    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be unregistered.\n    function batchRemoveDex(address[] calldata _dexs) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _dexs.length;\n        for (uint256 i = 0; i < length; ) {\n            LibAllowList.removeAllowedContract(_dexs[i]);\n            emit DexRemoved(_dexs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Adds/removes a specific function signature to/from the allowlist\n    /// @param _signature the function signature to allow/disallow\n    /// @param _approval whether the function signature should be allowed\n    function setFunctionApprovalBySignature(\n        bytes4 _signature,\n        bool _approval\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        if (_approval) {\n            LibAllowList.addAllowedSelector(_signature);\n        } else {\n            LibAllowList.removeAllowedSelector(_signature);\n        }\n\n        emit FunctionSignatureApprovalChanged(_signature, _approval);\n    }\n\n    /// @notice Batch Adds/removes a specific function signature to/from the allowlist\n    /// @param _signatures the function signatures to allow/disallow\n    /// @param _approval whether the function signatures should be allowed\n    function batchSetFunctionApprovalBySignature(\n        bytes4[] calldata _signatures,\n        bool _approval\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _signatures.length;\n        for (uint256 i = 0; i < length; ) {\n            bytes4 _signature = _signatures[i];\n            if (_approval) {\n                LibAllowList.addAllowedSelector(_signature);\n            } else {\n                LibAllowList.removeAllowedSelector(_signature);\n            }\n            emit FunctionSignatureApprovalChanged(_signature, _approval);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns whether a function signature is approved\n    /// @param _signature the function signature to query\n    /// @return approved Approved or not\n    function isFunctionApproved(\n        bytes4 _signature\n    ) public view returns (bool approved) {\n        return LibAllowList.selectorIsAllowed(_signature);\n    }\n\n    /// @notice Returns a list of all approved DEX addresses.\n    /// @return addresses List of approved DEX addresses\n    function approvedDexs()\n        external\n        view\n        returns (address[] memory addresses)\n    {\n        return LibAllowList.getAllowedContracts();\n    }\n}\n"
    },
    "src/Facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IDiamondCut } from \"../Interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Diamond Cut Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Core EIP-2535 Facet for upgrading Diamond Proxies.\n/// @custom:version 1.0.0\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n}\n"
    },
    "src/Facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../Interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../Interfaces/IERC165.sol\";\n\n/// @title Diamond Loupe Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Core EIP-2535 Facet for inspecting Diamond Proxies.\n/// @custom:version 1.0.0\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i = 0; i < numFacets; ) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds\n                .facetFunctionSelectors[facetAddress_]\n                .functionSelectors;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    )\n        external\n        view\n        override\n        returns (bytes4[] memory facetFunctionSelectors_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds\n            .facetFunctionSelectors[_facet]\n            .functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view override returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds\n            .selectorToFacetAndPosition[_functionSelector]\n            .facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view override returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "src/Facets/GenericSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { InvalidReceiver } from \"../Errors/GenericErrors.sol\";\n\n/// @title Generic Swap Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for swapping through ANY APPROVED DEX\n/// @dev Uses calldata to execute APPROVED arbitrary methods on DEXs\n/// @custom:version 1.0.0\ncontract GenericSwapFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// External Methods ///\n\n    /// @notice Performs multiple swaps in one transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensGeneric(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swapData\n    ) external payable nonReentrant refundExcessNative(_receiver) {\n        if (LibUtil.isZeroAddress(_receiver)) {\n            revert InvalidReceiver();\n        }\n\n        uint256 postSwapBalance = _depositAndSwap(\n            _transactionId,\n            _minAmount,\n            _swapData,\n            _receiver\n        );\n        address receivingAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        LibAsset.transferAsset(receivingAssetId, _receiver, postSwapBalance);\n\n        emit LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _swapData[0].sendingAssetId,\n            receivingAssetId,\n            _swapData[0].fromAmount,\n            postSwapBalance\n        );\n    }\n}\n"
    },
    "src/Facets/GnosisBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IXDaiBridge } from \"../Interfaces/IXDaiBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidSendingToken, NoSwapDataProvided } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Gnosis Bridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through XDaiBridge\n/// @custom:version 1.0.0\ncontract GnosisBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The DAI address on the source chain.\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    /// @notice The chain id of Gnosis.\n    uint64 private constant GNOSIS_CHAIN_ID = 100;\n\n    /// @notice The contract address of the xdai bridge on the source chain.\n    IXDaiBridge private immutable xDaiBridge;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _xDaiBridge The contract address of the xdai bridge on the source chain.\n    constructor(IXDaiBridge _xDaiBridge) {\n        xDaiBridge = _xDaiBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function startBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        nonReentrant\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, GNOSIS_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, DAI)\n    {\n        LibAsset.depositAsset(DAI, _bridgeData.minAmount);\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapAndStartBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, GNOSIS_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, DAI)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        LibAsset.maxApproveERC20(\n            IERC20(DAI),\n            address(xDaiBridge),\n            _bridgeData.minAmount\n        );\n        xDaiBridge.relayTokens(_bridgeData.receiver, _bridgeData.minAmount);\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/GnosisBridgeL2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IXDaiBridgeL2 } from \"../Interfaces/IXDaiBridgeL2.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidSendingToken, NoSwapDataProvided } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Gnosis Bridge Facet on Gnosis Chain\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through XDaiBridge\n/// @custom:version 1.0.0\ncontract GnosisBridgeL2Facet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @notice The xDAI address on the source chain.\n    address private constant XDAI = address(0);\n\n    /// @notice The chain id of Ethereum Mainnet.\n    uint64 private constant ETHEREUM_CHAIN_ID = 1;\n\n    /// @notice The contract address of the xdai bridge on the source chain.\n    IXDaiBridgeL2 private immutable xDaiBridge;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _xDaiBridge The contract address of the xdai bridge on the source chain.\n    constructor(IXDaiBridgeL2 _xDaiBridge) {\n        xDaiBridge = _xDaiBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function startBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, ETHEREUM_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, XDAI)\n    {\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapAndStartBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, ETHEREUM_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, XDAI)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        xDaiBridge.relayTokens{ value: _bridgeData.minAmount }(\n            _bridgeData.receiver\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/HopFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidConfig, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Hop Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 2.0.0\ncontract HopFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.hop\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(address => IHopBridge) bridges;\n        bool initialized; // no longer used but kept here to maintain the same storage layout\n    }\n\n    struct Config {\n        address assetId;\n        address bridge;\n    }\n\n    struct HopData {\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n        address relayer;\n        uint256 relayerFee;\n        uint256 nativeFee;\n    }\n\n    /// Events ///\n\n    event HopInitialized(Config[] configs);\n    event HopBridgeRegistered(address indexed assetId, address bridge);\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Hop Facet\n    /// @param configs Bridge configuration data\n    function initHop(Config[] calldata configs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        for (uint256 i = 0; i < configs.length; i++) {\n            if (configs[i].bridge == address(0)) {\n                revert InvalidConfig();\n            }\n            s.bridges[configs[i].assetId] = IHopBridge(configs[i].bridge);\n        }\n\n        emit HopInitialized(configs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Register token and bridge\n    /// @param assetId Address of token\n    /// @param bridge Address of bridge for asset\n    function registerBridge(address assetId, address bridge) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (bridge == address(0)) {\n            revert InvalidConfig();\n        }\n\n        s.bridges[assetId] = IHopBridge(bridge);\n\n        emit HopBridgeRegistered(assetId, bridge);\n    }\n\n    /// @notice Bridges tokens via Hop Protocol\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHop(\n        ILiFi.BridgeData memory _bridgeData,\n        HopData calldata _hopData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _hopData);\n    }\n\n    /// @notice Performs a swap before bridging via Hop Protocol\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHop(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n        _startBridge(_bridgeData, _hopData);\n    }\n\n    /// private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Hop Protocol\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        HopData calldata _hopData\n    ) private {\n        address sendingAssetId = _bridgeData.sendingAssetId;\n        Storage storage s = getStorage();\n        IHopBridge bridge = s.bridges[sendingAssetId];\n\n        // Give Hop approval to bridge tokens\n        LibAsset.maxApproveERC20(\n            IERC20(sendingAssetId),\n            address(bridge),\n            _bridgeData.minAmount\n        );\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId))\n            ? _hopData.nativeFee + _bridgeData.minAmount\n            : _hopData.nativeFee;\n\n        if (block.chainid == 1 || block.chainid == 5) {\n            // Ethereum L1\n            bridge.sendToL2{ value: value }(\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline,\n                _hopData.relayer,\n                _hopData.relayerFee\n            );\n        } else {\n            // L2\n            // solhint-disable-next-line check-send-result\n            bridge.swapAndSend{ value: value }(\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _hopData.bonderFee,\n                _hopData.amountOutMin,\n                _hopData.deadline,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline\n            );\n        }\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/HopFacetOptimized.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Hop Facet (Optimized)\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 2.0.0\ncontract HopFacetOptimized is ILiFi, SwapperV2 {\n    /// Types ///\n\n    struct HopData {\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n        IHopBridge hopBridge;\n        address relayer;\n        uint256 relayerFee;\n        uint256 nativeFee;\n    }\n\n    /// External Methods ///\n\n    /// @notice Sets approval for the Hop Bridge to spend the specified token\n    /// @param bridges The Hop Bridges to approve\n    /// @param tokensToApprove The tokens to approve to approve to the Hop Bridges\n    function setApprovalForBridges(\n        address[] calldata bridges,\n        address[] calldata tokensToApprove\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        for (uint256 i; i < bridges.length; i++) {\n            // Give Hop approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(bridges[i]),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL1ERC20(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL1Native(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging ERC20 tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL1ERC20(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging Native tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL1Native(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL2ERC20(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external {\n        // Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL2Native(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging ERC20 tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL2ERC20(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging Native tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL2Native(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/HopFacetPacked.sol": {
      "content": "// // SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IHopBridge, IL2AmmWrapper, ISwap } from \"../Interfaces/IHopBridge.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { HopFacetOptimized } from \"../../src/Facets/HopFacetOptimized.sol\";\nimport { WETH } from \"../../lib/solmate/src/tokens/WETH.sol\";\n\n/// @title Hop Facet (Optimized for Rollups)\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 1.0.6\ncontract HopFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage ///\n\n    address public immutable nativeBridge;\n    address public immutable nativeL2CanonicalToken;\n    address public immutable nativeHToken;\n    address public immutable nativeExchangeAddress;\n\n    /// Errors ///\n\n    error Invalid();\n\n    /// Events ///\n\n    event LiFiHopTransfer(bytes8 _transactionId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _owner The contract owner to approve tokens.\n    /// @param _wrapper The address of Hop L2_AmmWrapper for native asset.\n    constructor(\n        address _owner,\n        address _wrapper\n    ) TransferrableOwnership(_owner) {\n        bool wrapperIsSet = _wrapper != address(0);\n\n        if (block.chainid == 1 && wrapperIsSet) {\n            revert Invalid();\n        }\n\n        nativeL2CanonicalToken = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).l2CanonicalToken()\n            : address(0);\n        nativeHToken = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).hToken()\n            : address(0);\n        nativeExchangeAddress = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).exchangeAddress()\n            : address(0);\n        nativeBridge = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).bridge()\n            : address(0);\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Hop Bridge to spend the specified token\n    /// @param bridges The Hop Bridges to approve\n    /// @param tokensToApprove The tokens to approve to approve to the Hop Bridges\n    function setApprovalForHopBridges(\n        address[] calldata bridges,\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        uint256 numBridges = bridges.length;\n\n        for (uint256 i; i < numBridges; i++) {\n            // Give Hop approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(bridges[i]),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL2NativePacked() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[36:52]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[52:68])))\n        // => total calldata length required: 68\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[52:68])));\n        bool toL1 = destinationChainId == 1;\n\n        // Wrap ETH\n        WETH(payable(nativeL2CanonicalToken)).deposit{ value: msg.value }();\n\n        // Exchange WETH for hToken\n        uint256 swapAmount = ISwap(nativeExchangeAddress).swap(\n            0,\n            1,\n            msg.value,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(nativeBridge).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])), // receiver\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[36:52]))), // bonderFee\n            toL1 ? 0 : amountOutMin,\n            toL1 ? 0 : block.timestamp + 7 * 24 * 60 * 60\n        );\n\n        emit LiFiHopTransfer(\n            bytes8(msg.data[4:12]) // transactionId\n        );\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param hopBridge Address of the Hop L2_AmmWrapper\n    function startBridgeTokensViaHopL2NativeMin(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address hopBridge\n    ) external payable {\n        // Bridge assets\n        IHopBridge(hopBridge).swapAndSend{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    function encode_startBridgeTokensViaHopL2NativePacked(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 bonderFee,\n        uint256 amountOutMin\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin))\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL2NativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL2NativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 68,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[36:52])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[52:68])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL2ERC20Packed() external {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[88:104]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[104:120]))),\n        // destinationDeadline: uint256(uint32(bytes4(msg.data[120:124]))),\n        // wrapper: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[88:104])));\n        bool toL1 = destinationChainId == 1;\n\n        IL2AmmWrapper wrapper = IL2AmmWrapper(\n            address(bytes20(msg.data[124:144]))\n        );\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Exchange sending asset to hToken\n        uint256 swapAmount = ISwap(wrapper.exchangeAddress()).swap(\n            0,\n            1,\n            amount,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(wrapper.bridge()).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])),\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            toL1 ? 0 : uint256(uint128(bytes16(msg.data[104:120]))),\n            toL1 ? 0 : uint256(uint32(bytes4(msg.data[120:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param hopBridge Address of the Hop L2_AmmWrapper\n    function startBridgeTokensViaHopL2ERC20Min(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address hopBridge\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).swapAndSend(\n            destinationChainId,\n            receiver,\n            minAmount,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param wrapper Address of the Hop L2_AmmWrapper\n    function encode_startBridgeTokensViaHopL2ERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address wrapper\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationDeadline <= type(uint32).max,\n            \"destinationDeadline value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes4(uint32(destinationDeadline)),\n                bytes20(wrapper)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL2ERC20Packed\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL2ERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[88:104])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[104:120]))\n        );\n        hopData.destinationDeadline = uint256(uint32(bytes4(_data[120:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL1NativePacked() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[36:52]))),\n        // relayer: address(bytes20(msg.data[52:72])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // hopBridge: address(bytes20(msg.data[88:108]))\n        // => total calldata length required: 108\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[88:108]))).sendToL2{\n            value: msg.value\n        }(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            msg.value,\n            uint256(uint128(bytes16(msg.data[36:52]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[52:72])),\n            uint256(uint128(bytes16(msg.data[72:88])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function startBridgeTokensViaHopL1NativeMin(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external payable {\n        // Bridge assets\n        IHopBridge(hopBridge).sendToL2{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function encode_startBridgeTokensViaHopL1NativePacked(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL1NativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL1NativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 108,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[36:52]))\n        );\n        // relayer = address(bytes20(_data[52:72]));\n        // relayerFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[88:108])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL1ERC20Packed() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[72:88]))),\n        // relayer: address(bytes20(msg.data[88:108])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[108:124]))),\n        // hopBridge: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[124:144]))).sendToL2(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            amount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[88:108])),\n            uint256(uint128(bytes16(msg.data[108:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function startBridgeTokensViaHopL1ERC20Min(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).sendToL2(\n            destinationChainId,\n            receiver,\n            minAmount,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function encode_startBridgeTokensViaHopL1ERC20Packed(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL1ERC20Packed\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL1ERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[72:88]))\n        );\n        // relayer = address(bytes20(_data[88:108]));\n        // relayerFee = uint256(uint128(bytes16(_data[108:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }\n}\n"
    },
    "src/Facets/HyphenFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHyphenRouter } from \"../Interfaces/IHyphenRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Hyphen Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hyphen\n/// @custom:version 1.0.0\ncontract HyphenFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the router on the source chain.\n    IHyphenRouter private immutable router;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _router The contract address of the router on the source chain.\n    constructor(IHyphenRouter _router) {\n        router = _router;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Hyphen\n    /// @param _bridgeData the core information needed for bridging\n    function startBridgeTokensViaHyphen(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via Hyphen\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaHyphen(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Hyphen\n    /// @param _bridgeData the core information needed for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Give the Hyphen router approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(router),\n                _bridgeData.minAmount\n            );\n\n            router.depositErc20(\n                _bridgeData.destinationChainId,\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                \"LIFI\"\n            );\n        } else {\n            router.depositNative{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _bridgeData.destinationChainId,\n                \"LIFI\"\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/LIFuelFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ServiceFeeCollector } from \"../Periphery/ServiceFeeCollector.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title LIFuel Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging gas through LIFuel\n/// @custom:version 1.0.0\ncontract LIFuelFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.periphery_registry\");\n    string internal constant FEE_COLLECTOR_NAME = \"ServiceFeeCollector\";\n\n    /// Types ///\n\n    struct Storage {\n        mapping(string => address) contracts;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via LIFuel Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    function startBridgeTokensViaLIFuel(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via LIFuel Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaLIFuel(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via LIFuel Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        ServiceFeeCollector serviceFeeCollector = ServiceFeeCollector(\n            getStorage().contracts[FEE_COLLECTOR_NAME]\n        );\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            serviceFeeCollector.collectNativeGasFees{\n                value: _bridgeData.minAmount\n            }(_bridgeData.destinationChainId, _bridgeData.receiver);\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(serviceFeeCollector),\n                _bridgeData.minAmount\n            );\n\n            serviceFeeCollector.collectTokenGasFees(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/MakerTeleportFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ITeleportGateway } from \"../Interfaces/ITeleportGateway.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { InvalidSendingToken, NoSwapDataProvided } from \"../Errors/GenericErrors.sol\";\n\n/// @title MakerTeleport Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Maker Teleport\n/// @custom:version 1.0.0\ncontract MakerTeleportFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    using SafeCast for uint256;\n\n    /// Storage ///\n\n    /// @notice The address of Teleport Gateway.\n    ITeleportGateway private immutable teleportGateway;\n\n    /// @notice The address of DAI on the source chain.\n    address private immutable dai;\n\n    /// @notice The chain id of destination chain.\n    uint256 private immutable dstChainId;\n\n    /// @notice The domain of l1 network.\n    bytes32 private immutable l1Domain;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _teleportGateway The address of Teleport Gateway.\n    /// @param _dai The address of DAI on the source chain.\n    /// @param _dstChainId The chain id of destination chain.\n    /// @param _l1Domain The domain of l1 network.\n    constructor(\n        ITeleportGateway _teleportGateway,\n        address _dai,\n        uint256 _dstChainId,\n        bytes32 _l1Domain\n    ) {\n        dstChainId = _dstChainId;\n        teleportGateway = _teleportGateway;\n        dai = _dai;\n        l1Domain = _l1Domain;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Maker Teleport\n    /// @param _bridgeData The core information needed for bridging\n    function startBridgeTokensViaMakerTeleport(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        nonReentrant\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, dstChainId)\n        onlyAllowSourceToken(_bridgeData, dai)\n    {\n        LibAsset.depositAsset(dai, _bridgeData.minAmount);\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via Maker Teleport\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaMakerTeleport(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, dstChainId)\n        onlyAllowSourceToken(_bridgeData, dai)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Maker Teleport\n    /// @param _bridgeData The core information needed for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) internal {\n        LibAsset.maxApproveERC20(\n            IERC20(dai),\n            address(teleportGateway),\n            _bridgeData.minAmount\n        );\n\n        teleportGateway.initiateTeleport(\n            l1Domain,\n            _bridgeData.receiver,\n            _bridgeData.minAmount.toUint128()\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/MultichainFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { IMultichainRouter } from \"../Interfaces/IMultichainRouter.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidConfig, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\ninterface IMultichainERC20 {\n    function Swapout(uint256 amount, address bindaddr) external returns (bool);\n}\n\n/// @title Multichain Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n/// @custom:version 1.0.1\ncontract MultichainFacet is ILiFi, SwapperV2, ReentrancyGuard, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.multichain\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(address => bool) allowedRouters;\n        bool initialized; // no longer used but kept here to maintain the same storage layout\n        address anyNative;\n        mapping(address => address) anyTokenAddresses;\n    }\n\n    struct MultichainData {\n        address router;\n    }\n\n    struct AnyMapping {\n        address tokenAddress;\n        address anyTokenAddress;\n    }\n\n    /// Errors ///\n\n    error InvalidRouter();\n\n    /// Events ///\n\n    event MultichainInitialized();\n    event MultichainRoutersUpdated(address[] routers, bool[] allowed);\n    event AnyMappingUpdated(AnyMapping[] mappings);\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Multichain Facet\n    /// @param anyNative The address of the anyNative (e.g. anyETH) token\n    /// @param routers Allowed Multichain Routers\n    function initMultichain(\n        address anyNative,\n        address[] calldata routers\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        s.anyNative = anyNative;\n\n        uint256 len = routers.length;\n        for (uint256 i = 0; i < len; ) {\n            if (routers[i] == address(0)) {\n                revert InvalidConfig();\n            }\n            s.allowedRouters[routers[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit MultichainInitialized();\n    }\n\n    /// External Methods ///\n\n    /// @notice Updates the tokenAddress > anyTokenAddress storage\n    /// @param mappings A mapping of tokenAddress(es) to anyTokenAddress(es)\n    function updateAddressMappings(AnyMapping[] calldata mappings) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        for (uint64 i; i < mappings.length; ) {\n            s.anyTokenAddresses[mappings[i].tokenAddress] = mappings[i]\n                .anyTokenAddress;\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit AnyMappingUpdated(mappings);\n    }\n\n    /// @notice (Batch) register routers\n    /// @param routers Router addresses\n    /// @param allowed Array of whether the addresses are allowed or not\n    function registerRouters(\n        address[] calldata routers,\n        bool[] calldata allowed\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        uint256 len = routers.length;\n        for (uint256 i = 0; i < len; ) {\n            if (routers[i] == address(0)) {\n                revert InvalidConfig();\n            }\n            s.allowedRouters[routers[i]] = allowed[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n        emit MultichainRoutersUpdated(routers, allowed);\n    }\n\n    /// @notice Bridges tokens via Multichain\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _multichainData data specific to Multichain\n    function startBridgeTokensViaMultichain(\n        ILiFi.BridgeData memory _bridgeData,\n        MultichainData calldata _multichainData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        Storage storage s = getStorage();\n        if (!s.allowedRouters[_multichainData.router]) {\n            revert InvalidRouter();\n        }\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId))\n            LibAsset.depositAsset(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount\n            );\n\n        _startBridge(_bridgeData, _multichainData);\n    }\n\n    /// @notice Performs a swap before bridging via Multichain\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _multichainData data specific to Multichain\n    function swapAndStartBridgeTokensViaMultichain(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        MultichainData calldata _multichainData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        Storage storage s = getStorage();\n\n        if (!s.allowedRouters[_multichainData.router]) {\n            revert InvalidRouter();\n        }\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _multichainData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Multichain\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _multichainData data specific to Multichain\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        MultichainData calldata _multichainData\n    ) private {\n        // check if sendingAsset is a Multichain token that needs to be called directly in order to bridge it\n        if (_multichainData.router == _bridgeData.sendingAssetId) {\n            IMultichainERC20(_bridgeData.sendingAssetId).Swapout(\n                _bridgeData.minAmount,\n                _bridgeData.receiver\n            );\n        } else {\n            Storage storage s = getStorage();\n            if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n                // call native asset bridge function\n                IMultichainRouter(_multichainData.router).anySwapOutNative{\n                    value: _bridgeData.minAmount\n                }(\n                    s.anyNative,\n                    _bridgeData.receiver,\n                    _bridgeData.destinationChainId\n                );\n            } else {\n                // Give Multichain router approval to pull tokens\n                LibAsset.maxApproveERC20(\n                    IERC20(_bridgeData.sendingAssetId),\n                    _multichainData.router,\n                    _bridgeData.minAmount\n                );\n\n                address anyToken = s.anyTokenAddresses[\n                    _bridgeData.sendingAssetId\n                ];\n\n                // replace tokenAddress with anyTokenAddress (if mapping found) and call ERC20 asset bridge function\n                IMultichainRouter(_multichainData.router).anySwapOutUnderlying(\n                    anyToken != address(0)\n                        ? anyToken\n                        : _bridgeData.sendingAssetId,\n                    _bridgeData.receiver,\n                    _bridgeData.minAmount,\n                    _bridgeData.destinationChainId\n                );\n            }\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/NonStandardSelectorsRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Non Standard Selectors Registry Facet\n/// @author LIFI (https://li.finance)\n/// @notice Registry for non-standard selectors\n/// @custom:version 1.0.0\ncontract NonStandardSelectorsRegistryFacet {\n    // Storage //\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.nonstandardselectorsregistry\");\n\n    // Types //\n    struct Storage {\n        mapping(bytes4 => bool) selectors;\n    }\n\n    // @notice set a selector as non-standard\n    // @param _selector the selector to set\n    // @param _isNonStandardSelector whether the selector is non-standard\n    function setNonStandardSelector(\n        bytes4 _selector,\n        bool _isNonStandardSelector\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n        s.selectors[_selector] = _isNonStandardSelector;\n    }\n\n    // @notice batch set selectors as non-standard\n    // @param _selectors the selectors to set\n    // @param _isNonStandardSelectors whether the selectors are non-standard\n    function batchSetNonStandardSelectors(\n        bytes4[] calldata _selectors,\n        bool[] calldata _isNonStandardSelectors\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n        require(\n            _selectors.length == _isNonStandardSelectors.length,\n            \"NonStandardSelectorsRegistryFacet: selectors and isNonStandardSelectors length mismatch\"\n        );\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            s.selectors[_selectors[i]] = _isNonStandardSelectors[i];\n        }\n    }\n\n    // @notice check if a selector is non-standard\n    // @param _selector the selector to check\n    // @return whether the selector is non-standard\n    function isNonStandardSelector(\n        bytes4 _selector\n    ) external view returns (bool) {\n        return getStorage().selectors[_selector];\n    }\n\n    // Internal Functions //\n\n    // @notice get the storage slot for the NonStandardSelectorsRegistry\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 position = NAMESPACE;\n        assembly {\n            s.slot := position\n        }\n    }\n}\n"
    },
    "src/Facets/OmniBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IOmniBridge } from \"../Interfaces/IOmniBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title OmniBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through OmniBridge\n/// @custom:version 1.0.0\ncontract OmniBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the foreign omni bridge on the source chain.\n    IOmniBridge private immutable foreignOmniBridge;\n\n    /// @notice The contract address of the weth omni bridge on the source chain.\n    IOmniBridge private immutable wethOmniBridge;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _foreignOmniBridge The contract address of the foreign omni bridge on the source chain.\n    /// @param _wethOmniBridge The contract address of the weth omni bridge on the source chain.\n    constructor(IOmniBridge _foreignOmniBridge, IOmniBridge _wethOmniBridge) {\n        foreignOmniBridge = _foreignOmniBridge;\n        wethOmniBridge = _wethOmniBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via OmniBridge\n    /// @param _bridgeData Data contaning core information for bridging\n    function startBridgeTokensViaOmniBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via OmniBridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaOmniBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via OmniBridge\n    /// @param _bridgeData Data contaning core information for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            wethOmniBridge.wrapAndRelayTokens{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(foreignOmniBridge),\n                _bridgeData.minAmount\n            );\n            foreignOmniBridge.relayTokens(\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/OptimismBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IL1StandardBridge } from \"../Interfaces/IL1StandardBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidConfig, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\n\n/// @title Optimism Bridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Optimism Bridge\n/// @custom:version 1.0.0\ncontract OptimismBridgeFacet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.optimism\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(address => IL1StandardBridge) bridges;\n        IL1StandardBridge standardBridge;\n        bool initialized;\n    }\n\n    struct Config {\n        address assetId;\n        address bridge;\n    }\n\n    struct OptimismData {\n        address assetIdOnL2;\n        uint32 l2Gas;\n        bool isSynthetix;\n    }\n\n    /// Events ///\n\n    event OptimismInitialized(Config[] configs);\n    event OptimismBridgeRegistered(address indexed assetId, address bridge);\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Optimism Bridge Facet\n    /// @param configs Bridge configuration data\n    function initOptimism(\n        Config[] calldata configs,\n        IL1StandardBridge standardBridge\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (s.initialized) {\n            revert AlreadyInitialized();\n        }\n\n        for (uint256 i = 0; i < configs.length; i++) {\n            if (configs[i].bridge == address(0)) {\n                revert InvalidConfig();\n            }\n            s.bridges[configs[i].assetId] = IL1StandardBridge(\n                configs[i].bridge\n            );\n        }\n\n        s.standardBridge = standardBridge;\n        s.initialized = true;\n\n        emit OptimismInitialized(configs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Register token and bridge\n    /// @param assetId Address of token\n    /// @param bridge Address of bridge for asset\n    function registerOptimismBridge(address assetId, address bridge) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (!s.initialized) revert NotInitialized();\n\n        if (bridge == address(0)) {\n            revert InvalidConfig();\n        }\n\n        s.bridges[assetId] = IL1StandardBridge(bridge);\n\n        emit OptimismBridgeRegistered(assetId, bridge);\n    }\n\n    /// @notice Bridges tokens via Optimism Bridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _bridgeData Data specific to Optimism Bridge\n    function startBridgeTokensViaOptimismBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        OptimismData calldata _optimismData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _optimismData);\n    }\n\n    /// @notice Performs a swap before bridging via Optimism Bridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _bridgeData Data specific to Optimism Bridge\n    function swapAndStartBridgeTokensViaOptimismBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        OptimismData calldata _optimismData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _optimismData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Optimism Bridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _bridgeData Data specific to Optimism Bridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        OptimismData calldata _optimismData\n    ) private {\n        Storage storage s = getStorage();\n        IL1StandardBridge nonStandardBridge = s.bridges[\n            _bridgeData.sendingAssetId\n        ];\n        IL1StandardBridge bridge = LibUtil.isZeroAddress(\n            address(nonStandardBridge)\n        )\n            ? s.standardBridge\n            : nonStandardBridge;\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            bridge.depositETHTo{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _optimismData.l2Gas,\n                \"\"\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(bridge),\n                _bridgeData.minAmount\n            );\n\n            if (_optimismData.isSynthetix) {\n                bridge.depositTo(_bridgeData.receiver, _bridgeData.minAmount);\n            } else {\n                bridge.depositERC20To(\n                    _bridgeData.sendingAssetId,\n                    _optimismData.assetIdOnL2,\n                    _bridgeData.receiver,\n                    _bridgeData.minAmount,\n                    _optimismData.l2Gas,\n                    \"\"\n                );\n            }\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../Interfaces/IERC173.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\n/// @title Ownership Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Manages ownership of the LiFi Diamond contract for admin purposes\n/// @custom:version 1.0.0\ncontract OwnershipFacet is IERC173 {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.ownership\");\n\n    /// Types ///\n\n    struct Storage {\n        address newOwner;\n    }\n\n    /// Errors ///\n\n    error NoNullOwner();\n    error NewOwnerMustNotBeSelf();\n    error NoPendingOwnershipTransfer();\n    error NotPendingOwner();\n\n    /// Events ///\n\n    event OwnershipTransferRequested(\n        address indexed _from,\n        address indexed _to\n    );\n\n    /// External Methods ///\n\n    /// @notice Initiates transfer of ownership to a new address\n    /// @param _newOwner the address to transfer ownership to\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n\n        if (LibUtil.isZeroAddress(_newOwner)) revert NoNullOwner();\n\n        if (_newOwner == LibDiamond.contractOwner())\n            revert NewOwnerMustNotBeSelf();\n\n        s.newOwner = _newOwner;\n        emit OwnershipTransferRequested(msg.sender, s.newOwner);\n    }\n\n    /// @notice Cancel transfer of ownership\n    function cancelOwnershipTransfer() external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n\n        if (LibUtil.isZeroAddress(s.newOwner))\n            revert NoPendingOwnershipTransfer();\n        s.newOwner = address(0);\n    }\n\n    /// @notice Confirms transfer of ownership to the calling address (msg.sender)\n    function confirmOwnershipTransfer() external {\n        Storage storage s = getStorage();\n        address _pendingOwner = s.newOwner;\n        if (msg.sender != _pendingOwner) revert NotPendingOwner();\n        emit OwnershipTransferred(LibDiamond.contractOwner(), _pendingOwner);\n        LibDiamond.setContractOwner(_pendingOwner);\n        s.newOwner = LibAsset.NULL_ADDRESS;\n    }\n\n    /// @notice Return the current owner address\n    /// @return owner_ The current owner address\n    function owner() external view override returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n\n    /// Private Methods ///\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/PeripheryRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Periphery Registry Facet\n/// @author LI.FI (https://li.fi)\n/// @notice A simple registry to track LIFI periphery contracts\n/// @custom:version 1.0.0\ncontract PeripheryRegistryFacet {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.periphery_registry\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(string => address) contracts;\n    }\n\n    /// Events ///\n\n    event PeripheryContractRegistered(string name, address contractAddress);\n\n    /// External Methods ///\n\n    /// @notice Registers a periphery contract address with a specified name\n    /// @param _name the name to register the contract address under\n    /// @param _contractAddress the address of the contract to register\n    function registerPeripheryContract(\n        string calldata _name,\n        address _contractAddress\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n        s.contracts[_name] = _contractAddress;\n        emit PeripheryContractRegistered(_name, _contractAddress);\n    }\n\n    /// @notice Returns the registered contract address by its name\n    /// @param _name the registered name of the contract\n    function getPeripheryContract(\n        string calldata _name\n    ) external view returns (address) {\n        return getStorage().contracts[_name];\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/PolygonBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IRootChainManager } from \"../Interfaces/IRootChainManager.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Polygon Bridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Polygon Bridge\n/// @custom:version 1.0.0\ncontract PolygonBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the RootChainManager on the source chain.\n    IRootChainManager private immutable rootChainManager;\n\n    /// @notice The contract address of the ERC20Predicate on the source chain.\n    address private immutable erc20Predicate;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _rootChainManager The contract address of the RootChainManager on the source chain.\n    /// @param _erc20Predicate The contract address of the ERC20Predicate on the source chain.\n    constructor(IRootChainManager _rootChainManager, address _erc20Predicate) {\n        rootChainManager = _rootChainManager;\n        erc20Predicate = _erc20Predicate;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Polygon Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    function startBridgeTokensViaPolygonBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via Polygon Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaPolygonBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Polygon Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        address childToken;\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            rootChainManager.depositEtherFor{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver\n            );\n        } else {\n            childToken = rootChainManager.rootToChildToken(\n                _bridgeData.sendingAssetId\n            );\n\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                erc20Predicate,\n                _bridgeData.minAmount\n            );\n\n            bytes memory depositData = abi.encode(_bridgeData.minAmount);\n            rootChainManager.depositFor(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                depositData\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/StandardizedCallFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Standardized Call Facet\n/// @author LIFI https://li.finance ed@li.finance\n/// @notice Allows calling different facet methods through a single standardized entrypoint\n/// @custom:version 1.0.0\ncontract StandardizedCallFacet {\n    /// External Methods ///\n\n    /// @notice Make a standardized call to a facet\n    /// @param callData The calldata to forward to the facet\n    function standardizedCall(bytes memory callData) external payable {\n        // Fetch the facetAddress from the dimaond's internal storage\n        // Cheaper than calling the external facetAddress(selector) method directly\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        address facetAddress = ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress;\n\n        if (facetAddress == address(0)) {\n            revert LibDiamond.FunctionDoesNotExist();\n        }\n\n        // Execute external function from facet using delegatecall and return any value.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // execute function call using the facet\n            let result := delegatecall(\n                gas(),\n                facetAddress,\n                add(callData, 0x20),\n                mload(callData),\n                0,\n                0\n            )\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "src/Facets/StargateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IStargateRouter } from \"../Interfaces/IStargateRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InformationMismatch, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Stargate Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Stargate\n/// @custom:version 2.2.0\ncontract StargateFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// CONSTANTS ///\n\n    /// @notice The contract address of the stargate composer on the source chain.\n    IStargateRouter private immutable composer;\n\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.stargate\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(uint256 => uint16) layerZeroChainId;\n        bool initialized;\n    }\n\n    struct ChainIdConfig {\n        uint256 chainId;\n        uint16 layerZeroChainId;\n    }\n\n    /// @param srcPoolId Source pool id.\n    /// @param dstPoolId Dest pool id.\n    /// @param minAmountLD The min qty you would accept on the destination.\n    /// @param dstGasForCall Additional gas fee for extral call on the destination.\n    /// @param lzFee Estimated message fee.\n    /// @param refundAddress Refund adddress. Extra gas (if any) is returned to this address\n    /// @param callTo The address to send the tokens to on the destination.\n    /// @param callData Additional payload.\n    struct StargateData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        uint256 minAmountLD;\n        uint256 dstGasForCall;\n        uint256 lzFee;\n        address payable refundAddress;\n        bytes callTo;\n        bytes callData;\n    }\n\n    /// Errors ///\n\n    error UnknownLayerZeroChain();\n\n    /// Events ///\n\n    event StargateInitialized(ChainIdConfig[] chainIdConfigs);\n\n    event LayerZeroChainIdSet(\n        uint256 indexed chainId,\n        uint16 layerZeroChainId\n    );\n\n    /// @notice Emit to get credited for referral\n    /// @dev Our partner id is 0x0006\n    event PartnerSwap(bytes2 partnerId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _composer The contract address of the stargate composer router on the source chain.\n    constructor(IStargateRouter _composer) {\n        composer = _composer;\n    }\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Stargate Facet\n    /// @param chainIdConfigs Chain Id configuration data\n    function initStargate(ChainIdConfig[] calldata chainIdConfigs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage sm = getStorage();\n\n        for (uint256 i = 0; i < chainIdConfigs.length; i++) {\n            sm.layerZeroChainId[chainIdConfigs[i].chainId] = chainIdConfigs[i]\n                .layerZeroChainId;\n        }\n\n        sm.initialized = true;\n\n        emit StargateInitialized(chainIdConfigs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function startBridgeTokensViaStargate(\n        ILiFi.BridgeData calldata _bridgeData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _stargateData);\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    /// @notice Performs a swap before bridging via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _stargateData Data specific to Stargate Bridge\n    function swapAndStartBridgeTokensViaStargate(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _stargateData);\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            LibAsset.isNativeAsset(_bridgeData.sendingAssetId)\n                ? 0\n                : _stargateData.lzFee\n        );\n\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    function quoteLayerZeroFee(\n        uint256 _destinationChainId,\n        StargateData calldata _stargateData\n    ) external view returns (uint256, uint256) {\n        return\n            composer.quoteLayerZeroFee(\n                getLayerZeroChainId(_destinationChainId),\n                1, // TYPE_SWAP_REMOTE on Bridge\n                _stargateData.callTo,\n                _stargateData.callData,\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                )\n            );\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        StargateData calldata _stargateData\n    ) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            composer.swapETHAndCall{ value: _bridgeData.minAmount }(\n                getLayerZeroChainId(_bridgeData.destinationChainId),\n                _stargateData.refundAddress,\n                _stargateData.callTo,\n                IStargateRouter.SwapAmount(\n                    _bridgeData.minAmount - _stargateData.lzFee,\n                    _stargateData.minAmountLD\n                ),\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                ),\n                _stargateData.callData\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(composer),\n                _bridgeData.minAmount\n            );\n\n            composer.swap{ value: _stargateData.lzFee }(\n                getLayerZeroChainId(_bridgeData.destinationChainId),\n                _stargateData.srcPoolId,\n                _stargateData.dstPoolId,\n                _stargateData.refundAddress,\n                _bridgeData.minAmount,\n                _stargateData.minAmountLD,\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                ),\n                _stargateData.callTo,\n                _stargateData.callData\n            );\n        }\n\n        emit PartnerSwap(0x0006);\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        StargateData calldata _stargateData\n    ) private pure {\n        if (\n            (_stargateData.callData.length > 0) !=\n            _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n\n    /// Mappings management ///\n\n    /// @notice Sets the Layer 0 chain ID for a given chain ID\n    /// @param _chainId uint16 of the chain ID\n    /// @param _layerZeroChainId uint16 of the Layer 0 chain ID\n    /// @dev This is used to map a chain ID to its Layer 0 chain ID\n    function setLayerZeroChainId(\n        uint256 _chainId,\n        uint16 _layerZeroChainId\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage sm = getStorage();\n\n        if (!sm.initialized) {\n            revert NotInitialized();\n        }\n\n        sm.layerZeroChainId[_chainId] = _layerZeroChainId;\n        emit LayerZeroChainIdSet(_chainId, _layerZeroChainId);\n    }\n\n    /// @notice Gets the Layer 0 chain ID for a given chain ID\n    /// @param _chainId uint256 of the chain ID\n    /// @return uint16 of the Layer 0 chain ID\n    function getLayerZeroChainId(\n        uint256 _chainId\n    ) private view returns (uint16) {\n        Storage storage sm = getStorage();\n        uint16 chainId = sm.layerZeroChainId[_chainId];\n        if (chainId == 0) revert UnknownLayerZeroChain();\n        return chainId;\n    }\n\n    function toBytes(address _address) private pure returns (bytes memory) {\n        return abi.encodePacked(_address);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/SymbiosisFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ISymbiosisMetaRouter } from \"../Interfaces/ISymbiosisMetaRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Symbiosis Facet\n/// @author Symbiosis (https://symbiosis.finance)\n/// @notice Provides functionality for bridging through Symbiosis Protocol\n/// @custom:version 1.0.0\ncontract SymbiosisFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the Symbiosis router on the source chain\n    ISymbiosisMetaRouter private immutable symbiosisMetaRouter;\n    address private immutable symbiosisGateway;\n\n    /// Types ///\n\n    /// @notice The data specific to Symbiosis\n    /// @param firstSwapCalldata The calldata for the first swap\n    /// @param secondSwapCalldata The calldata for the second swap\n    /// @param intermediateToken The intermediate token used for swapping\n    /// @param firstDexRouter The router for the first swap\n    /// @param secondDexRouter The router for the second swap\n    /// @param approvedTokens The tokens approved for swapping\n    /// @param callTo The bridging entrypoint\n    /// @param callData The bridging calldata\n    struct SymbiosisData {\n        bytes firstSwapCalldata;\n        bytes secondSwapCalldata;\n        address intermediateToken;\n        address firstDexRouter;\n        address secondDexRouter;\n        address[] approvedTokens;\n        address callTo;\n        bytes callData;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _symbiosisMetaRouter The contract address of the Symbiosis MetaRouter on the source chain.\n    /// @param _symbiosisGateway The contract address of the Symbiosis Gateway on the source chain.\n    constructor(\n        ISymbiosisMetaRouter _symbiosisMetaRouter,\n        address _symbiosisGateway\n    ) {\n        symbiosisMetaRouter = _symbiosisMetaRouter;\n        symbiosisGateway = _symbiosisGateway;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Symbiosis\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _symbiosisData The data specific to Symbiosis\n    function startBridgeTokensViaSymbiosis(\n        ILiFi.BridgeData memory _bridgeData,\n        SymbiosisData calldata _symbiosisData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _symbiosisData);\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before bridging via Symbiosis\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _symbiosisData The data specific to Symbiosis\n    function swapAndStartBridgeTokensViaSymbiosis(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        SymbiosisData calldata _symbiosisData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData, _symbiosisData);\n    }\n\n    /// @dev Contains the business logic for the bridge via Symbiosis\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _symbiosisData data specific to Symbiosis\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        SymbiosisData calldata _symbiosisData\n    ) internal {\n        bool isNative = LibAsset.isNativeAsset(_bridgeData.sendingAssetId);\n        uint256 nativeAssetAmount;\n\n        if (isNative) {\n            nativeAssetAmount = _bridgeData.minAmount;\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                symbiosisGateway,\n                _bridgeData.minAmount\n            );\n        }\n\n        symbiosisMetaRouter.metaRoute{ value: nativeAssetAmount }(\n            ISymbiosisMetaRouter.MetaRouteTransaction(\n                _symbiosisData.firstSwapCalldata,\n                _symbiosisData.secondSwapCalldata,\n                _symbiosisData.approvedTokens,\n                _symbiosisData.firstDexRouter,\n                _symbiosisData.secondDexRouter,\n                _bridgeData.minAmount,\n                isNative,\n                _symbiosisData.callTo,\n                _symbiosisData.callData\n            )\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/SynapseBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ISynapseRouter } from \"../Interfaces/ISynapseRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title SynapseBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through SynapseBridge\n/// @custom:version 1.0.0\ncontract SynapseBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    address internal constant NETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The contract address of the SynapseRouter on the source chain.\n    ISynapseRouter private immutable synapseRouter;\n\n    /// Types ///\n\n    /// @param originQuery Origin swap query. Empty struct indicates no swap is required.\n    /// @param destQuery Destination swap query. Empty struct indicates no swap is required.\n    struct SynapseData {\n        ISynapseRouter.SwapQuery originQuery;\n        ISynapseRouter.SwapQuery destQuery;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _synapseRouter The contract address of the SynapseRouter on the source chain.\n    constructor(ISynapseRouter _synapseRouter) {\n        synapseRouter = _synapseRouter;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Synapse Bridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _synapseData data specific to Synapse Bridge\n    function startBridgeTokensViaSynapseBridge(\n        ILiFi.BridgeData calldata _bridgeData,\n        SynapseData calldata _synapseData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _synapseData);\n    }\n\n    /// @notice Performs a swap before bridging via Synapse Bridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _synapseData data specific to Synapse Bridge\n    function swapAndStartBridgeTokensViaSynapseBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        SynapseData calldata _synapseData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData, _synapseData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Synapse Bridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _synapseData data specific to Synapse Bridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        SynapseData calldata _synapseData\n    ) internal {\n        uint256 nativeAssetAmount;\n        address sendingAssetId = _bridgeData.sendingAssetId;\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            nativeAssetAmount = _bridgeData.minAmount;\n            sendingAssetId = NETH_ADDRESS;\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(synapseRouter),\n                _bridgeData.minAmount\n            );\n        }\n\n        synapseRouter.bridge{ value: nativeAssetAmount }(\n            _bridgeData.receiver,\n            _bridgeData.destinationChainId,\n            sendingAssetId,\n            _bridgeData.minAmount,\n            _synapseData.originQuery,\n            _synapseData.destQuery\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/ThorSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IThorSwap } from \"../Interfaces/IThorSwap.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\n/// @title ThorSwap Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through ThorSwap\n/// @custom:version 1.0.0\ncontract ThorSwapFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    address private immutable thorchainRouter;\n\n    /// @notice The struct for the ThorSwap data.\n    /// @param vault The Thorchain vault address\n    /// @param memo The memo to send to Thorchain for the swap\n    /// @param expiration The expiration time for the swap\n    struct ThorSwapData {\n        address vault;\n        string memo;\n        uint256 expiration;\n    }\n\n    /// @notice Initializes the ThorSwap contract\n    constructor(address _thorchainRouter) {\n        thorchainRouter = _thorchainRouter;\n    }\n\n    /// @notice Bridge tokens to another chain via ThorSwap\n    /// @param _bridgeData The bridge data struct\n    /// @param _thorSwapData The ThorSwap data struct\n    function startBridgeTokensViaThorSwap(\n        ILiFi.BridgeData memory _bridgeData,\n        ThorSwapData calldata _thorSwapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _thorSwapData);\n    }\n\n    /// @notice Bridge tokens to another chain via ThorSwap\n    /// @param _bridgeData The bridge data struct\n    /// @param _swapData The swap data struct\n    /// @param _thorSwapData The ThorSwap data struct\n    function swapAndStartBridgeTokensViaThorSwap(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        ThorSwapData calldata _thorSwapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _thorSwapData);\n    }\n\n    /// @notice Bridge tokens to another chain via ThorSwap\n    /// @param _bridgeData The bridge data struct\n    /// @param _thorSwapData The thorSwap data struct for ThorSwap specicific data\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        ThorSwapData calldata _thorSwapData\n    ) internal {\n        IERC20 sendingAssetId = IERC20(_bridgeData.sendingAssetId);\n        bool isNative = LibAsset.isNativeAsset(address(sendingAssetId));\n\n        if (!isNative) {\n            LibAsset.maxApproveERC20(\n                sendingAssetId,\n                thorchainRouter,\n                _bridgeData.minAmount\n            );\n        }\n        IThorSwap(thorchainRouter).depositWithExpiry{\n            value: isNative ? _bridgeData.minAmount : 0\n        }(\n            _thorSwapData.vault,\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount,\n            _thorSwapData.memo,\n            _thorSwapData.expiration\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/WithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { NotAContract } from \"../Errors/GenericErrors.sol\";\n\n/// @title Withdraw Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Allows admin to withdraw funds that are kept in the contract by accident\n/// @custom:version 1.0.0\ncontract WithdrawFacet {\n    /// Errors ///\n\n    error WithdrawFailed();\n\n    /// Events ///\n\n    event LogWithdraw(\n        address indexed _assetAddress,\n        address _to,\n        uint256 amount\n    );\n\n    /// External Methods ///\n\n    /// @notice Execute call data and withdraw asset.\n    /// @param _callTo The address to execute the calldata on.\n    /// @param _callData The data to execute.\n    /// @param _assetAddress Asset to be withdrawn.\n    /// @param _to address to withdraw to.\n    /// @param _amount amount of asset to withdraw.\n    function executeCallAndWithdraw(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        // Check if the _callTo is a contract\n        bool success;\n        bool isContract = LibAsset.isContract(_callTo);\n        if (!isContract) revert NotAContract();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ) = _callTo.call(_callData);\n\n        if (success) {\n            _withdrawAsset(_assetAddress, _to, _amount);\n        } else {\n            revert WithdrawFailed();\n        }\n    }\n\n    /// @notice Withdraw asset.\n    /// @param _assetAddress Asset to be withdrawn.\n    /// @param _to address to withdraw to.\n    /// @param _amount amount of asset to withdraw.\n    function withdraw(\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        _withdrawAsset(_assetAddress, _to, _amount);\n    }\n\n    /// Internal Methods ///\n\n    /// @notice Withdraw asset.\n    /// @param _assetAddress Asset to be withdrawn.\n    /// @param _to address to withdraw to.\n    /// @param _amount amount of asset to withdraw.\n    function _withdrawAsset(\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) internal {\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit LogWithdraw(_assetAddress, sendTo, _amount);\n    }\n}\n"
    },
    "src/Facets/WormholeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IWormholeRouter } from \"../Interfaces/IWormholeRouter.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { UnsupportedChainId, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Wormhole Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Wormhole\n/// @custom:version 1.0.0\ncontract WormholeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.wormhole\");\n    address internal constant NON_EVM_ADDRESS =\n        0x11f111f111f111F111f111f111F111f111f111F1;\n\n    /// @notice The contract address of the wormhole router on the source chain.\n    IWormholeRouter private immutable router;\n\n    /// Types ///\n\n    struct Storage {\n        mapping(uint256 => uint16) wormholeChainId;\n        bool initialized;\n    }\n\n    struct Config {\n        uint256 chainId;\n        uint16 wormholeChainId;\n    }\n\n    /// @param receiver The address of the token receiver after bridging.\n    /// @param arbiterFee The amount of token to pay a relayer (can be zero if no relayer is used).\n    /// @param nonce A random nonce to associate with the tx.\n    struct WormholeData {\n        bytes32 receiver;\n        uint256 arbiterFee;\n        uint32 nonce;\n    }\n\n    /// Events ///\n\n    event WormholeInitialized(Config[] configs);\n    event WormholeChainIdMapped(\n        uint256 indexed lifiChainId,\n        uint256 indexed wormholeChainId\n    );\n    event WormholeChainIdsMapped(Config[] configs);\n    event BridgeToNonEVMChain(\n        bytes32 indexed transactionId,\n        uint256 indexed wormholeChainId,\n        bytes32 receiver\n    );\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _router The contract address of the wormhole router on the source chain.\n    constructor(IWormholeRouter _router) {\n        router = _router;\n    }\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Wormhole Facet\n    /// @param configs Bridge configuration data\n    function initWormhole(Config[] calldata configs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage sm = getStorage();\n\n        if (sm.initialized) {\n            revert AlreadyInitialized();\n        }\n\n        uint256 numConfigs = configs.length;\n        for (uint256 i = 0; i < numConfigs; i++) {\n            sm.wormholeChainId[configs[i].chainId] = configs[i]\n                .wormholeChainId;\n        }\n\n        sm.initialized = true;\n\n        emit WormholeInitialized(configs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Wormhole\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _wormholeData data specific to Wormhole\n    function startBridgeTokensViaWormhole(\n        ILiFi.BridgeData memory _bridgeData,\n        WormholeData calldata _wormholeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _wormholeData);\n    }\n\n    /// @notice Performs a swap before bridging via Wormhole\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _wormholeData data specific to Wormhole\n    function swapAndStartBridgeTokensViaWormhole(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        WormholeData calldata _wormholeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _wormholeData);\n    }\n\n    /// @notice Creates a mapping between a lifi chain id and a wormhole chain id\n    /// @param _lifiChainId lifi chain id\n    /// @param _wormholeChainId wormhole chain id\n    function setWormholeChainId(\n        uint256 _lifiChainId,\n        uint16 _wormholeChainId\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage sm = getStorage();\n        sm.wormholeChainId[_lifiChainId] = _wormholeChainId;\n        emit WormholeChainIdMapped(_lifiChainId, _wormholeChainId);\n    }\n\n    /// @notice Creates mappings between chain ids and wormhole chain ids\n    /// @param configs Bridge configuration data\n    function setWormholeChainIds(Config[] calldata configs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage sm = getStorage();\n\n        if (!sm.initialized) {\n            revert NotInitialized();\n        }\n\n        uint256 numConfigs = configs.length;\n        for (uint256 i = 0; i < numConfigs; i++) {\n            sm.wormholeChainId[configs[i].chainId] = configs[i]\n                .wormholeChainId;\n        }\n\n        emit WormholeChainIdsMapped(configs);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Wormhole\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _wormholeData data specific to Wormhole\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        WormholeData calldata _wormholeData\n    ) private {\n        uint16 toWormholeChainId = getWormholeChainId(\n            _bridgeData.destinationChainId\n        );\n        uint16 fromWormholeChainId = getWormholeChainId(block.chainid);\n\n        {\n            if (toWormholeChainId == 0)\n                revert UnsupportedChainId(_bridgeData.destinationChainId);\n            if (fromWormholeChainId == 0)\n                revert UnsupportedChainId(block.chainid);\n        }\n\n        LibAsset.maxApproveERC20(\n            IERC20(_bridgeData.sendingAssetId),\n            address(router),\n            _bridgeData.minAmount\n        );\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            router.wrapAndTransferETH{ value: _bridgeData.minAmount }(\n                toWormholeChainId,\n                _wormholeData.receiver,\n                _wormholeData.arbiterFee,\n                _wormholeData.nonce\n            );\n        } else {\n            router.transferTokens(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                toWormholeChainId,\n                _wormholeData.receiver,\n                _wormholeData.arbiterFee,\n                _wormholeData.nonce\n            );\n        }\n\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                toWormholeChainId,\n                _wormholeData.receiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Gets the wormhole chain id for a given lifi chain id\n    /// @param _lifiChainId uint256 of the lifi chain ID\n    /// @return uint16 of the wormhole chain id\n    function getWormholeChainId(\n        uint256 _lifiChainId\n    ) private view returns (uint16) {\n        Storage storage sm = getStorage();\n        uint16 wormholeChainId = sm.wormholeChainId[_lifiChainId];\n        if (wormholeChainId == 0) revert UnsupportedChainId(_lifiChainId);\n        return wormholeChainId;\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Helpers/CelerIMFacetBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ERC20 } from \"../../lib/solmate/src/tokens/ERC20.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { InvalidAmount, InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { MessageSenderLib, MsgDataTypes, IMessageBus } from \"../../lib/sgn-v2-contracts/contracts/message/libraries/MessageSenderLib.sol\";\nimport { RelayerCelerIM } from \"../../src/Periphery/RelayerCelerIM.sol\";\n\ninterface CelerToken {\n    function canonical() external returns (address);\n}\n\ninterface CelerIM {\n    /// @param maxSlippage The max slippage accepted, given as percentage in point (pip).\n    /// @param nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n    /// @param callTo The address of the contract to be called at destination.\n    /// @param callData The encoded calldata with below data\n    ///                 bytes32 transactionId,\n    ///                 LibSwap.SwapData[] memory swapData,\n    ///                 address receiver,\n    ///                 address refundAddress\n    /// @param messageBusFee The fee to be paid to CBridge message bus for relaying the message\n    /// @param bridgeType Defines the bridge operation type (must be one of the values of CBridge library MsgDataTypes.BridgeSendType)\n    struct CelerIMData {\n        uint32 maxSlippage;\n        uint64 nonce;\n        bytes callTo;\n        bytes callData;\n        uint256 messageBusFee;\n        MsgDataTypes.BridgeSendType bridgeType;\n    }\n}\n\n/// @title CelerIM Facet Base\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging tokens and data through CBridge\n/// @notice Used to differentiate between contract instances for mutable and immutable diamond as these cannot be shared\n/// @custom:version 2.0.0\nabstract contract CelerIMFacetBase is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @dev The contract address of the cBridge Message Bus\n    IMessageBus private immutable cBridgeMessageBus;\n\n    /// @dev The contract address of the RelayerCelerIM\n    RelayerCelerIM public immutable relayer;\n\n    /// @dev The contract address of the Celer Flow USDC\n    address private immutable cfUSDC;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _messageBus The contract address of the cBridge Message Bus\n    /// @param _relayerOwner The address that will become the owner of the RelayerCelerIM contract\n    /// @param _diamondAddress The address of the diamond contract that will be connected with the RelayerCelerIM\n    /// @param _cfUSDC The contract address of the Celer Flow USDC\n    constructor(\n        IMessageBus _messageBus,\n        address _relayerOwner,\n        address _diamondAddress,\n        address _cfUSDC\n    ) {\n        // deploy RelayerCelerIM\n        relayer = new RelayerCelerIM(\n            address(_messageBus),\n            _relayerOwner,\n            _diamondAddress\n        );\n\n        // store arguments in variables\n        cBridgeMessageBus = _messageBus;\n        cfUSDC = _cfUSDC;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _celerIMData Data specific to CelerIM\n    function startBridgeTokensViaCelerIM(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _celerIMData);\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Transfer ERC20 tokens directly to relayer\n            IERC20 asset = _getRightAsset(_bridgeData.sendingAssetId);\n\n            // Deposit ERC20 token\n            uint256 prevBalance = asset.balanceOf(address(relayer));\n            SafeERC20.safeTransferFrom(\n                asset,\n                msg.sender,\n                address(relayer),\n                _bridgeData.minAmount\n            );\n\n            if (\n                asset.balanceOf(address(relayer)) - prevBalance !=\n                _bridgeData.minAmount\n            ) {\n                revert InvalidAmount();\n            }\n        }\n\n        _startBridge(_bridgeData, _celerIMData);\n    }\n\n    /// @notice Performs a swap before bridging via CBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _celerIMData Data specific to CelerIM\n    function swapAndStartBridgeTokensViaCelerIM(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        CelerIM.CelerIMData calldata _celerIMData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _celerIMData);\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _celerIMData.messageBusFee\n        );\n\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Transfer ERC20 tokens directly to relayer\n            IERC20 asset = _getRightAsset(_bridgeData.sendingAssetId);\n\n            // Deposit ERC20 token\n            uint256 prevBalance = asset.balanceOf(address(relayer));\n            SafeERC20.safeTransfer(\n                asset,\n                address(relayer),\n                _bridgeData.minAmount\n            );\n\n            if (\n                asset.balanceOf(address(relayer)) - prevBalance !=\n                _bridgeData.minAmount\n            ) {\n                revert InvalidAmount();\n            }\n        }\n\n        _startBridge(_bridgeData, _celerIMData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _celerIMData Data specific to CBridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    ) private {\n        // Assuming messageBusFee is pre-calculated off-chain and available in _celerIMData\n        // Determine correct native asset amount to be forwarded (if so) and send funds to relayer\n        uint256 msgValue = LibAsset.isNativeAsset(_bridgeData.sendingAssetId)\n            ? _bridgeData.minAmount\n            : 0;\n\n        // Check if transaction contains a destination call\n        if (!_bridgeData.hasDestinationCall) {\n            // Case 'no': Simple bridge transfer - Send to receiver\n            relayer.sendTokenTransfer{ value: msgValue }(\n                _bridgeData,\n                _celerIMData\n            );\n        } else {\n            // Case 'yes': Bridge + Destination call - Send to relayer\n\n            // save address of original recipient\n            address receiver = _bridgeData.receiver;\n\n            // Set relayer as a receiver\n            _bridgeData.receiver = address(relayer);\n\n            // send token transfer\n            (bytes32 transferId, address bridgeAddress) = relayer\n                .sendTokenTransfer{ value: msgValue }(\n                _bridgeData,\n                _celerIMData\n            );\n\n            // Call message bus via relayer incl messageBusFee\n            relayer.forwardSendMessageWithTransfer{\n                value: _celerIMData.messageBusFee\n            }(\n                _bridgeData.receiver,\n                uint64(_bridgeData.destinationChainId),\n                bridgeAddress,\n                transferId,\n                _celerIMData.callData\n            );\n\n            // Reset receiver of bridge data for event emission\n            _bridgeData.receiver = receiver;\n        }\n\n        // emit LiFi event\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev Get right asset to transfer to relayer.\n    /// @param _sendingAssetId The address of asset to bridge.\n    /// @return _asset The address of asset to transfer to relayer.\n    function _getRightAsset(\n        address _sendingAssetId\n    ) private returns (IERC20 _asset) {\n        if (_sendingAssetId == cfUSDC) {\n            // special case for cfUSDC token\n            _asset = IERC20(CelerToken(_sendingAssetId).canonical());\n        } else {\n            // any other ERC20 token\n            _asset = IERC20(_sendingAssetId);\n        }\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    ) private pure {\n        if (\n            (_celerIMData.callData.length > 0) !=\n            _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n}\n"
    },
    "src/Helpers/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n// This contract has been taken from: https://github.com/nomad-xyz/ExcessivelySafeCall\npragma solidity 0.8.17;\n\nimport { InvalidCallData } from \"../Errors/GenericErrors.sol\";\n\n// solhint-disable no-inline-assembly\nlibrary ExcessivelySafeCall {\n    uint256 private constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(\n        bytes4 _newSelector,\n        bytes memory _buf\n    ) internal pure {\n        if (_buf.length < 4) {\n            revert InvalidCallData();\n        }\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "src/Helpers/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\n/// @title Reentrancy Guard\n/// @author LI.FI (https://li.fi)\n/// @notice Abstract contract to provide protection against reentrancy\nabstract contract ReentrancyGuard {\n    /// Storage ///\n\n    bytes32 private constant NAMESPACE = keccak256(\"com.lifi.reentrancyguard\");\n\n    /// Types ///\n\n    struct ReentrancyStorage {\n        uint256 status;\n    }\n\n    /// Errors ///\n\n    error ReentrancyError();\n\n    /// Constants ///\n\n    uint256 private constant _NOT_ENTERED = 0;\n    uint256 private constant _ENTERED = 1;\n\n    /// Modifiers ///\n\n    modifier nonReentrant() {\n        ReentrancyStorage storage s = reentrancyStorage();\n        if (s.status == _ENTERED) revert ReentrancyError();\n        s.status = _ENTERED;\n        _;\n        s.status = _NOT_ENTERED;\n    }\n\n    /// Private Methods ///\n\n    /// @dev fetch local storage\n    function reentrancyStorage()\n        private\n        pure\n        returns (ReentrancyStorage storage data)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data.slot := position\n        }\n    }\n}\n"
    },
    "src/Helpers/SwapperV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibAllowList } from \"../Libraries/LibAllowList.sol\";\nimport { ContractCallNotAllowed, NoSwapDataProvided, CumulativeSlippageTooHigh } from \"../Errors/GenericErrors.sol\";\n\n/// @title Swapper\n/// @author LI.FI (https://li.fi)\n/// @notice Abstract contract to provide swap functionality\ncontract SwapperV2 is ILiFi {\n    /// Types ///\n\n    /// @dev only used to get around \"Stack Too Deep\" errors\n    struct ReserveData {\n        bytes32 transactionId;\n        address payable leftoverReceiver;\n        uint256 nativeReserve;\n    }\n\n    /// Modifiers ///\n\n    /// @dev Sends any leftover balances back to the user\n    /// @notice Sends any leftover balances to the user\n    /// @param _swaps Swap data array\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial token balances\n    modifier noLeftovers(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance =\n                        LibAsset.getOwnBalance(curAsset) -\n                        _initialBalances[i];\n                    if (curBalance > 0) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// @dev Sends any leftover balances back to the user reserving native tokens\n    /// @notice Sends any leftover balances to the user\n    /// @param _swaps Swap data array\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial token balances\n    modifier noLeftoversReserve(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances,\n        uint256 _nativeReserve\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance =\n                        LibAsset.getOwnBalance(curAsset) -\n                        _initialBalances[i];\n                    uint256 reserve = LibAsset.isNativeAsset(curAsset)\n                        ? _nativeReserve\n                        : 0;\n                    if (curBalance > 0) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance - reserve\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// @dev Refunds any excess native asset sent to the contract after the main function\n    /// @notice Refunds any excess native asset sent to the contract after the main function\n    /// @param _refundReceiver Address to send refunds to\n    modifier refundExcessNative(address payable _refundReceiver) {\n        uint256 initialBalance = address(this).balance - msg.value;\n        _;\n        uint256 finalBalance = address(this).balance;\n\n        if (finalBalance > initialBalance) {\n            LibAsset.transferAsset(\n                LibAsset.NATIVE_ASSETID,\n                _refundReceiver,\n                finalBalance - initialBalance\n            );\n        }\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Deposits value, executes swaps, and performs minimum amount check\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver The address to send leftover funds to\n    /// @return uint256 result of the swap\n    function _depositAndSwap(\n        bytes32 _transactionId,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver\n    ) internal returns (uint256) {\n        uint256 numSwaps = _swaps.length;\n\n        if (numSwaps == 0) {\n            revert NoSwapDataProvided();\n        }\n\n        address finalTokenId = _swaps[numSwaps - 1].receivingAssetId;\n        uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId);\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            initialBalance -= msg.value;\n        }\n\n        uint256[] memory initialBalances = _fetchBalances(_swaps);\n\n        LibAsset.depositAssets(_swaps);\n        _executeSwaps(\n            _transactionId,\n            _swaps,\n            _leftoverReceiver,\n            initialBalances\n        );\n\n        uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance;\n\n        if (newBalance < _minAmount) {\n            revert CumulativeSlippageTooHigh(_minAmount, newBalance);\n        }\n\n        return newBalance;\n    }\n\n    /// @dev Deposits value, executes swaps, and performs minimum amount check and reserves native token for fees\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver The address to send leftover funds to\n    /// @param _nativeReserve Amount of native token to prevent from being swept back to the caller\n    function _depositAndSwap(\n        bytes32 _transactionId,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256 _nativeReserve\n    ) internal returns (uint256) {\n        uint256 numSwaps = _swaps.length;\n\n        if (numSwaps == 0) {\n            revert NoSwapDataProvided();\n        }\n\n        address finalTokenId = _swaps[numSwaps - 1].receivingAssetId;\n        uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId);\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            initialBalance -= msg.value;\n        }\n\n        uint256[] memory initialBalances = _fetchBalances(_swaps);\n\n        LibAsset.depositAssets(_swaps);\n        ReserveData memory rd = ReserveData(\n            _transactionId,\n            _leftoverReceiver,\n            _nativeReserve\n        );\n        _executeSwaps(rd, _swaps, initialBalances);\n\n        uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance;\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            newBalance -= _nativeReserve;\n        }\n\n        if (newBalance < _minAmount) {\n            revert CumulativeSlippageTooHigh(_minAmount, newBalance);\n        }\n\n        return newBalance;\n    }\n\n    /// Private Methods ///\n\n    /// @dev Executes swaps and checks that DEXs used are in the allowList\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial balances\n    function _executeSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances\n    ) internal noLeftovers(_swaps, _leftoverReceiver, _initialBalances) {\n        uint256 numSwaps = _swaps.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            LibSwap.SwapData calldata currentSwap = _swaps[i];\n\n            if (\n                !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) ||\n                    LibAllowList.contractIsAllowed(currentSwap.approveTo)) &&\n                    LibAllowList.contractIsAllowed(currentSwap.callTo) &&\n                    LibAllowList.selectorIsAllowed(\n                        bytes4(currentSwap.callData[:4])\n                    ))\n            ) revert ContractCallNotAllowed();\n\n            LibSwap.swap(_transactionId, currentSwap);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Executes swaps and checks that DEXs used are in the allowList\n    /// @param _reserveData Data passed used to reserve native tokens\n    /// @param _swaps Array of data used to execute swaps\n    function _executeSwaps(\n        ReserveData memory _reserveData,\n        LibSwap.SwapData[] calldata _swaps,\n        uint256[] memory _initialBalances\n    )\n        internal\n        noLeftoversReserve(\n            _swaps,\n            _reserveData.leftoverReceiver,\n            _initialBalances,\n            _reserveData.nativeReserve\n        )\n    {\n        uint256 numSwaps = _swaps.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            LibSwap.SwapData calldata currentSwap = _swaps[i];\n\n            if (\n                !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) ||\n                    LibAllowList.contractIsAllowed(currentSwap.approveTo)) &&\n                    LibAllowList.contractIsAllowed(currentSwap.callTo) &&\n                    LibAllowList.selectorIsAllowed(\n                        bytes4(currentSwap.callData[:4])\n                    ))\n            ) revert ContractCallNotAllowed();\n\n            LibSwap.swap(_reserveData.transactionId, currentSwap);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Fetches balances of tokens to be swapped before swapping.\n    /// @param _swaps Array of data used to execute swaps\n    /// @return uint256[] Array of token balances.\n    function _fetchBalances(\n        LibSwap.SwapData[] calldata _swaps\n    ) private view returns (uint256[] memory) {\n        uint256 numSwaps = _swaps.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swaps[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }\n}\n"
    },
    "src/Helpers/TransferrableOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC173 } from \"../Interfaces/IERC173.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\ncontract TransferrableOwnership is IERC173 {\n    address public owner;\n    address public pendingOwner;\n\n    /// Errors ///\n    error UnAuthorized();\n    error NoNullOwner();\n    error NewOwnerMustNotBeSelf();\n    error NoPendingOwnershipTransfer();\n    error NotPendingOwner();\n\n    /// Events ///\n    event OwnershipTransferRequested(\n        address indexed _from,\n        address indexed _to\n    );\n\n    constructor(address initialOwner) {\n        owner = initialOwner;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert UnAuthorized();\n        _;\n    }\n\n    /// @notice Initiates transfer of ownership to a new address\n    /// @param _newOwner the address to transfer ownership to\n    function transferOwnership(address _newOwner) external onlyOwner {\n        if (_newOwner == LibAsset.NULL_ADDRESS) revert NoNullOwner();\n        if (_newOwner == msg.sender) revert NewOwnerMustNotBeSelf();\n        pendingOwner = _newOwner;\n        emit OwnershipTransferRequested(msg.sender, pendingOwner);\n    }\n\n    /// @notice Cancel transfer of ownership\n    function cancelOwnershipTransfer() external onlyOwner {\n        if (pendingOwner == LibAsset.NULL_ADDRESS)\n            revert NoPendingOwnershipTransfer();\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }\n\n    /// @notice Confirms transfer of ownership to the calling address (msg.sender)\n    function confirmOwnershipTransfer() external {\n        address _pendingOwner = pendingOwner;\n        if (msg.sender != _pendingOwner) revert NotPendingOwner();\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }\n}\n"
    },
    "src/Helpers/Validatable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { InvalidReceiver, InformationMismatch, InvalidSendingToken, InvalidAmount, NativeAssetNotSupported, InvalidDestinationChain, CannotBridgeToSameNetwork } from \"../Errors/GenericErrors.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\ncontract Validatable {\n    modifier validateBridgeData(ILiFi.BridgeData memory _bridgeData) {\n        if (LibUtil.isZeroAddress(_bridgeData.receiver)) {\n            revert InvalidReceiver();\n        }\n        if (_bridgeData.minAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (_bridgeData.destinationChainId == block.chainid) {\n            revert CannotBridgeToSameNetwork();\n        }\n        _;\n    }\n\n    modifier noNativeAsset(ILiFi.BridgeData memory _bridgeData) {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            revert NativeAssetNotSupported();\n        }\n        _;\n    }\n\n    modifier onlyAllowSourceToken(\n        ILiFi.BridgeData memory _bridgeData,\n        address _token\n    ) {\n        if (_bridgeData.sendingAssetId != _token) {\n            revert InvalidSendingToken();\n        }\n        _;\n    }\n\n    modifier onlyAllowDestinationChain(\n        ILiFi.BridgeData memory _bridgeData,\n        uint256 _chainId\n    ) {\n        if (_bridgeData.destinationChainId != _chainId) {\n            revert InvalidDestinationChain();\n        }\n        _;\n    }\n\n    modifier containsSourceSwaps(ILiFi.BridgeData memory _bridgeData) {\n        if (!_bridgeData.hasSourceSwaps) {\n            revert InformationMismatch();\n        }\n        _;\n    }\n\n    modifier doesNotContainSourceSwaps(ILiFi.BridgeData memory _bridgeData) {\n        if (_bridgeData.hasSourceSwaps) {\n            revert InformationMismatch();\n        }\n        _;\n    }\n\n    modifier doesNotContainDestinationCalls(\n        ILiFi.BridgeData memory _bridgeData\n    ) {\n        if (_bridgeData.hasDestinationCall) {\n            revert InformationMismatch();\n        }\n        _;\n    }\n}\n"
    },
    "src/Interfaces/IAcrossSpokePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IAcrossSpokePool {\n    function deposit(\n        address recipient, // Recipient address\n        address originToken, // Address of the token\n        uint256 amount, // Token amount\n        uint256 destinationChainId, // ⛓ id\n        int64 relayerFeePct, // see #Fees Calculation\n        uint32 quoteTimestamp, // Timestamp for the quote creation\n        bytes memory message, // Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n        uint256 maxCount // Used to protect the depositor from frontrunning to guarantee their quote remains valid.\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IAllBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @title AllBridge Interface\ninterface IAllBridge {\n    /// @dev AllBridge Messenger Protocol Enum\n    enum MessengerProtocol {\n        None,\n        Allbridge,\n        Wormhole,\n        LayerZero\n    }\n\n    function pools(bytes32 addr) external returns (address);\n\n    function swapAndBridge(\n        bytes32 token,\n        uint256 amount,\n        bytes32 recipient,\n        uint256 destinationChainId,\n        bytes32 receiveToken,\n        uint256 nonce,\n        MessengerProtocol messenger,\n        uint256 feeTokenAmount\n    ) external payable;\n\n    function getTransactionCost(\n        uint256 chainId\n    ) external view returns (uint256);\n\n    function getMessageCost(\n        uint256 chainId,\n        MessengerProtocol protocol\n    ) external view returns (uint256);\n\n    function getBridgingCostInTokens(\n        uint256 destinationChainId,\n        MessengerProtocol messenger,\n        address tokenAddress\n    ) external view returns (uint256);\n}\n"
    },
    "src/Interfaces/ICBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ICBridge {\n    /// @notice Send a cross-chain transfer via the liquidity pool-based bridge.\n    /// @dev This function DOES NOT SUPPORT fee-on-transfer / rebasing tokens.\n    /// @param _receiver The address of the receiver.\n    /// @param _token The address of the token.\n    /// @param _amount The amount of the transfer.\n    /// @param _dstChainId The destination chain ID.\n    /// @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n    /// @param _maxSlippage The max slippage accepted, given as percentage in point (pip).\n    ///                     Eg. 5000 means 0.5%. Must be greater than minimalMaxSlippage.\n    ///                     Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount\n    ///                     or the transfer can be refunded.\n    function send(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    /// @notice Send a cross-chain transfer via the liquidity pool-based bridge using the native token.\n    /// @param _receiver The address of the receiver.\n    /// @param _amount The amount of the transfer.\n    /// @param _dstChainId The destination chain ID.\n    /// @param _nonce A unique number. Can be timestamp in practice.\n    /// @param _maxSlippage The max slippage accepted, given as percentage in point (pip).\n    ///                     Eg. 5000 means 0.5%. Must be greater than minimalMaxSlippage.\n    ///                     Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount\n    ///                     or the transfer can be refunded.\n    function sendNative(\n        address _receiver,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external payable;\n}\n"
    },
    "src/Interfaces/ICircleBridgeProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ICircleBridgeProxy {\n    /// @notice Deposits and burns tokens from sender to be minted on destination domain.\n    /// @dev reverts if:\n    ///      - given burnToken is not supported.\n    ///      - given destinationDomain has no TokenMessenger registered.\n    ///      - transferFrom() reverts. For example, if sender's burnToken balance\n    ///        or approved allowance to this contract is less than `amount`.\n    ///      - burn() reverts. For example, if `amount` is 0.\n    ///      - MessageTransmitter returns false or reverts.\n    /// @param _amount Amount of tokens to burn.\n    /// @param _dstChid Destination domain.\n    /// @param _mintRecipient Address of mint recipient on destination domain.\n    /// @param _burnToken Address of contract to burn deposited tokens, on local domain.\n    /// @return nonce Unique nonce reserved by message.\n    function depositForBurn(\n        uint256 _amount,\n        uint64 _dstChid,\n        bytes32 _mintRecipient,\n        address _burnToken\n    ) external returns (uint64 nonce);\n}\n"
    },
    "src/Interfaces/IConnextHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IConnextHandler {\n    /// @notice These are the call parameters that will remain constant between the\n    /// two chains. They are supplied on `xcall` and should be asserted on `execute`\n    /// @property to - The account that receives funds, in the event of a crosschain call,\n    /// will receive funds if the call fails.\n    /// @param to - The address you are sending funds (and potentially data) to\n    /// @param callData - The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\n    /// @param originDomain - The originating domain (i.e. where `xcall` is called). Must match nomad domain schema\n    /// @param destinationDomain - The final domain (i.e. where `execute` / `reconcile` are called). Must match nomad domain schema\n    /// @param agent - An address who can execute txs on behalf of `to`, in addition to allowing relayers\n    /// @param recovery - The address to send funds to if your `Executor.execute call` fails\n    /// @param forceSlow - If true, will take slow liquidity path even if it is not a permissioned call\n    /// @param receiveLocal - If true, will use the local nomad asset on the destination instead of adopted.\n    /// @param callback - The address on the origin domain of the callback contract\n    /// @param callbackFee - The relayer fee to execute the callback\n    /// @param relayerFee - The amount of relayer fee the tx called xcall with\n    /// @param slippageTol - Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n    struct CallParams {\n        address to;\n        bytes callData;\n        uint32 originDomain;\n        uint32 destinationDomain;\n        address agent;\n        address recovery;\n        bool forceSlow;\n        bool receiveLocal;\n        address callback;\n        uint256 callbackFee;\n        uint256 relayerFee;\n        uint256 slippageTol;\n    }\n\n    /// @notice The arguments you supply to the `xcall` function called by user on origin domain\n    /// @param params - The CallParams. These are consistent across sending and receiving chains\n    /// @param transactingAsset - The asset the caller sent with the transfer. Can be the adopted, canonical,\n    /// or the representational asset\n    /// @param transactingAmount - The amount of transferring asset supplied by the user in the `xcall`\n    /// @param originMinOut - Minimum amount received on swaps for adopted <> local on origin chain\n    struct XCallArgs {\n        CallParams params;\n        address transactingAsset; // Could be adopted, local, or wrapped\n        uint256 transactingAmount;\n        uint256 originMinOut;\n    }\n\n    function xcall(\n        uint32 destination,\n        address recipient,\n        address tokenAddress,\n        address delegate,\n        uint256 amount,\n        uint256 slippage,\n        bytes memory callData\n    ) external payable returns (bytes32);\n\n    function xcall(\n        uint32 destination,\n        address recipient,\n        address tokenAddress,\n        address delegate,\n        uint256 amount,\n        uint256 slippage,\n        bytes memory callData,\n        uint256 _relayerFee\n    ) external returns (bytes32);\n}\n"
    },
    "src/Interfaces/IDeBridgeGate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IDeBridgeGate {\n    /// @param fixedNativeFee Transfer fixed fee.\n    /// @param isSupported Whether the chain for the asset is supported.\n    /// @param transferFeeBps Transfer fee rate nominated in basis points (1/10000)\n    ///                       of transferred amount.\n    struct ChainSupportInfo {\n        uint256 fixedNativeFee;\n        bool isSupported;\n        uint16 transferFeeBps;\n    }\n\n    /// @dev Fallback fixed fee in native asset, used if a chain fixed fee is set to 0\n    function globalFixedNativeFee() external view returns (uint256);\n\n    /// @dev Whether the chain for the asset is supported to send\n    function getChainToConfig(\n        uint256\n    ) external view returns (ChainSupportInfo memory);\n\n    /// @dev This method is used for the transfer of assets.\n    ///      It locks an asset in the smart contract in the native chain\n    ///      and enables minting of deAsset on the secondary chain.\n    /// @param _tokenAddress Asset identifier.\n    /// @param _amount Amount to be transferred (note: the fee can be applied).\n    /// @param _chainIdTo Chain id of the target chain.\n    /// @param _receiver Receiver address.\n    /// @param _permit deadline + signature for approving the spender by signature.\n    /// @param _useAssetFee use assets fee for pay protocol fix (work only for specials token)\n    /// @param _referralCode Referral code\n    /// @param _autoParams Auto params for external call in target network\n    function send(\n        address _tokenAddress,\n        uint256 _amount,\n        uint256 _chainIdTo,\n        bytes memory _receiver,\n        bytes memory _permit,\n        bool _useAssetFee,\n        uint32 _referralCode,\n        bytes calldata _autoParams\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "src/Interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view returns (address facetAddress_);\n}\n"
    },
    "src/Interfaces/IDlnSource.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IDlnSource {\n    struct OrderCreation {\n        // the address of the ERC-20 token you are giving;\n        // use the zero address to indicate you are giving a native blockchain token (ether, matic, etc).\n        address giveTokenAddress;\n        // the amount of tokens you are giving\n        uint256 giveAmount;\n        // the address of the ERC-20 token you are willing to take on the destination chain\n        bytes takeTokenAddress;\n        // the amount of tokens you are willing to take on the destination chain\n        uint256 takeAmount;\n        // the ID of the chain where an order should be fulfilled.\n        // Use the list of supported chains mentioned above\n        uint256 takeChainId;\n        // the address on the destination chain where the funds\n        // should be sent to upon order fulfillment\n        bytes receiverDst;\n        // the address on the source (current) chain who is allowed to patch the order\n        // giving more input tokens and thus making the order more attractive to takers, just in case\n        address givePatchAuthoritySrc;\n        // the address on the destination chain who is allowed to patch the order\n        // decreasing the take amount and thus making the order more attractive to takers, just in case\n        bytes orderAuthorityAddressDst;\n        // an optional address restricting anyone in the open market from fulfilling\n        // this order but the given address. This can be useful if you are creating a order\n        //  for a specific taker. By default, set to empty bytes array (0x)\n        bytes allowedTakerDst; // *optional\n        // set to an empty bytes array (0x)\n        bytes externalCall; // N/A, *optional\n        // an optional address on the source (current) chain where the given input tokens\n        // would be transferred to in case order cancellation is initiated by the orderAuthorityAddressDst\n        // on the destination chain. This property can be safely set to an empty bytes array (0x):\n        // in this case, tokens would be transferred to the arbitrary address specified\n        // by the orderAuthorityAddressDst upon order cancellation\n        bytes allowedCancelBeneficiarySrc; // *optional\n    }\n\n    function globalFixedNativeFee() external returns (uint256);\n\n    function createOrder(\n        OrderCreation calldata _orderCreation,\n        bytes calldata _affiliateFee,\n        uint32 _referralCode,\n        bytes calldata _permitEnvelope\n    ) external payable returns (bytes32 orderId);\n}\n"
    },
    "src/Interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external view returns (bool);\n}\n"
    },
    "src/Interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "src/Interfaces/IERC20Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC20Proxy {\n    function transferFrom(\n        address tokenAddress,\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n}\n"
    },
    "src/Interfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\n/// @title Interface for Executor\n/// @author LI.FI (https://li.fi)\ninterface IExecutor {\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param transferredAssetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address transferredAssetId,\n        address payable receiver\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IGatewayRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\ninterface IGatewayRouter {\n    /// @notice Transfer non-native assets\n    /// @param _token L1 address of ERC20\n    /// @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract)\n    /// @param _amount Token Amount\n    /// @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n    /// @param _gasPriceBid Gas price for L2 execution\n    /// @param _data Encoded data from router and user\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    /// @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress). createRetryableTicket method is the recommended standard.\n    /// @param _destAddr destination L2 contract address\n    /// @param _l2CallValue call value for retryable L2 message\n    /// @param _maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n    /// @param _excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\n    /// @param _callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n    /// @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n    /// @param _gasPriceBid price bid for L2 execution\n    /// @param _data ABI encoded data of L2 message\n    /// @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n    function unsafeCreateRetryableTicket(\n        address _destAddr,\n        uint256 _l2CallValue,\n        uint256 _maxSubmissionCost,\n        address _excessFeeRefundAddress,\n        address _callValueRefundAddress,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (uint256);\n\n    /// @notice Returns receiving token address on L2\n    /// @param _token Sending token address on L1\n    /// @return Receiving token address on L2\n    function calculateL2TokenAddress(\n        address _token\n    ) external view returns (address);\n\n    /// @notice Returns exact gateway router address for token\n    /// @param _token Sending token address on L1\n    /// @return Gateway router address for sending token\n    function getGateway(address _token) external view returns (address);\n}\n"
    },
    "src/Interfaces/IHopBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IHopBridge {\n    function sendToL2(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 amountOutMin,\n        uint256 deadline,\n        address relayer,\n        uint256 relayerFee\n    ) external payable;\n\n    function swapAndSend(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline\n    ) external payable;\n\n    function send(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline\n    ) external;\n}\n\ninterface IL2AmmWrapper {\n    function bridge() external view returns (address);\n\n    function l2CanonicalToken() external view returns (address);\n\n    function hToken() external view returns (address);\n\n    function exchangeAddress() external view returns (address);\n}\n\ninterface ISwap {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n}\n"
    },
    "src/Interfaces/IHyphenRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// https://github.com/bcnmy/hyphen-contract/blob/master/contracts/hyphen/LiquidityPool.sol\ninterface IHyphenRouter {\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string calldata tag\n    ) external;\n\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string calldata tag\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\ninterface IL1StandardBridge {\n    /// @notice Deposit an amount of ETH to a recipient's balance on L2.\n    /// @param _to L2 address to credit the withdrawal to.\n    /// @param _l2Gas Gas limit required to complete the deposit on L2.\n    /// @param _data Optional data to forward to L2. This data is provided\n    ///        solely as a convenience for external contracts. Aside from enforcing a maximum\n    ///        length, these contracts provide no guarantees about its content.\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /// @notice Deposit an amount of the ERC20 to the caller's balance on L2.\n    /// @param _l1Token Address of the L1 ERC20 we are depositing\n    /// @param _l2Token Address of the L1 respective L2 ERC20\n    /// @param _to L2 address to credit the withdrawal to.\n    /// @param _amount Amount of the ERC20 to deposit\n    /// @param _l2Gas Gas limit required to complete the deposit on L2.\n    /// @param _data Optional data to forward to L2. This data is provided\n    ///        solely as a convenience for external contracts. Aside from enforcing a maximum\n    ///        length, these contracts provide no guarantees about its content.\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /// @notice Deposit an amount of the ERC20 to the caller's balance on L2.\n    /// @dev This function is implemented on SynthetixBridgeToOptimism contract.\n    /// @param _to L2 address to credit the withdrawal to.\n    /// @param _amount Amount of the ERC20 to deposit\n    function depositTo(address _to, uint256 _amount) external;\n}\n"
    },
    "src/Interfaces/ILiFi.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ILiFi {\n    /// Structs ///\n\n    struct BridgeData {\n        bytes32 transactionId;\n        string bridge;\n        string integrator;\n        address referrer;\n        address sendingAssetId;\n        address receiver;\n        uint256 minAmount;\n        uint256 destinationChainId;\n        bool hasSourceSwaps;\n        bool hasDestinationCall;\n    }\n\n    /// Events ///\n\n    event LiFiTransferStarted(ILiFi.BridgeData bridgeData);\n\n    event LiFiTransferCompleted(\n        bytes32 indexed transactionId,\n        address receivingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event LiFiTransferRecovered(\n        bytes32 indexed transactionId,\n        address receivingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event LiFiGenericSwapCompleted(\n        bytes32 indexed transactionId,\n        string integrator,\n        string referrer,\n        address receiver,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount\n    );\n\n    // Deprecated but kept here to include in ABI to parse historic events\n    event LiFiSwappedGeneric(\n        bytes32 indexed transactionId,\n        string integrator,\n        string referrer,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount\n    );\n}\n"
    },
    "src/Interfaces/IMultichainRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IMultichainRouter {\n    function anySwapOutUnderlying(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 toChainID\n    ) external;\n\n    function anySwapOut(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 toChainID\n    ) external;\n\n    function anySwapOutNative(\n        address token,\n        address to,\n        uint256 toChainID\n    ) external payable;\n\n    function wNATIVE() external returns (address);\n}\n"
    },
    "src/Interfaces/IMultichainToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IMultichainToken {\n    function underlying() external returns (address);\n}\n"
    },
    "src/Interfaces/IOmniBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IOmniBridge {\n    /// @dev Initiate the bridge operation for some amount of tokens from msg.sender.\n    /// @param token bridged token contract address.\n    /// @param receiver Receiver address\n    /// @param amount Dai amount\n    function relayTokens(\n        address token,\n        address receiver,\n        uint256 amount\n    ) external;\n\n    /// @dev Wraps native assets and relays wrapped ERC20 tokens to the other chain.\n    /// @param receiver Bridged assets receiver on the other side of the bridge.\n    function wrapAndRelayTokens(address receiver) external payable;\n}\n"
    },
    "src/Interfaces/IRootChainManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\ninterface IRootChainManager {\n    /// @notice Move ether from root to child chain, accepts ether transfer\n    /// @dev Keep in mind this ether cannot be used to pay gas on child chain\n    ///      Use Matic tokens deposited using plasma mechanism for that\n    /// @param user address of account that should receive WETH on child chain\n    function depositEtherFor(address user) external payable;\n\n    /// @notice Move tokens from root to child chain\n    /// @dev This mechanism supports arbitrary tokens as long as\n    ///      its predicate has been registered and the token is mapped\n    /// @param user address of account that should receive this deposit on child chain\n    /// @param rootToken address of token that is being deposited\n    /// @param depositData bytes data that is sent to predicate and\n    ///        child token contracts to handle deposit\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external;\n\n    /// @notice Returns child token address for root token\n    /// @param rootToken Root token address\n    /// @return childToken Child token address\n    function rootToChildToken(\n        address rootToken\n    ) external view returns (address childToken);\n}\n"
    },
    "src/Interfaces/IStargateRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\n// solhint-disable contract-name-camelcase\ninterface IStargateRouter {\n    struct lzTxObj {\n        uint256 dstGasForCall;\n        uint256 dstNativeAmount;\n        bytes dstNativeAddr;\n    }\n\n    /// @notice SwapAmount struct\n    /// @param amountLD The amount, in Local Decimals, to be swapped\n    /// @param minAmountLD The minimum amount accepted out on destination\n    struct SwapAmount {\n        uint256 amountLD;\n        uint256 minAmountLD;\n    }\n\n    /// @notice Returns factory address used for creating pools.\n    function factory() external view returns (address);\n\n    /// @notice Swap assets cross-chain.\n    /// @dev Pass (0, 0, \"0x\") to lzTxParams\n    ///      for 0 additional gasLimit increase, 0 airdrop, at 0x address.\n    /// @param dstChainId Destination chainId\n    /// @param srcPoolId Source pool id\n    /// @param dstPoolId Dest pool id\n    /// @param refundAddress Refund adddress. extra gas (if any) is returned to this address\n    /// @param amountLD Quantity to swap\n    /// @param minAmountLD The min qty you would accept on the destination\n    /// @param lzTxParams Additional gas, airdrop data\n    /// @param to The address to send the tokens to on the destination\n    /// @param payload Additional payload. You can abi.encode() them here\n    function swap(\n        uint16 dstChainId,\n        uint256 srcPoolId,\n        uint256 dstPoolId,\n        address payable refundAddress,\n        uint256 amountLD,\n        uint256 minAmountLD,\n        lzTxObj memory lzTxParams,\n        bytes calldata to,\n        bytes calldata payload\n    ) external payable;\n\n    /// @notice Swap native assets cross-chain.\n    /// @param _dstChainId Destination Stargate chainId\n    /// @param _refundAddress Refunds additional messageFee to this address\n    /// @param _toAddress The receiver of the destination ETH\n    /// @param _swapAmount The amount and the minimum swap amount\n    /// @param _lzTxParams The LZ tx params\n    /// @param _payload The payload to send to the destination\n    function swapETHAndCall(\n        uint16 _dstChainId,\n        address payable _refundAddress,\n        bytes calldata _toAddress,\n        SwapAmount memory _swapAmount,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes calldata _payload\n    ) external payable;\n\n    /// @notice Returns the native gas fee required for swap.\n    function quoteLayerZeroFee(\n        uint16 dstChainId,\n        uint8 functionType,\n        bytes calldata toAddress,\n        bytes calldata transferAndCallPayload,\n        lzTxObj memory lzTxParams\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n}\n"
    },
    "src/Interfaces/ISymbiosisMetaRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISymbiosisMetaRouter {\n    /// @notice entry point data to Symbiosis contracts\n    /// @param firstSwapCalldata calldata for the dex swap to get corresponding asset (USDC) on init chain\n    /// @param secondSwapCalldata legacy calldata from v1, should be empty\n    /// @param approvedTokens set of token for firstSwapCalldata, and o bridgingCalldata\n    /// @param firstDexRouter entry point for firstSwapCalldata\n    /// @param secondDexRouter legacy entry point from v1, should be empty\n    /// @param amount of tokens\n    /// @param nativeIn native token in amount or not\n    /// @param relayRecipient entry point to bridge provided from API\n    /// @param otherSideCalldata bridging calldata\n    struct MetaRouteTransaction {\n        bytes firstSwapCalldata;\n        bytes secondSwapCalldata;\n        address[] approvedTokens;\n        address firstDexRouter;\n        address secondDexRouter;\n        uint256 amount;\n        bool nativeIn;\n        address relayRecipient;\n        bytes otherSideCalldata;\n    }\n\n    /**\n     * @notice Method that starts the Meta Routing in Symbiosis\n     * @param _metarouteTransaction metaRoute offchain transaction data\n     */\n    function metaRoute(\n        MetaRouteTransaction calldata _metarouteTransaction\n    ) external payable;\n}\n"
    },
    "src/Interfaces/ISynapseRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISynapseRouter {\n    /// @notice Struct representing a request for SynapseRouter.\n    /// @dev tokenIn is supplied separately.\n    /// @param swapAdapter Adapter address that will perform the swap.\n    ///                    Address(0) specifies a \"no swap\" query.\n    /// @param tokenOut Token address to swap to.\n    /// @param minAmountOut Minimum amount of tokens to receive after the swap,\n    ///                     or tx will be reverted.\n    /// @param deadline Latest timestamp for when the transaction needs to be executed,\n    ///                 or tx will be reverted.\n    /// @param rawParams ABI-encoded params for the swap that will be passed to `swapAdapter`.\n    ///                  Should be SynapseParams for swaps via SynapseAdapter.\n    struct SwapQuery {\n        address swapAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    /// @notice Struct representing a request for a swap quote from a bridge token.\n    /// @dev tokenOut is passed externally.\n    /// @param symbol Bridge token symbol: unique token ID consistent among all chains.\n    /// @param amountIn Amount of bridge token to start with, before the bridge fee is applied.\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n    /// @notice Struct representing a bridge token.\n    ///         Used as the return value in view functions.\n    /// @param symbol Bridge token symbol: unique token ID consistent among all chains.\n    /// @param token Bridge token address.\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n    /// @notice Initiate a bridge transaction with an optional swap on both origin\n    ///         and destination chains.\n    /// @dev Note This method is payable.\n    ///      If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    ///      If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    ///      Make sure to approve this contract for spending `token` beforehand.\n    ///      originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    ///      `token` is always a token user is sending.\n    ///      In case token requires a wrapper token to be bridge,\n    ///      use underlying address for `token` instead of the wrapper one.\n    ///\n    ///      `originQuery` contains instructions for the swap on origin chain.\n    ///      As above, originQuery.tokenOut should always use the underlying address.\n    ///      In other words, the concept of wrapper token is fully abstracted away from the end user.\n    ///\n    ///      `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    ///      Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    ///      `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    ///      Complex swaps on destination chain are not supported for the time being.\n    ///      Check contract description above for more details.\n    /// @param to Address to receive tokens on destination chain.\n    /// @param chainId Destination chain id.\n    /// @param token Initial token for the bridge transaction to be pulled from the user.\n    /// @param amount Amount of the initial tokens for the bridge transaction.\n    /// @param originQuery Origin swap query. Empty struct indicates no swap is required.\n    /// @param destQuery Destination swap query. Empty struct indicates no swap is required.\n    function bridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token\n    ///         from the given list, treating the swap as \"origin swap\",\n    ///         without putting any restrictions on the swap.\n    /// @dev Will NOT revert if any of the tokens are not supported,\n    ///      instead will return an empty query for that symbol.\n    ///      Check (query.minAmountOut != 0): this is true only if the swap is possible\n    ///      and bridge token is supported.\n    ///      The returned queries with minAmountOut != 0 could be used as `originQuery`\n    ///      with SynapseRouter.\n    /// Note: It is possible to form a SwapQuery off-chain using alternative SwapAdapter\n    ///       for the origin swap.\n    /// @param tokenIn Initial token that user wants to bridge/swap.\n    /// @param tokenSymbols List of symbols representing bridge tokens.\n    /// @param amountIn Amount of tokens user wants to bridge/swap.\n    /// @return originQueries List of structs that could be used as `originQuery` in SynapseRouter.\n    ///                       minAmountOut and deadline fields will need to be adjusted\n    ///                       based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string[] memory tokenSymbols,\n        uint256 amountIn\n    ) external view returns (SwapQuery[] memory originQueries);\n\n    /// @notice Finds the best path between every supported bridge token from\n    ///         the given list and `tokenOut`, treating the swap as \"destination swap\",\n    ///         limiting possible actions to those available for every bridge token.\n    /// @dev Will NOT revert if any of the tokens are not supported,\n    ///      instead will return an empty query for that symbol.\n    /// Note: It is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter\n    ///       for the destination swap.\n    ///       For the time being, only swaps through the Synapse-supported pools\n    ///       are available on destination chain.\n    /// @param requests List of structs with following information:\n    ///                 - symbol: unique token ID consistent among all chains.\n    ///                 - amountIn: amount of bridge token to start with,\n    ///                              before the bridge fee is applied.\n    /// @param tokenOut Token user wants to receive on destination chain.\n    /// @return destQueries List of structs that could be used as `destQuery` in SynapseRouter.\n    ///                     minAmountOut and deadline fields will need to be adjusted based\n    ///                     on the user settings.\n    function getDestinationAmountOut(\n        DestRequest[] memory requests,\n        address tokenOut\n    ) external view returns (SwapQuery[] memory destQueries);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols),\n    ///         such that destination swap from a bridge token to `tokenOut` is possible.\n    /// @param tokenOut Token address to swap to on destination chain\n    /// @return tokens List of structs with following information:\n    ///                - symbol: unique token ID consistent among all chains\n    ///                - token: bridge token address\n    function getConnectedBridgeTokens(\n        address tokenOut\n    ) external view returns (BridgeToken[] memory tokens);\n}\n"
    },
    "src/Interfaces/ITeleportGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITeleportGateway {\n    /// @notice Initiate DAI transfer.\n    /// @param targetDomain Domain of destination chain.\n    /// @param receiver Receiver address.\n    /// @param amount The amount of DAI to transfer.\n    function initiateTeleport(\n        bytes32 targetDomain,\n        address receiver,\n        uint128 amount\n    ) external;\n}\n"
    },
    "src/Interfaces/IThorSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @title ThorSwap Interface\ninterface IThorSwap {\n    // Thorchain router\n    function depositWithExpiry(\n        address vault,\n        address asset,\n        uint256 amount,\n        string calldata memo,\n        uint256 expiration\n    ) external payable;\n}\n"
    },
    "src/Interfaces/ITokenMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITokenMessenger {\n    /// @notice Deposits and burns tokens from sender to be minted on destination domain.\n    /// @dev reverts if:\n    ///      - given burnToken is not supported.\n    ///      - given destinationDomain has no TokenMessenger registered.\n    ///      - transferFrom() reverts. For example, if sender's burnToken balance\n    ///        or approved allowance to this contract is less than `amount`.\n    ///      - burn() reverts. For example, if `amount` is 0.\n    ///      - MessageTransmitter returns false or reverts.\n    /// @param amount Amount of tokens to burn.\n    /// @param destinationDomain Destination domain.\n    /// @param mintRecipient Address of mint recipient on destination domain.\n    /// @param burnToken Address of contract to burn deposited tokens, on local domain.\n    /// @return nonce Unique nonce reserved by message.\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken\n    ) external returns (uint64 nonce);\n}\n"
    },
    "src/Interfaces/ITransactionManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface ITransactionManager {\n    // Structs\n\n    // Holds all data that is constant between sending and\n    // receiving chains. The hash of this is what gets signed\n    // to ensure the signature can be used on both chains.\n    struct InvariantTransactionData {\n        address receivingChainTxManagerAddress;\n        address user;\n        address router;\n        address initiator; // msg.sender of sending side\n        address sendingAssetId;\n        address receivingAssetId;\n        address sendingChainFallback; // funds sent here on cancel\n        address receivingAddress;\n        address callTo;\n        uint256 sendingChainId;\n        uint256 receivingChainId;\n        bytes32 callDataHash; // hashed to prevent free option\n        bytes32 transactionId;\n    }\n\n    // All Transaction data, constant and variable\n    struct TransactionData {\n        address receivingChainTxManagerAddress;\n        address user;\n        address router;\n        address initiator; // msg.sender of sending side\n        address sendingAssetId;\n        address receivingAssetId;\n        address sendingChainFallback;\n        address receivingAddress;\n        address callTo;\n        bytes32 callDataHash;\n        bytes32 transactionId;\n        uint256 sendingChainId;\n        uint256 receivingChainId;\n        uint256 amount;\n        uint256 expiry;\n        uint256 preparedBlockNumber; // Needed for removal of active blocks on fulfill/cancel\n    }\n\n    /**\n     * Arguments for calling prepare()\n     * @param invariantData The data for a crosschain transaction that will\n     *                      not change between sending and receiving chains.\n     *                      The hash of this data is used as the key to store\n     *                      the inforamtion that does change between chains\n     *                      (amount,expiry,preparedBlock) for verification\n     * @param amount The amount of the transaction on this chain\n     * @param expiry The block.timestamp when the transaction will no longer be\n     *               fulfillable and is freely cancellable on this chain\n     * @param encryptedCallData The calldata to be executed when the tx is\n     *                          fulfilled. Used in the function to allow the user\n     *                          to reconstruct the tx from events. Hash is stored\n     *                          onchain to prevent shenanigans.\n     * @param encodedBid The encoded bid that was accepted by the user for this\n     *                   crosschain transfer. It is supplied as a param to the\n     *                   function but is only used in event emission\n     * @param bidSignature The signature of the bidder on the encoded bid for\n     *                     this transaction. Only used within the function for\n     *                     event emission. The validity of the bid and\n     *                     bidSignature are enforced offchain\n     * @param encodedMeta The meta for the function\n     */\n    struct PrepareArgs {\n        InvariantTransactionData invariantData;\n        uint256 amount;\n        uint256 expiry;\n        bytes encryptedCallData;\n        bytes encodedBid;\n        bytes bidSignature;\n        bytes encodedMeta;\n    }\n\n    // called in the following order (in happy case)\n    // 1. prepare by user on sending chain\n    function prepare(\n        PrepareArgs calldata args\n    ) external payable returns (TransactionData memory);\n}\n"
    },
    "src/Interfaces/IWormholeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IWormholeRouter {\n    function transferTokens(\n        address token,\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    ) external;\n\n    function wrapAndTransferETH(\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    ) external payable returns (uint64 sequence);\n}\n"
    },
    "src/Interfaces/IXDaiBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IXDaiBridge {\n    /// @notice Bridge Dai to xDai and sends to receiver\n    /// @dev It's implemented in xDaiBridge on only Ethereum\n    /// @param receiver Receiver address\n    /// @param amount Dai amount\n    function relayTokens(address receiver, uint256 amount) external;\n}\n"
    },
    "src/Interfaces/IXDaiBridgeL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IXDaiBridgeL2 {\n    /// @notice Bridge xDai to DAI and sends to receiver\n    /// @dev It's implemented in xDaiBridge on only Gnosis\n    /// @param receiver Receiver address\n    function relayTokens(address receiver) external payable;\n}\n"
    },
    "src/Libraries/LibAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { CannotAuthoriseSelf, UnAuthorized } from \"../Errors/GenericErrors.sol\";\n\n/// @title Access Library\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for managing method level access control\nlibrary LibAccess {\n    /// Types ///\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.library.access.management\");\n\n    /// Storage ///\n    struct AccessStorage {\n        mapping(bytes4 => mapping(address => bool)) execAccess;\n    }\n\n    /// Events ///\n    event AccessGranted(address indexed account, bytes4 indexed method);\n    event AccessRevoked(address indexed account, bytes4 indexed method);\n\n    /// @dev Fetch local storage\n    function accessStorage()\n        internal\n        pure\n        returns (AccessStorage storage accStor)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            accStor.slot := position\n        }\n    }\n\n    /// @notice Gives an address permission to execute a method\n    /// @param selector The method selector to execute\n    /// @param executor The address to grant permission to\n    function addAccess(bytes4 selector, address executor) internal {\n        if (executor == address(this)) {\n            revert CannotAuthoriseSelf();\n        }\n        AccessStorage storage accStor = accessStorage();\n        accStor.execAccess[selector][executor] = true;\n        emit AccessGranted(executor, selector);\n    }\n\n    /// @notice Revokes permission to execute a method\n    /// @param selector The method selector to execute\n    /// @param executor The address to revoke permission from\n    function removeAccess(bytes4 selector, address executor) internal {\n        AccessStorage storage accStor = accessStorage();\n        accStor.execAccess[selector][executor] = false;\n        emit AccessRevoked(executor, selector);\n    }\n\n    /// @notice Enforces access control by reverting if `msg.sender`\n    ///     has not been given permission to execute `msg.sig`\n    function enforceAccessControl() internal view {\n        AccessStorage storage accStor = accessStorage();\n        if (accStor.execAccess[msg.sig][msg.sender] != true)\n            revert UnAuthorized();\n    }\n}\n"
    },
    "src/Libraries/LibAllowList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { InvalidContract } from \"../Errors/GenericErrors.sol\";\n\n/// @title Lib Allow List\n/// @author LI.FI (https://li.fi)\n/// @notice Library for managing and accessing the conract address allow list\nlibrary LibAllowList {\n    /// Storage ///\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.library.allow.list\");\n\n    struct AllowListStorage {\n        mapping(address => bool) allowlist;\n        mapping(bytes4 => bool) selectorAllowList;\n        address[] contracts;\n    }\n\n    /// @dev Adds a contract address to the allow list\n    /// @param _contract the contract address to add\n    function addAllowedContract(address _contract) internal {\n        _checkAddress(_contract);\n\n        AllowListStorage storage als = _getStorage();\n\n        if (als.allowlist[_contract]) return;\n\n        als.allowlist[_contract] = true;\n        als.contracts.push(_contract);\n    }\n\n    /// @dev Checks whether a contract address has been added to the allow list\n    /// @param _contract the contract address to check\n    function contractIsAllowed(\n        address _contract\n    ) internal view returns (bool) {\n        return _getStorage().allowlist[_contract];\n    }\n\n    /// @dev Remove a contract address from the allow list\n    /// @param _contract the contract address to remove\n    function removeAllowedContract(address _contract) internal {\n        AllowListStorage storage als = _getStorage();\n\n        if (!als.allowlist[_contract]) {\n            return;\n        }\n\n        als.allowlist[_contract] = false;\n\n        uint256 length = als.contracts.length;\n        // Find the contract in the list\n        for (uint256 i = 0; i < length; i++) {\n            if (als.contracts[i] == _contract) {\n                // Move the last element into the place to delete\n                als.contracts[i] = als.contracts[length - 1];\n                // Remove the last element\n                als.contracts.pop();\n                break;\n            }\n        }\n    }\n\n    /// @dev Fetch contract addresses from the allow list\n    function getAllowedContracts() internal view returns (address[] memory) {\n        return _getStorage().contracts;\n    }\n\n    /// @dev Add a selector to the allow list\n    /// @param _selector the selector to add\n    function addAllowedSelector(bytes4 _selector) internal {\n        _getStorage().selectorAllowList[_selector] = true;\n    }\n\n    /// @dev Removes a selector from the allow list\n    /// @param _selector the selector to remove\n    function removeAllowedSelector(bytes4 _selector) internal {\n        _getStorage().selectorAllowList[_selector] = false;\n    }\n\n    /// @dev Returns if selector has been added to the allow list\n    /// @param _selector the selector to check\n    function selectorIsAllowed(bytes4 _selector) internal view returns (bool) {\n        return _getStorage().selectorAllowList[_selector];\n    }\n\n    /// @dev Fetch local storage struct\n    function _getStorage()\n        internal\n        pure\n        returns (AllowListStorage storage als)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            als.slot := position\n        }\n    }\n\n    /// @dev Contains business logic for validating a contract address.\n    /// @param _contract address of the dex to check\n    function _checkAddress(address _contract) private view {\n        if (_contract == address(0)) revert InvalidContract();\n\n        if (_contract.code.length == 0) revert InvalidContract();\n    }\n}\n"
    },
    "src/Libraries/LibAsset.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\nimport { InsufficientBalance, NullAddrIsNotAnERC20Token, NullAddrIsNotAValidSpender, NoTransferToNullAddress, InvalidAmount, NativeAssetTransferFailed } from \"../Errors/GenericErrors.sol\";\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { LibSwap } from \"./LibSwap.sol\";\n\n/// @title LibAsset\n/// @notice This library contains helpers for dealing with onchain transfers\n///         of assets, including accounting for the native asset `assetId`\n///         conventions and any noncompliant ERC20 transfers\nlibrary LibAsset {\n    uint256 private constant MAX_UINT = type(uint256).max;\n\n    address internal constant NULL_ADDRESS = address(0);\n\n    /// @dev All native assets use the empty address for their asset id\n    ///      by convention\n\n    address internal constant NATIVE_ASSETID = NULL_ADDRESS; //address(0)\n\n    /// @notice Gets the balance of the inheriting contract for the given asset\n    /// @param assetId The asset identifier to get the balance of\n    /// @return Balance held by contracts using this library\n    function getOwnBalance(address assetId) internal view returns (uint256) {\n        return\n            isNativeAsset(assetId)\n                ? address(this).balance\n                : IERC20(assetId).balanceOf(address(this));\n    }\n\n    /// @notice Transfers ether from the inheriting contract to a given\n    ///         recipient\n    /// @param recipient Address to send ether to\n    /// @param amount Amount to send to given recipient\n    function transferNativeAsset(\n        address payable recipient,\n        uint256 amount\n    ) private {\n        if (recipient == NULL_ADDRESS) revert NoTransferToNullAddress();\n        if (amount > address(this).balance)\n            revert InsufficientBalance(amount, address(this).balance);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        if (!success) revert NativeAssetTransferFailed();\n    }\n\n    /// @notice If the current allowance is insufficient, the allowance for a given spender\n    /// is set to MAX_UINT.\n    /// @param assetId Token address to transfer\n    /// @param spender Address to give spend approval to\n    /// @param amount Amount to approve for spending\n    function maxApproveERC20(\n        IERC20 assetId,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(address(assetId))) {\n            return;\n        }\n        if (spender == NULL_ADDRESS) {\n            revert NullAddrIsNotAValidSpender();\n        }\n\n        if (assetId.allowance(address(this), spender) < amount) {\n            SafeERC20.safeApprove(IERC20(assetId), spender, 0);\n            SafeERC20.safeApprove(IERC20(assetId), spender, MAX_UINT);\n        }\n    }\n\n    /// @notice Transfers tokens from the inheriting contract to a given\n    ///         recipient\n    /// @param assetId Token address to transfer\n    /// @param recipient Address to send token to\n    /// @param amount Amount to send to given recipient\n    function transferERC20(\n        address assetId,\n        address recipient,\n        uint256 amount\n    ) private {\n        if (isNativeAsset(assetId)) {\n            revert NullAddrIsNotAnERC20Token();\n        }\n        if (recipient == NULL_ADDRESS) {\n            revert NoTransferToNullAddress();\n        }\n\n        uint256 assetBalance = IERC20(assetId).balanceOf(address(this));\n        if (amount > assetBalance) {\n            revert InsufficientBalance(amount, assetBalance);\n        }\n        SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);\n    }\n\n    /// @notice Transfers tokens from a sender to a given recipient\n    /// @param assetId Token address to transfer\n    /// @param from Address of sender/owner\n    /// @param to Address of recipient/spender\n    /// @param amount Amount to transfer from owner to spender\n    function transferFromERC20(\n        address assetId,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(assetId)) {\n            revert NullAddrIsNotAnERC20Token();\n        }\n        if (to == NULL_ADDRESS) {\n            revert NoTransferToNullAddress();\n        }\n\n        IERC20 asset = IERC20(assetId);\n        uint256 prevBalance = asset.balanceOf(to);\n        SafeERC20.safeTransferFrom(asset, from, to, amount);\n        if (asset.balanceOf(to) - prevBalance != amount) {\n            revert InvalidAmount();\n        }\n    }\n\n    function depositAsset(address assetId, uint256 amount) internal {\n        if (amount == 0) revert InvalidAmount();\n        if (isNativeAsset(assetId)) {\n            if (msg.value < amount) revert InvalidAmount();\n        } else {\n            uint256 balance = IERC20(assetId).balanceOf(msg.sender);\n            if (balance < amount) revert InsufficientBalance(amount, balance);\n            transferFromERC20(assetId, msg.sender, address(this), amount);\n        }\n    }\n\n    function depositAssets(LibSwap.SwapData[] calldata swaps) internal {\n        for (uint256 i = 0; i < swaps.length; ) {\n            LibSwap.SwapData calldata swap = swaps[i];\n            if (swap.requiresDeposit) {\n                depositAsset(swap.sendingAssetId, swap.fromAmount);\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @notice Determines whether the given assetId is the native asset\n    /// @param assetId The asset identifier to evaluate\n    /// @return Boolean indicating if the asset is the native asset\n    function isNativeAsset(address assetId) internal pure returns (bool) {\n        return assetId == NATIVE_ASSETID;\n    }\n\n    /// @notice Wrapper function to transfer a given asset (native or erc20) to\n    ///         some recipient. Should handle all non-compliant return value\n    ///         tokens as well by using the SafeERC20 contract by open zeppelin.\n    /// @param assetId Asset id for transfer (address(0) for native asset,\n    ///                token address for erc20s)\n    /// @param recipient Address to send asset to\n    /// @param amount Amount to send to given recipient\n    function transferAsset(\n        address assetId,\n        address payable recipient,\n        uint256 amount\n    ) internal {\n        isNativeAsset(assetId)\n            ? transferNativeAsset(recipient, amount)\n            : transferERC20(assetId, recipient, amount);\n    }\n\n    /// @dev Checks whether the given address is a contract and contains code\n    function isContract(address _contractAddr) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(_contractAddr)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "src/Libraries/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary LibBytes {\n    // solhint-disable no-inline-assembly\n\n    // LibBytes specific errors\n    error SliceOverflow();\n    error SliceOutOfBounds();\n    error AddressOutOfBounds();\n\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n\n    // -------------------------\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        if (_length + 31 < _length) revert SliceOverflow();\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(\n                    add(tempBytes, lengthmod),\n                    mul(0x20, iszero(lengthmod))\n                )\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(\n                        add(\n                            add(_bytes, lengthmod),\n                            mul(0x20, iszero(lengthmod))\n                        ),\n                        _start\n                    )\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(\n        bytes memory _bytes,\n        uint256 _start\n    ) internal pure returns (address) {\n        if (_bytes.length < _start + 20) {\n            revert AddressOutOfBounds();\n        }\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/Libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IDiamondCut } from \"../Interfaces/IDiamondCut.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { OnlyContractOwner } from \"../Errors/GenericErrors.sol\";\n\n/// Implementation of EIP-2535 Diamond Standard\n/// https://eips.ethereum.org/EIPS/eip-2535\nlibrary LibDiamond {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    // Diamond specific errors\n    error IncorrectFacetCutAction();\n    error NoSelectorsInFace();\n    error FunctionAlreadyExists();\n    error FacetAddressIsZero();\n    error FacetAddressIsNotZero();\n    error FacetContainsNoCode();\n    error FunctionDoesNotExist();\n    error FunctionIsImmutable();\n    error InitZeroButCalldataNotEmpty();\n    error CalldataEmptyButInitNotZero();\n    error InitReverted();\n    // ----------------\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner)\n            revert OnlyContractOwner();\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else {\n                revert IncorrectFacetCutAction();\n            }\n            unchecked {\n                ++facetIndex;\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsZero();\n        }\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            if (!LibUtil.isZeroAddress(oldFacetAddress)) {\n                revert FunctionAlreadyExists();\n            }\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            unchecked {\n                ++selectorPosition;\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsZero();\n        }\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            if (oldFacetAddress == _facetAddress) {\n                revert FunctionAlreadyExists();\n            }\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            unchecked {\n                ++selectorPosition;\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        if (!LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsNotZero();\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n            unchecked {\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function addFacet(\n        DiamondStorage storage ds,\n        address _facetAddress\n    ) internal {\n        enforceHasContractCode(_facetAddress);\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\n            .facetAddresses\n            .length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondStorage storage ds,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\n            _selector\n        );\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(\n        DiamondStorage storage ds,\n        address _facetAddress,\n        bytes4 _selector\n    ) internal {\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FunctionDoesNotExist();\n        }\n        // an immutable function is a function defined directly in a diamond\n        if (_facetAddress == address(this)) {\n            revert FunctionIsImmutable();\n        }\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition;\n        uint256 lastSelectorPosition = ds\n            .facetFunctionSelectors[_facetAddress]\n            .functionSelectors\n            .length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds\n                .facetFunctionSelectors[_facetAddress]\n                .functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\n                selectorPosition\n            ] = lastSelector;\n            ds\n                .selectorToFacetAndPosition[lastSelector]\n                .functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[\n                    lastFacetAddressPosition\n                ];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds\n                    .facetFunctionSelectors[lastFacetAddress]\n                    .facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        if (LibUtil.isZeroAddress(_init)) {\n            if (_calldata.length != 0) {\n                revert InitZeroButCalldataNotEmpty();\n            }\n        } else {\n            if (_calldata.length == 0) {\n                revert CalldataEmptyButInitNotZero();\n            }\n            if (_init != address(this)) {\n                enforceHasContractCode(_init);\n            }\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert InitReverted();\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract) internal view {\n        uint256 contractSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if (contractSize == 0) {\n            revert FacetContainsNoCode();\n        }\n    }\n}\n"
    },
    "src/Libraries/LibSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\nimport { InvalidContract, NoSwapFromZeroBalance, InsufficientBalance } from \"../Errors/GenericErrors.sol\";\nimport { IERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nlibrary LibSwap {\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n        bool requiresDeposit;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swap) internal {\n        if (!LibAsset.isContract(_swap.callTo)) revert InvalidContract();\n        uint256 fromAmount = _swap.fromAmount;\n        if (fromAmount == 0) revert NoSwapFromZeroBalance();\n        uint256 nativeValue = LibAsset.isNativeAsset(_swap.sendingAssetId)\n            ? _swap.fromAmount\n            : 0;\n        uint256 initialSendingAssetBalance = LibAsset.getOwnBalance(\n            _swap.sendingAssetId\n        );\n        uint256 initialReceivingAssetBalance = LibAsset.getOwnBalance(\n            _swap.receivingAssetId\n        );\n\n        if (nativeValue == 0) {\n            LibAsset.maxApproveERC20(\n                IERC20(_swap.sendingAssetId),\n                _swap.approveTo,\n                _swap.fromAmount\n            );\n        }\n\n        if (initialSendingAssetBalance < _swap.fromAmount) {\n            revert InsufficientBalance(\n                _swap.fromAmount,\n                initialSendingAssetBalance\n            );\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swap.callTo.call{\n            value: nativeValue\n        }(_swap.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        uint256 newBalance = LibAsset.getOwnBalance(_swap.receivingAssetId);\n\n        emit AssetSwapped(\n            transactionId,\n            _swap.callTo,\n            _swap.sendingAssetId,\n            _swap.receivingAssetId,\n            _swap.fromAmount,\n            newBalance > initialReceivingAssetBalance\n                ? newBalance - initialReceivingAssetBalance\n                : newBalance,\n            block.timestamp\n        );\n    }\n}\n"
    },
    "src/Libraries/LibUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./LibBytes.sol\";\n\nlibrary LibUtil {\n    using LibBytes for bytes;\n\n    function getRevertMsg(\n        bytes memory _res\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) return \"Transaction reverted silently\";\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Determines whether the given address is the zero address\n    /// @param addr The address to verify\n    /// @return Boolean indicating if the address is the zero address\n    function isZeroAddress(address addr) internal pure returns (bool) {\n        return addr == address(0);\n    }\n}\n"
    },
    "src/LiFiDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"./Libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./Interfaces/IDiamondCut.sol\";\nimport { LibUtil } from \"./Libraries/LibUtil.sol\";\n\n/// @title LIFI Diamond\n/// @author LI.FI (https://li.fi)\n/// @notice Base EIP-2535 Diamond Proxy Contract.\n/// @custom:version 1.0.0\ncontract LiFiDiamond {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n\n        // get diamond storage\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n\n        if (facet == address(0)) {\n            revert LibDiamond.FunctionDoesNotExist();\n        }\n\n        // Execute external function from facet using delegatecall and return any value.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Able to receive ether\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/LiFiDiamondImmutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"./Libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./Interfaces/IDiamondCut.sol\";\nimport { LibUtil } from \"./Libraries/LibUtil.sol\";\n\n/// @title LIFI Diamond Immutable\n/// @author LI.FI (https://li.fi)\n/// @notice (Immutable) Base EIP-2535 Diamond Proxy Contract.\n/// @custom:version 1.0.0\ncontract LiFiDiamondImmutable {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n\n        // get diamond storage\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n\n        if (facet == address(0)) {\n            revert LibDiamond.FunctionDoesNotExist();\n        }\n\n        // Execute external function from facet using delegatecall and return any value.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Able to receive ether\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/Periphery/ERC20Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { Ownable } from \"../../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\n/// @title ERC20 Proxy\n/// @author LI.FI (https://li.fi)\n/// @notice Proxy contract for safely transferring ERC20 tokens for swaps/executions\n/// @custom:version 1.0.0\ncontract ERC20Proxy is Ownable {\n    /// Storage ///\n    mapping(address => bool) public authorizedCallers;\n\n    /// Errors ///\n    error UnAuthorized();\n\n    /// Events ///\n    event AuthorizationChanged(address indexed caller, bool authorized);\n\n    /// Constructor\n    constructor(address _owner) {\n        transferOwnership(_owner);\n    }\n\n    /// @notice Sets whether or not a specified caller is authorized to call this contract\n    /// @param caller the caller to change authorization for\n    /// @param authorized specifies whether the caller is authorized (true/false)\n    function setAuthorizedCaller(\n        address caller,\n        bool authorized\n    ) external onlyOwner {\n        authorizedCallers[caller] = authorized;\n        emit AuthorizationChanged(caller, authorized);\n    }\n\n    /// @notice Transfers tokens from one address to another specified address\n    /// @param tokenAddress the ERC20 contract address of the token to send\n    /// @param from the address to transfer from\n    /// @param to the address to transfer to\n    /// @param amount the amount of tokens to send\n    function transferFrom(\n        address tokenAddress,\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        if (!authorizedCallers[msg.sender]) revert UnAuthorized();\n\n        LibAsset.transferFromERC20(tokenAddress, from, to, amount);\n    }\n}\n"
    },
    "src/Periphery/Executor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { UnAuthorized } from \"../../src/Errors/GenericErrors.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IERC20Proxy } from \"../Interfaces/IERC20Proxy.sol\";\nimport { ERC1155Holder } from \"../../lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport { ERC721Holder } from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { IERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Executor\n/// @author LI.FI (https://li.fi)\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing\n/// @custom:version 2.0.0\ncontract Executor is ILiFi, ReentrancyGuard, ERC1155Holder, ERC721Holder {\n    /// Storage ///\n\n    /// @notice The address of the ERC20Proxy contract\n    IERC20Proxy public erc20Proxy;\n\n    /// Events ///\n    event ERC20ProxySet(address indexed proxy);\n\n    /// Modifiers ///\n\n    /// @dev Sends any leftover balances back to the user\n    modifier noLeftovers(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            uint256[] memory initialBalances = _fetchBalances(_swaps);\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance = 0;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance = LibAsset.getOwnBalance(curAsset);\n                    if (curBalance > initialBalances[i]) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance - initialBalances[i]\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// Constructor\n    /// @notice Initialize local variables for the Executor\n    /// @param _erc20Proxy The address of the ERC20Proxy contract\n    constructor(address _erc20Proxy) {\n        erc20Proxy = IERC20Proxy(_erc20Proxy);\n        emit ERC20ProxySet(_erc20Proxy);\n    }\n\n    /// External Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver\n    ) external payable nonReentrant {\n        _processSwaps(\n            _transactionId,\n            _swapData,\n            _transferredAssetId,\n            _receiver,\n            0,\n            true\n        );\n    }\n\n    /// @notice Performs a series of swaps or arbitrary executions\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    /// @param _amount amount of token for swaps or arbitrary executions\n    function swapAndExecute(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver,\n        uint256 _amount\n    ) external payable nonReentrant {\n        _processSwaps(\n            _transactionId,\n            _swapData,\n            _transferredAssetId,\n            _receiver,\n            _amount,\n            false\n        );\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a series of swaps or arbitrary executions\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    /// @param _amount amount of token for swaps or arbitrary executions\n    /// @param _depositAllowance If deposit approved amount of token\n    function _processSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver,\n        uint256 _amount,\n        bool _depositAllowance\n    ) private {\n        uint256 startingBalance;\n        uint256 finalAssetStartingBalance;\n        address finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        if (!LibAsset.isNativeAsset(finalAssetId)) {\n            finalAssetStartingBalance = LibAsset.getOwnBalance(finalAssetId);\n        } else {\n            finalAssetStartingBalance =\n                LibAsset.getOwnBalance(finalAssetId) -\n                msg.value;\n        }\n\n        if (!LibAsset.isNativeAsset(_transferredAssetId)) {\n            startingBalance = LibAsset.getOwnBalance(_transferredAssetId);\n            if (_depositAllowance) {\n                uint256 allowance = IERC20(_transferredAssetId).allowance(\n                    msg.sender,\n                    address(this)\n                );\n                LibAsset.depositAsset(_transferredAssetId, allowance);\n            } else {\n                erc20Proxy.transferFrom(\n                    _transferredAssetId,\n                    msg.sender,\n                    address(this),\n                    _amount\n                );\n            }\n        } else {\n            startingBalance =\n                LibAsset.getOwnBalance(_transferredAssetId) -\n                msg.value;\n        }\n\n        _executeSwaps(_transactionId, _swapData, _receiver);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_transferredAssetId);\n        if (postSwapBalance > startingBalance) {\n            LibAsset.transferAsset(\n                _transferredAssetId,\n                _receiver,\n                postSwapBalance - startingBalance\n            );\n        }\n\n        uint256 finalAssetPostSwapBalance = LibAsset.getOwnBalance(\n            finalAssetId\n        );\n\n        if (finalAssetPostSwapBalance > finalAssetStartingBalance) {\n            LibAsset.transferAsset(\n                finalAssetId,\n                _receiver,\n                finalAssetPostSwapBalance - finalAssetStartingBalance\n            );\n        }\n\n        emit LiFiTransferCompleted(\n            _transactionId,\n            _transferredAssetId,\n            _receiver,\n            finalAssetPostSwapBalance,\n            block.timestamp\n        );\n    }\n\n    /// @dev Executes swaps one after the other\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData Array of data used to execute swaps\n    /// @param _leftoverReceiver Address to receive lefover tokens\n    function _executeSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address payable _leftoverReceiver\n    ) private noLeftovers(_swapData, _leftoverReceiver) {\n        uint256 numSwaps = _swapData.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            if (_swapData[i].callTo == address(erc20Proxy)) {\n                revert UnAuthorized(); // Prevent calling ERC20 Proxy directly\n            }\n\n            LibSwap.SwapData calldata currentSwapData = _swapData[i];\n            LibSwap.swap(_transactionId, currentSwapData);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Fetches balances of tokens to be swapped before swapping.\n    /// @param _swapData Array of data used to execute swaps\n    /// @return uint256[] Array of token balances.\n    function _fetchBalances(\n        LibSwap.SwapData[] calldata _swapData\n    ) private view returns (uint256[] memory) {\n        uint256 numSwaps = _swapData.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swapData[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }\n\n    /// @dev required for receiving native assets from destination swaps\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/Periphery/FeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title Fee Collector\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for collecting integrator fees\n/// @custom:version 1.0.0\ncontract FeeCollector is TransferrableOwnership {\n    /// State ///\n\n    // Integrator -> TokenAddress -> Balance\n    mapping(address => mapping(address => uint256)) private _balances;\n    // TokenAddress -> Balance\n    mapping(address => uint256) private _lifiBalances;\n\n    /// Errors ///\n    error TransferFailure();\n    error NotEnoughNativeForFees();\n\n    /// Events ///\n    event FeesCollected(\n        address indexed _token,\n        address indexed _integrator,\n        uint256 _integratorFee,\n        uint256 _lifiFee\n    );\n    event FeesWithdrawn(\n        address indexed _token,\n        address indexed _to,\n        uint256 _amount\n    );\n    event LiFiFeesWithdrawn(\n        address indexed _token,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    /// Constructor ///\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) TransferrableOwnership(_owner) {}\n\n    /// External Methods ///\n\n    /// @notice Collects fees for the integrator\n    /// @param tokenAddress address of the token to collect fees for\n    /// @param integratorFee amount of fees to collect going to the integrator\n    /// @param lifiFee amount of fees to collect going to lifi\n    /// @param integratorAddress address of the integrator\n    function collectTokenFees(\n        address tokenAddress,\n        uint256 integratorFee,\n        uint256 lifiFee,\n        address integratorAddress\n    ) external {\n        LibAsset.depositAsset(tokenAddress, integratorFee + lifiFee);\n        _balances[integratorAddress][tokenAddress] += integratorFee;\n        _lifiBalances[tokenAddress] += lifiFee;\n        emit FeesCollected(\n            tokenAddress,\n            integratorAddress,\n            integratorFee,\n            lifiFee\n        );\n    }\n\n    /// @notice Collects fees for the integrator in native token\n    /// @param integratorFee amount of fees to collect going to the integrator\n    /// @param lifiFee amount of fees to collect going to lifi\n    /// @param integratorAddress address of the integrator\n    function collectNativeFees(\n        uint256 integratorFee,\n        uint256 lifiFee,\n        address integratorAddress\n    ) external payable {\n        if (msg.value < integratorFee + lifiFee)\n            revert NotEnoughNativeForFees();\n        _balances[integratorAddress][LibAsset.NULL_ADDRESS] += integratorFee;\n        _lifiBalances[LibAsset.NULL_ADDRESS] += lifiFee;\n        uint256 remaining = msg.value - (integratorFee + lifiFee);\n        // Prevent extra native token from being locked in the contract\n        if (remaining > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = payable(msg.sender).call{ value: remaining }(\n                \"\"\n            );\n            if (!success) {\n                revert TransferFailure();\n            }\n        }\n        emit FeesCollected(\n            LibAsset.NULL_ADDRESS,\n            integratorAddress,\n            integratorFee,\n            lifiFee\n        );\n    }\n\n    /// @notice Withdraw fees and sends to the integrator\n    /// @param tokenAddress address of the token to withdraw fees for\n    function withdrawIntegratorFees(address tokenAddress) external {\n        uint256 balance = _balances[msg.sender][tokenAddress];\n        if (balance == 0) {\n            return;\n        }\n        _balances[msg.sender][tokenAddress] = 0;\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit FeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraw fees and sends to the integrator\n    /// @param tokenAddresses addresses of the tokens to withdraw fees for\n    function batchWithdrawIntegratorFees(\n        address[] memory tokenAddresses\n    ) external {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = _balances[msg.sender][tokenAddresses[i]];\n            if (balance != 0) {\n                _balances[msg.sender][tokenAddresses[i]] = 0;\n                LibAsset.transferAsset(\n                    tokenAddresses[i],\n                    payable(msg.sender),\n                    balance\n                );\n                emit FeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Withdraws fees and sends to lifi\n    /// @param tokenAddress address of the token to withdraw fees for\n    function withdrawLifiFees(address tokenAddress) external onlyOwner {\n        uint256 balance = _lifiBalances[tokenAddress];\n        if (balance == 0) {\n            return;\n        }\n        _lifiBalances[tokenAddress] = 0;\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit LiFiFeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraws fees and sends to lifi\n    /// @param tokenAddresses addresses of the tokens to withdraw fees for\n    function batchWithdrawLifiFees(\n        address[] memory tokenAddresses\n    ) external onlyOwner {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = _lifiBalances[tokenAddresses[i]];\n            _lifiBalances[tokenAddresses[i]] = 0;\n            LibAsset.transferAsset(\n                tokenAddresses[i],\n                payable(msg.sender),\n                balance\n            );\n            emit LiFiFeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the balance of the integrator\n    /// @param integratorAddress address of the integrator\n    /// @param tokenAddress address of the token to get the balance of\n    function getTokenBalance(\n        address integratorAddress,\n        address tokenAddress\n    ) external view returns (uint256) {\n        return _balances[integratorAddress][tokenAddress];\n    }\n\n    /// @notice Returns the balance of lifi\n    /// @param tokenAddress address of the token to get the balance of\n    function getLifiTokenBalance(\n        address tokenAddress\n    ) external view returns (uint256) {\n        return _lifiBalances[tokenAddress];\n    }\n}\n"
    },
    "src/Periphery/LiFuelFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title LiFuelFeeCollector\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for collecting fees for LiFuel\n/// @custom:version 1.0.0\ncontract LiFuelFeeCollector is TransferrableOwnership {\n    /// Errors ///\n    error TransferFailure();\n    error NotEnoughNativeForFees();\n\n    /// Events ///\n    event GasFeesCollected(\n        address indexed token,\n        uint256 indexed chainId,\n        address indexed receiver,\n        uint256 feeAmount\n    );\n\n    event FeesWithdrawn(\n        address indexed token,\n        address indexed to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) TransferrableOwnership(_owner) {}\n\n    /// External Methods ///\n\n    /// @notice Collects gas fees\n    /// @param tokenAddress The address of the token to collect\n    /// @param feeAmount The amount of fees to collect\n    /// @param chainId The chain id of the destination chain\n    /// @param receiver The address to send gas to on the destination chain\n    function collectTokenGasFees(\n        address tokenAddress,\n        uint256 feeAmount,\n        uint256 chainId,\n        address receiver\n    ) external {\n        LibAsset.depositAsset(tokenAddress, feeAmount);\n        emit GasFeesCollected(tokenAddress, chainId, receiver, feeAmount);\n    }\n\n    /// @notice Collects gas fees in native token\n    /// @param chainId The chain id of the destination chain\n    /// @param receiver The address to send gas to on destination chain\n    function collectNativeGasFees(\n        uint256 chainId,\n        address receiver\n    ) external payable {\n        emit GasFeesCollected(\n            LibAsset.NULL_ADDRESS,\n            chainId,\n            receiver,\n            msg.value\n        );\n    }\n\n    /// @notice Withdraws fees\n    /// @param tokenAddress The address of the token to withdraw fees for\n    function withdrawFees(address tokenAddress) external onlyOwner {\n        uint256 balance = LibAsset.getOwnBalance(tokenAddress);\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit FeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraws fees\n    /// @param tokenAddresses The addresses of the tokens to withdraw fees for\n    function batchWithdrawFees(\n        address[] calldata tokenAddresses\n    ) external onlyOwner {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = LibAsset.getOwnBalance(tokenAddresses[i]);\n            LibAsset.transferAsset(\n                tokenAddresses[i],\n                payable(msg.sender),\n                balance\n            );\n            emit FeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "src/Periphery/Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC20, SafeERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IExecutor } from \"../Interfaces/IExecutor.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { ExternalCallFailed, UnAuthorized } from \"../Errors/GenericErrors.sol\";\n\n/// @title Receiver\n/// @author LI.FI (https://li.fi)\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing\n/// @custom:version 2.0.2\ncontract Receiver is ILiFi, ReentrancyGuard, TransferrableOwnership {\n    using SafeERC20 for IERC20;\n\n    /// Storage ///\n    address public sgRouter;\n    IExecutor public executor;\n    uint256 public recoverGas;\n    address public amarokRouter;\n\n    /// Events ///\n    event StargateRouterSet(address indexed router);\n    event AmarokRouterSet(address indexed router);\n    event ExecutorSet(address indexed executor);\n    event RecoverGasSet(uint256 indexed recoverGas);\n\n    /// Modifiers ///\n    modifier onlySGRouter() {\n        if (msg.sender != sgRouter) {\n            revert UnAuthorized();\n        }\n        _;\n    }\n    modifier onlyAmarokRouter() {\n        if (msg.sender != amarokRouter) {\n            revert UnAuthorized();\n        }\n        _;\n    }\n\n    /// Constructor\n    constructor(\n        address _owner,\n        address _sgRouter,\n        address _amarokRouter,\n        address _executor,\n        uint256 _recoverGas\n    ) TransferrableOwnership(_owner) {\n        owner = _owner;\n        sgRouter = _sgRouter;\n        amarokRouter = _amarokRouter;\n        executor = IExecutor(_executor);\n        recoverGas = _recoverGas;\n        emit StargateRouterSet(_sgRouter);\n        emit AmarokRouterSet(_amarokRouter);\n        emit RecoverGasSet(_recoverGas);\n    }\n\n    /// External Methods ///\n\n    /// @notice Completes a cross-chain transaction with calldata via Amarok facet on the receiving chain.\n    /// @dev This function is called from Amarok Router.\n    /// @param _transferId The unique ID of this transaction (assigned by Amarok)\n    /// @param _amount the amount of bridged tokens\n    /// @param _asset the address of the bridged token\n    /// @param * (unused) the sender of the transaction\n    /// @param * (unused) the domain ID of the src chain\n    /// @param _callData The data to execute\n    function xReceive(\n        bytes32 _transferId,\n        uint256 _amount,\n        address _asset,\n        address,\n        uint32,\n        bytes memory _callData\n    ) external nonReentrant onlyAmarokRouter {\n        (LibSwap.SwapData[] memory swapData, address receiver) = abi.decode(\n            _callData,\n            (LibSwap.SwapData[], address)\n        );\n\n        _swapAndCompleteBridgeTokens(\n            _transferId,\n            swapData,\n            _asset,\n            payable(receiver),\n            _amount,\n            false\n        );\n    }\n\n    /// @notice Completes a cross-chain transaction on the receiving chain.\n    /// @dev This function is called from Stargate Router.\n    /// @param * (unused) The remote chainId sending the tokens\n    /// @param * (unused) The remote Bridge address\n    /// @param * (unused) Nonce\n    /// @param _token The token contract on the local chain\n    /// @param _amountLD The amount of tokens received through bridging\n    /// @param _payload The data to execute\n    function sgReceive(\n        uint16, // _srcChainId unused\n        bytes memory, // _srcAddress unused\n        uint256, // _nonce unused\n        address _token,\n        uint256 _amountLD,\n        bytes memory _payload\n    ) external nonReentrant onlySGRouter {\n        (\n            bytes32 transactionId,\n            LibSwap.SwapData[] memory swapData,\n            ,\n            address receiver\n        ) = abi.decode(\n                _payload,\n                (bytes32, LibSwap.SwapData[], address, address)\n            );\n\n        _swapAndCompleteBridgeTokens(\n            transactionId,\n            swapData,\n            swapData.length > 0 ? swapData[0].sendingAssetId : _token, // If swapping assume sent token is the first token in swapData\n            payable(receiver),\n            _amountLD,\n            true\n        );\n    }\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver\n    ) external payable nonReentrant {\n        if (LibAsset.isNativeAsset(assetId)) {\n            _swapAndCompleteBridgeTokens(\n                _transactionId,\n                _swapData,\n                assetId,\n                receiver,\n                msg.value,\n                false\n            );\n        } else {\n            uint256 allowance = IERC20(assetId).allowance(\n                msg.sender,\n                address(this)\n            );\n            LibAsset.depositAsset(assetId, allowance);\n            _swapAndCompleteBridgeTokens(\n                _transactionId,\n                _swapData,\n                assetId,\n                receiver,\n                allowance,\n                false\n            );\n        }\n    }\n\n    /// @notice Send remaining token to receiver\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    function pullToken(\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    ) external onlyOwner {\n        if (LibAsset.isNativeAsset(assetId)) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = receiver.call{ value: amount }(\"\");\n            if (!success) revert ExternalCallFailed();\n        } else {\n            IERC20(assetId).safeTransfer(receiver, amount);\n        }\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    /// @param reserveRecoverGas whether we need a gas buffer to recover\n    function _swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver,\n        uint256 amount,\n        bool reserveRecoverGas\n    ) private {\n        uint256 _recoverGas = reserveRecoverGas ? recoverGas : 0;\n\n        if (LibAsset.isNativeAsset(assetId)) {\n            // case 1: native asset\n            uint256 cacheGasLeft = gasleft();\n            if (reserveRecoverGas && cacheGasLeft < _recoverGas) {\n                // case 1a: not enough gas left to execute calls\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = receiver.call{ value: amount }(\"\");\n                if (!success) revert ExternalCallFailed();\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 1b: enough gas left to execute calls\n            // solhint-disable no-empty-blocks\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    value: amount,\n                    gas: cacheGasLeft - _recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = receiver.call{ value: amount }(\"\");\n                if (!success) revert ExternalCallFailed();\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n        } else {\n            // case 2: ERC20 asset\n            uint256 cacheGasLeft = gasleft();\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n\n            if (reserveRecoverGas && cacheGasLeft < _recoverGas) {\n                // case 2a: not enough gas left to execute calls\n                token.safeTransfer(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 2b: enough gas left to execute calls\n            token.safeIncreaseAllowance(address(executor), amount);\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    gas: cacheGasLeft - _recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                token.safeTransfer(receiver, amount);\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n\n            token.safeApprove(address(executor), 0);\n        }\n    }\n\n    /// @notice Receive native asset directly.\n    /// @dev Some bridges may send native asset before execute external calls.\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/Periphery/RelayerCelerIM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC20, SafeERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ContractCallNotAllowed, ExternalCallFailed, InvalidConfig, UnAuthorized, WithdrawFailed } from \"../Errors/GenericErrors.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { PeripheryRegistryFacet } from \"../Facets/PeripheryRegistryFacet.sol\";\nimport { IExecutor } from \"../Interfaces/IExecutor.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { IMessageReceiverApp } from \"../../lib/sgn-v2-contracts/contracts/message/interfaces/IMessageReceiverApp.sol\";\nimport { CelerIM } from \"../../src/Helpers/CelerIMFacetBase.sol\";\nimport { MessageSenderLib, MsgDataTypes, IMessageBus, IOriginalTokenVault, IPeggedTokenBridge, IOriginalTokenVaultV2, IPeggedTokenBridgeV2 } from \"../../lib/sgn-v2-contracts/contracts/message/libraries/MessageSenderLib.sol\";\nimport { IBridge as ICBridge } from \"../../lib/sgn-v2-contracts/contracts/interfaces/IBridge.sol\";\n\n/// @title RelayerCelerIM\n/// @author LI.FI (https://li.fi)\n/// @notice Relayer contract for CelerIM that forwards calls and handles refunds on src side and acts receiver on dest\n/// @custom:version 2.0.0\ncontract RelayerCelerIM is ILiFi, TransferrableOwnership {\n    using SafeERC20 for IERC20;\n\n    /// Storage ///\n\n    IMessageBus public cBridgeMessageBus;\n    address public diamondAddress;\n\n    /// Events ///\n\n    event LogWithdraw(\n        address indexed _assetAddress,\n        address indexed _to,\n        uint256 amount\n    );\n\n    /// Modifiers ///\n\n    modifier onlyCBridgeMessageBus() {\n        if (msg.sender != address(cBridgeMessageBus)) revert UnAuthorized();\n        _;\n    }\n    modifier onlyDiamond() {\n        if (msg.sender != diamondAddress) revert UnAuthorized();\n        _;\n    }\n\n    /// Constructor\n\n    constructor(\n        address _cBridgeMessageBusAddress,\n        address _owner,\n        address _diamondAddress\n    ) TransferrableOwnership(_owner) {\n        owner = _owner;\n        cBridgeMessageBus = IMessageBus(_cBridgeMessageBusAddress);\n        diamondAddress = _diamondAddress;\n    }\n\n    /// External Methods ///\n\n    /**\n     * @notice Called by MessageBus to execute a message with an associated token transfer.\n     * The Receiver is guaranteed to have received the right amount of tokens before this function is called.\n     * @param * (unused) The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param * (unused)  The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param * (unused)  Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransfer(\n        address,\n        address _token,\n        uint256 _amount,\n        uint64,\n        bytes calldata _message,\n        address\n    )\n        external\n        payable\n        onlyCBridgeMessageBus\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        // decode message\n        (\n            bytes32 transactionId,\n            LibSwap.SwapData[] memory swapData,\n            address receiver,\n            address refundAddress\n        ) = abi.decode(\n                _message,\n                (bytes32, LibSwap.SwapData[], address, address)\n            );\n\n        _swapAndCompleteBridgeTokens(\n            transactionId,\n            swapData,\n            _token,\n            payable(receiver),\n            _amount,\n            refundAddress\n        );\n\n        return IMessageReceiverApp.ExecutionStatus.Success;\n    }\n\n    /**\n     * @notice Called by MessageBus to process refund of the original transfer from this contract.\n     * The contract is guaranteed to have received the refund before this function is called.\n     * @param _token The token address of the original transfer\n     * @param _amount The amount of the original transfer\n     * @param _message The same message associated with the original transfer\n     * @param * (unused) Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address\n    )\n        external\n        payable\n        onlyCBridgeMessageBus\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        (bytes32 transactionId, , , address refundAddress) = abi.decode(\n            _message,\n            (bytes32, LibSwap.SwapData[], address, address)\n        );\n\n        // return funds to cBridgeData.refundAddress\n        LibAsset.transferAsset(_token, payable(refundAddress), _amount);\n\n        emit LiFiTransferRecovered(\n            transactionId,\n            _token,\n            refundAddress,\n            _amount,\n            block.timestamp\n        );\n\n        return IMessageReceiverApp.ExecutionStatus.Success;\n    }\n\n    /**\n     * @notice Forwards a call to transfer tokens to cBridge (sent via this contract to ensure that potential refunds are sent here)\n     * @param _bridgeData the core information needed for bridging\n     * @param _celerIMData data specific to CelerIM\n     */\n    // solhint-disable-next-line code-complexity\n    function sendTokenTransfer(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    )\n        external\n        payable\n        onlyDiamond\n        returns (bytes32 transferId, address bridgeAddress)\n    {\n        // approve to and call correct bridge depending on BridgeSendType\n        // @dev copied and slightly adapted from Celer MessageSenderLib\n        if (_celerIMData.bridgeType == MsgDataTypes.BridgeSendType.Liquidity) {\n            bridgeAddress = cBridgeMessageBus.liquidityBridge();\n            if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n                // case: native asset bridging\n                ICBridge(bridgeAddress).sendNative{\n                    value: _bridgeData.minAmount\n                }(\n                    _bridgeData.receiver,\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _celerIMData.nonce,\n                    _celerIMData.maxSlippage\n                );\n            } else {\n                // case: ERC20 asset bridging\n                LibAsset.maxApproveERC20(\n                    IERC20(_bridgeData.sendingAssetId),\n                    bridgeAddress,\n                    _bridgeData.minAmount\n                );\n                // solhint-disable-next-line check-send-result\n                ICBridge(bridgeAddress).send(\n                    _bridgeData.receiver,\n                    _bridgeData.sendingAssetId,\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _celerIMData.nonce,\n                    _celerIMData.maxSlippage\n                );\n            }\n            transferId = MessageSenderLib.computeLiqBridgeTransferId(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegDeposit\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegVault();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            IOriginalTokenVault(bridgeAddress).deposit(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n            transferId = MessageSenderLib.computePegV1DepositId(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegBurn\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegBridge();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            IPeggedTokenBridge(bridgeAddress).burn(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n            transferId = MessageSenderLib.computePegV1BurnId(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegV2Deposit\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegVaultV2();\n            if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n                // case: native asset bridging\n                transferId = IOriginalTokenVaultV2(bridgeAddress)\n                    .depositNative{ value: _bridgeData.minAmount }(\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _bridgeData.receiver,\n                    _celerIMData.nonce\n                );\n            } else {\n                // case: ERC20 bridging\n                LibAsset.maxApproveERC20(\n                    IERC20(_bridgeData.sendingAssetId),\n                    bridgeAddress,\n                    _bridgeData.minAmount\n                );\n                transferId = IOriginalTokenVaultV2(bridgeAddress).deposit(\n                    _bridgeData.sendingAssetId,\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _bridgeData.receiver,\n                    _celerIMData.nonce\n                );\n            }\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegV2Burn\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegBridgeV2();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            transferId = IPeggedTokenBridgeV2(bridgeAddress).burn(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType ==\n            MsgDataTypes.BridgeSendType.PegV2BurnFrom\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegBridgeV2();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            transferId = IPeggedTokenBridgeV2(bridgeAddress).burnFrom(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n        } else {\n            revert InvalidConfig();\n        }\n    }\n\n    /**\n     * @notice Forwards a call to the CBridge Messagebus\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _srcBridge The bridge contract to send the transfer with.\n     * @param _srcTransferId The transfer ID.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function forwardSendMessageWithTransfer(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes calldata _message\n    ) external payable onlyDiamond {\n        cBridgeMessageBus.sendMessageWithTransfer{ value: msg.value }(\n            _receiver,\n            _dstChainId,\n            _srcBridge,\n            _srcTransferId,\n            _message\n        );\n    }\n\n    // ------------------------------------------------------------------------------------------------\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    function _swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver,\n        uint256 amount,\n        address refundAddress\n    ) private {\n        bool success;\n        IExecutor executor = IExecutor(\n            PeripheryRegistryFacet(diamondAddress).getPeripheryContract(\n                \"Executor\"\n            )\n        );\n        if (LibAsset.isNativeAsset(assetId)) {\n            try\n                executor.swapAndCompleteBridgeTokens{ value: amount }(\n                    _transactionId,\n                    _swapData,\n                    assetId,\n                    receiver\n                )\n            {\n                success = true;\n            } catch {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool fundsSent, ) = refundAddress.call{ value: amount }(\"\");\n                if (!fundsSent) {\n                    revert ExternalCallFailed();\n                }\n            }\n        } else {\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n            token.safeIncreaseAllowance(address(executor), amount);\n\n            try\n                executor.swapAndCompleteBridgeTokens(\n                    _transactionId,\n                    _swapData,\n                    assetId,\n                    receiver\n                )\n            {\n                success = true;\n            } catch {\n                token.safeTransfer(refundAddress, amount);\n            }\n            token.safeApprove(address(executor), 0);\n        }\n\n        if (!success) {\n            emit LiFiTransferRecovered(\n                _transactionId,\n                assetId,\n                refundAddress,\n                amount,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @notice Sends remaining token to given receiver address (for refund cases)\n    /// @param assetId Address of the token to be withdrawn\n    /// @param receiver Address that will receive tokens\n    /// @param amount Amount of tokens to be withdrawn\n    function withdraw(\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    ) external onlyOwner {\n        if (LibAsset.isNativeAsset(assetId)) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = receiver.call{ value: amount }(\"\");\n            if (!success) {\n                revert WithdrawFailed();\n            }\n        } else {\n            IERC20(assetId).safeTransfer(receiver, amount);\n        }\n        emit LogWithdraw(assetId, receiver, amount);\n    }\n\n    /// @notice Triggers a cBridge refund with calldata produced by cBridge API\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to Address to withdraw to\n    /// @param _amount Amount of asset to withdraw\n    function triggerRefund(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        bool success;\n\n        // make sure that callTo address is either of the cBridge addresses\n        if (\n            cBridgeMessageBus.liquidityBridge() != _callTo &&\n            cBridgeMessageBus.pegBridge() != _callTo &&\n            cBridgeMessageBus.pegBridgeV2() != _callTo &&\n            cBridgeMessageBus.pegVault() != _callTo &&\n            cBridgeMessageBus.pegVaultV2() != _callTo\n        ) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ) = _callTo.call(_callData);\n\n        // forward funds to _to address and emit event, if cBridge refund successful\n        if (success) {\n            address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n            LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n            emit LogWithdraw(_assetAddress, sendTo, _amount);\n        } else {\n            revert WithdrawFailed();\n        }\n    }\n\n    // required in order to receive native tokens from cBridge facet\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/Periphery/ServiceFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title Service Fee Collector\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for collecting service fees (gas/insurance)\n/// @custom:version 1.0.0\ncontract ServiceFeeCollector is TransferrableOwnership {\n    /// Errors ///\n    error TransferFailure();\n    error NotEnoughNativeForFees();\n\n    /// Events ///\n    event GasFeesCollected(\n        address indexed token,\n        uint256 indexed chainId,\n        address indexed receiver,\n        uint256 feeAmount\n    );\n\n    event InsuranceFeesCollected(\n        address indexed token,\n        address indexed receiver,\n        uint256 feeAmount\n    );\n\n    event FeesWithdrawn(\n        address indexed token,\n        address indexed to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) TransferrableOwnership(_owner) {}\n\n    /// External Methods ///\n\n    /// @notice Collects gas fees\n    /// @param tokenAddress The address of the token to collect\n    /// @param feeAmount The amount of fees to collect\n    /// @param chainId The chain id of the destination chain\n    /// @param receiver The address to send gas to on the destination chain\n    function collectTokenGasFees(\n        address tokenAddress,\n        uint256 feeAmount,\n        uint256 chainId,\n        address receiver\n    ) external {\n        LibAsset.depositAsset(tokenAddress, feeAmount);\n        emit GasFeesCollected(tokenAddress, chainId, receiver, feeAmount);\n    }\n\n    /// @notice Collects gas fees in native token\n    /// @param chainId The chain id of the destination chain\n    /// @param receiver The address to send gas to on destination chain\n    function collectNativeGasFees(\n        uint256 chainId,\n        address receiver\n    ) external payable {\n        emit GasFeesCollected(\n            LibAsset.NULL_ADDRESS,\n            chainId,\n            receiver,\n            msg.value\n        );\n    }\n\n    /// @notice Collects insurance fees\n    /// @param tokenAddress The address of the token to collect\n    /// @param feeAmount The amount of fees to collect\n    /// @param receiver The address to insure\n    function collectTokenInsuranceFees(\n        address tokenAddress,\n        uint256 feeAmount,\n        address receiver\n    ) external {\n        LibAsset.depositAsset(tokenAddress, feeAmount);\n        emit InsuranceFeesCollected(tokenAddress, receiver, feeAmount);\n    }\n\n    /// @notice Collects insurance fees in native token\n    /// @param receiver The address to insure\n    function collectNativeInsuranceFees(address receiver) external payable {\n        emit InsuranceFeesCollected(\n            LibAsset.NULL_ADDRESS,\n            receiver,\n            msg.value\n        );\n    }\n\n    /// @notice Withdraws fees\n    /// @param tokenAddress The address of the token to withdraw fees for\n    function withdrawFees(address tokenAddress) external onlyOwner {\n        uint256 balance = LibAsset.getOwnBalance(tokenAddress);\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit FeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraws fees\n    /// @param tokenAddresses The addresses of the tokens to withdraw fees for\n    function batchWithdrawFees(\n        address[] calldata tokenAddresses\n    ) external onlyOwner {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = LibAsset.getOwnBalance(tokenAddresses[i]);\n            LibAsset.transferAsset(\n                tokenAddresses[i],\n                payable(msg.sender),\n                balance\n            );\n            emit FeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "src/Periphery/TokenWrapper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { IERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// External wrapper interface\ninterface IWrapper {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}\n\n/// @title TokenWrapper\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for wrapping and unwrapping tokens\n/// @custom:version 1.0.0\ncontract TokenWrapper {\n    uint256 private constant MAX_INT = 2**256 - 1;\n    address public wrappedToken;\n\n    /// Errors ///\n    error WithdrawFailure();\n\n    /// Constructor ///\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _wrappedToken) {\n        wrappedToken = _wrappedToken;\n        IERC20(wrappedToken).approve(address(this), MAX_INT);\n    }\n\n    /// External Methods ///\n\n    /// @notice Wraps the native token\n    function deposit(\n    ) external payable {\n        IWrapper(wrappedToken).deposit{value: msg.value}();\n        IERC20(wrappedToken).transfer(msg.sender, msg.value);\n    }\n\n    /// @notice Unwraps all the caller's balance of wrapped token\n    function withdraw() external {\n        // While in a general purpose contract it would make sense\n        // to have `wad` equal to the minimum between the balance and the\n        // given allowance, in our specific usecase allowance is always\n        // nearly MAX_UINT256. Using the balance only is a gas optimisation.\n        uint256 wad = IERC20(wrappedToken).balanceOf(msg.sender);\n        IERC20(wrappedToken).transferFrom(msg.sender, address(this), wad);\n        IWrapper(wrappedToken).withdraw(wad);\n        (bool success, ) = payable(msg.sender).call{value: wad}(\"\");\n        if (!success) {\n            revert WithdrawFailure();\n        }\n    }\n\n    // Needs to be able to receive native on `withdraw`\n    receive() external payable {}\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "mode": "3"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.methodIdentifiers",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031373130303935303137393433"
      }
    }
  }
}