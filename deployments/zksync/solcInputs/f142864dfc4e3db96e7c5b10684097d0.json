{
  "language": "Solidity",
  "sources": {
    "lib/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _castLogPayloadViewToPure(\n        function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IBridge {\n    function send(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    function sendNative(\n        address _receiver,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external payable;\n\n    function relay(\n        bytes calldata _relayRequest,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function transfers(bytes32 transferId) external view returns (bool);\n\n    function withdraws(bytes32 withdrawId) external view returns (bool);\n\n    function withdraw(\n        bytes calldata _wdmsg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    /**\n     * @notice Verifies that a message is signed by a quorum among the signers.\n     * @param _msg signed message\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\n     * @param _signers sorted list of current signers\n     * @param _powers powers of current signers\n     */\n    function verifySigs(\n        bytes memory _msg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external view;\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IOriginalTokenVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IOriginalTokenVault {\n    /**\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external;\n\n    /**\n     * @notice Lock native token as original token to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function depositNative(\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external payable;\n\n    /**\n     * @notice Withdraw locked original tokens triggered by a burn at a remote chain's PeggedTokenBridge.\n     * @param _request The serialized Withdraw protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the bridge's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdraw(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IOriginalTokenVaultV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IOriginalTokenVaultV2 {\n    /**\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    /**\n     * @notice Lock native token as original token to trigger mint at a remote chain's PeggedTokenBridge\n     * @param _amount locked token amount\n     * @param _mintChainId destination chainId to mint tokens\n     * @param _mintAccount destination account to receive minted tokens\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function depositNative(\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external payable returns (bytes32);\n\n    /**\n     * @notice Withdraw locked original tokens triggered by a burn at a remote chain's PeggedTokenBridge.\n     * @param _request The serialized Withdraw protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the bridge's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdraw(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external returns (bytes32);\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IPeggedTokenBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IPeggedTokenBridge {\n    /**\n     * @notice Burn tokens to trigger withdrawal at a remote chain's OriginalTokenVault\n     * @param _token local token address\n     * @param _amount locked token amount\n     * @param _withdrawAccount account who withdraw original tokens on the remote chain\n     * @param _nonce user input to guarantee unique depositId\n     */\n    function burn(\n        address _token,\n        uint256 _amount,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) external;\n\n    /**\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\n     * @param _request The serialized Mint protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function mint(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/interfaces/IPeggedTokenBridgeV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IPeggedTokenBridgeV2 {\n    /**\n     * @notice Burn pegged tokens to trigger a cross-chain withdrawal of the original tokens at a remote chain's\n     * OriginalTokenVault, or mint at another remote chain\n     * @param _token The pegged token address.\n     * @param _amount The amount to burn.\n     * @param _toChainId If zero, withdraw from original vault; otherwise, the remote chain to mint tokens.\n     * @param _toAccount The account to receive tokens on the remote chain\n     * @param _nonce A number to guarantee unique depositId. Can be timestamp in practice.\n     */\n    function burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _toAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    // same with `burn` above, use openzeppelin ERC20Burnable interface\n    function burnFrom(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _toAccount,\n        uint64 _nonce\n    ) external returns (bytes32);\n\n    /**\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\n     * @param _request The serialized Mint protobuf.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function mint(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external returns (bytes32);\n\n    function records(bytes32 recordId) external view returns (bool);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/message/interfaces/IMessageBus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"../libraries/MsgDataTypes.sol\";\n\ninterface IMessageBus {\n    /**\n     * @notice Send a message to a contract on another chain.\n     * Sender needs to make sure the uniqueness of the message Id, which is computed as\n     * hash(type.MessageOnly, sender, receiver, srcChainId, srcTxHash, dstChainId, message).\n     * If messages with the same Id are sent, only one of them will succeed at dst chain..\n     * A fee is charged in the native gas token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessage(\n        address _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable;\n\n    // same as above, except that receiver is an non-evm chain address,\n    function sendMessage(\n        bytes calldata _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message\n    ) external payable;\n\n    /**\n     * @notice Send a message associated with a token transfer to a contract on another chain.\n     * If messages with the same srcTransferId are sent, only one of them will succeed at dst chain..\n     * A fee is charged in the native token.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _srcBridge The bridge contract to send the transfer with.\n     * @param _srcTransferId The transfer ID.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes calldata _message\n    ) external payable;\n\n    /**\n     * @notice Execute a message not associated with a transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessage(\n        bytes calldata _message,\n        MsgDataTypes.RouteInfo calldata _route,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Execute a message with a successful transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransfer(\n        bytes calldata _message,\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Execute a message with a refunded transfer.\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _transfer The transfer info.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function executeMessageWithTransferRefund(\n        bytes calldata _message, // the same message associated with the original transfer\n        MsgDataTypes.TransferInfo calldata _transfer,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable;\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     * @param _cumulativeFee The cumulative fee credited to the account. Tracked by SGN.\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A withdrawal must be\n     * signed-off by +2/3 of the sigsVerifier's current signing power to be delivered.\n     * @param _signers The sorted list of signers.\n     * @param _powers The signing powers of the signers.\n     */\n    function withdrawFee(\n        address _account,\n        uint256 _cumulativeFee,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n\n    /**\n     * @notice Calculates the required fee for the message.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     @ @return The required fee.\n     */\n    function calcFee(bytes calldata _message) external view returns (uint256);\n\n    function liquidityBridge() external view returns (address);\n\n    function pegBridge() external view returns (address);\n\n    function pegBridgeV2() external view returns (address);\n\n    function pegVault() external view returns (address);\n\n    function pegVaultV2() external view returns (address);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/message/interfaces/IMessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\ninterface IMessageReceiverApp {\n    enum ExecutionStatus {\n        Fail, // execution failed, finalized\n        Success, // execution succeeded, finalized\n        Retry // execution rejected, can retry later\n    }\n\n    /**\n     * @notice Called by MessageBus to execute a message\n     * @param _sender The address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        address _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    // same as above, except that sender is an non-evm chain address,\n    // otherwise same as above.\n    function executeMessage(\n        bytes calldata _sender,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Called by MessageBus to execute a message with an associated token transfer.\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransfer(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Only called by MessageBus if\n     *         1. executeMessageWithTransfer reverts, or\n     *         2. executeMessageWithTransfer returns ExecutionStatus.Fail\n     * The contract is guaranteed to have received the right amount of tokens before this function is called.\n     * @param _sender The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferFallback(\n        address _sender,\n        address _token,\n        uint256 _amount,\n        uint64 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n\n    /**\n     * @notice Called by MessageBus to process refund of the original transfer from this contract.\n     * The contract is guaranteed to have received the refund before this function is called.\n     * @param _token The token address of the original transfer\n     * @param _amount The amount of the original transfer\n     * @param _message The same message associated with the original transfer\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address _executor\n    ) external payable returns (ExecutionStatus);\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/message/libraries/MessageSenderLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nimport \"../../../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../../../../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../interfaces/IBridge.sol\";\nimport \"../../interfaces/IOriginalTokenVault.sol\";\nimport \"../../interfaces/IOriginalTokenVaultV2.sol\";\nimport \"../../interfaces/IPeggedTokenBridge.sol\";\nimport \"../../interfaces/IPeggedTokenBridgeV2.sol\";\nimport \"../interfaces/IMessageBus.sol\";\nimport \"./MsgDataTypes.sol\";\n\nlibrary MessageSenderLib {\n    using SafeERC20 for IERC20;\n\n    // ============== Internal library functions called by apps ==============\n\n    /**\n     * @notice Sends a message to an app on another chain via MessageBus without an associated transfer.\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     * @param _messageBus The address of the MessageBus on this chain.\n     * @param _fee The fee amount to pay to MessageBus.\n     */\n    function sendMessage(\n        address _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        address _messageBus,\n        uint256 _fee\n    ) internal {\n        IMessageBus(_messageBus).sendMessage{value: _fee}(_receiver, _dstChainId, _message);\n    }\n\n    // Send message to non-evm chain with bytes for receiver address,\n    // otherwise same as above.\n    function sendMessage(\n        bytes calldata _receiver,\n        uint64 _dstChainId,\n        bytes memory _message,\n        address _messageBus,\n        uint256 _fee\n    ) internal {\n        IMessageBus(_messageBus).sendMessage{value: _fee}(_receiver, _dstChainId, _message);\n    }\n\n    /**\n     * @notice Sends a message to an app on another chain via MessageBus with an associated transfer.\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     * Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount or the\n     * transfer can be refunded. Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     * @param _bridgeSendType One of the {MsgDataTypes.BridgeSendType} enum.\n     * @param _messageBus The address of the MessageBus on this chain.\n     * @param _fee The fee amount to pay to MessageBus.\n     * @return The transfer ID.\n     */\n    function sendMessageWithTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        bytes memory _message,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        address _messageBus,\n        uint256 _fee\n    ) internal returns (bytes32) {\n        (bytes32 transferId, address bridge) = sendTokenTransfer(\n            _receiver,\n            _token,\n            _amount,\n            _dstChainId,\n            _nonce,\n            _maxSlippage,\n            _bridgeSendType,\n            _messageBus\n        );\n        if (_message.length > 0) {\n            IMessageBus(_messageBus).sendMessageWithTransfer{value: _fee}(\n                _receiver,\n                _dstChainId,\n                bridge,\n                transferId,\n                _message\n            );\n        }\n        return transferId;\n    }\n\n    /**\n     * @notice Sends a token transfer via a bridge.\n     * @param _receiver The address of the destination app contract.\n     * @param _token The address of the token to be sent.\n     * @param _amount The amount of tokens to be sent.\n     * @param _dstChainId The destination chain ID.\n     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.\n     * Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount or the\n     * transfer can be refunded.\n     * @param _bridgeSendType One of the {MsgDataTypes.BridgeSendType} enum.\n     */\n    function sendTokenTransfer(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage,\n        MsgDataTypes.BridgeSendType _bridgeSendType,\n        address _messageBus\n    ) internal returns (bytes32 transferId, address bridge) {\n        if (_bridgeSendType == MsgDataTypes.BridgeSendType.Liquidity) {\n            bridge = IMessageBus(_messageBus).liquidityBridge();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IBridge(bridge).send(_receiver, _token, _amount, _dstChainId, _nonce, _maxSlippage);\n            transferId = computeLiqBridgeTransferId(_receiver, _token, _amount, _dstChainId, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegDeposit) {\n            bridge = IMessageBus(_messageBus).pegVault();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IOriginalTokenVault(bridge).deposit(_token, _amount, _dstChainId, _receiver, _nonce);\n            transferId = computePegV1DepositId(_receiver, _token, _amount, _dstChainId, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegBurn) {\n            bridge = IMessageBus(_messageBus).pegBridge();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            IPeggedTokenBridge(bridge).burn(_token, _amount, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n            transferId = computePegV1BurnId(_receiver, _token, _amount, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2Deposit) {\n            bridge = IMessageBus(_messageBus).pegVaultV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IOriginalTokenVaultV2(bridge).deposit(_token, _amount, _dstChainId, _receiver, _nonce);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2Burn) {\n            bridge = IMessageBus(_messageBus).pegBridgeV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IPeggedTokenBridgeV2(bridge).burn(_token, _amount, _dstChainId, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n        } else if (_bridgeSendType == MsgDataTypes.BridgeSendType.PegV2BurnFrom) {\n            bridge = IMessageBus(_messageBus).pegBridgeV2();\n            IERC20(_token).safeIncreaseAllowance(bridge, _amount);\n            transferId = IPeggedTokenBridgeV2(bridge).burnFrom(_token, _amount, _dstChainId, _receiver, _nonce);\n            // handle cases where certain tokens do not spend allowance for role-based burn\n            IERC20(_token).safeApprove(bridge, 0);\n        } else {\n            revert(\"bridge type not supported\");\n        }\n    }\n\n    function computeLiqBridgeTransferId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(address(this), _receiver, _token, _amount, _dstChainId, _nonce, uint64(block.chainid))\n            );\n    }\n\n    function computePegV1DepositId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(address(this), _token, _amount, _dstChainId, _receiver, _nonce, uint64(block.chainid))\n            );\n    }\n\n    function computePegV1BurnId(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _nonce\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(address(this), _token, _amount, _receiver, _nonce, uint64(block.chainid)));\n    }\n}\n"
    },
    "lib/sgn-v2-contracts/contracts/message/libraries/MsgDataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary MsgDataTypes {\n    string constant ABORT_PREFIX = \"MSG::ABORT:\";\n\n    // bridge operation type at the sender side (src chain)\n    enum BridgeSendType {\n        Null,\n        Liquidity,\n        PegDeposit,\n        PegBurn,\n        PegV2Deposit,\n        PegV2Burn,\n        PegV2BurnFrom\n    }\n\n    // bridge operation type at the receiver side (dst chain)\n    enum TransferType {\n        Null,\n        LqRelay, // relay through liquidity bridge\n        LqWithdraw, // withdraw from liquidity bridge\n        PegMint, // mint through pegged token bridge\n        PegWithdraw, // withdraw from original token vault\n        PegV2Mint, // mint through pegged token bridge v2\n        PegV2Withdraw // withdraw from original token vault v2\n    }\n\n    enum MsgType {\n        MessageWithTransfer,\n        MessageOnly\n    }\n\n    enum TxStatus {\n        Null,\n        Success,\n        Fail,\n        Fallback,\n        Pending // transient state within a transaction\n    }\n\n    struct TransferInfo {\n        TransferType t;\n        address sender;\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 wdseq; // only needed for LqWithdraw (refund)\n        uint64 srcChainId;\n        bytes32 refId;\n        bytes32 srcTxHash; // src chain msg tx hash\n    }\n\n    struct RouteInfo {\n        address sender;\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash; // src chain msg tx hash\n    }\n\n    // used for msg from non-evm chains with longer-bytes address\n    struct RouteInfo2 {\n        bytes sender;\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash;\n    }\n\n    // combination of RouteInfo and RouteInfo2 for easier processing\n    struct Route {\n        address sender; // from RouteInfo\n        bytes senderBytes; // from RouteInfo2\n        address receiver;\n        uint64 srcChainId;\n        bytes32 srcTxHash;\n    }\n\n    struct MsgWithTransferExecutionParams {\n        bytes message;\n        TransferInfo transfer;\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n\n    struct BridgeTransferParams {\n        bytes request;\n        bytes[] sigs;\n        address[] signers;\n        uint256[] powers;\n    }\n}\n"
    },
    "lib/solady/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC20 + EIP-2612 implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n///\n/// @dev Note:\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\n///   minting and transferring zero tokens, as well as self-approvals.\n///   For performance, this implementation WILL NOT revert for such actions.\n///   Please add any checks with overrides if desired.\n/// - The `permit` function uses the ecrecover precompile (0x1).\n///\n/// If you are overriding:\n/// - NEVER violate the ERC20 invariant:\n///   the total sum of all balances must be equal to `totalSupply()`.\n/// - Check that the overridden function is actually used in the function you want to\n///   change the behavior of. Much of the code has been manually inlined for performance.\nabstract contract ERC20 {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The total supply has overflowed.\n    error TotalSupplyOverflow();\n\n    /// @dev The allowance has overflowed.\n    error AllowanceOverflow();\n\n    /// @dev The allowance has underflowed.\n    error AllowanceUnderflow();\n\n    /// @dev Insufficient balance.\n    error InsufficientBalance();\n\n    /// @dev Insufficient allowance.\n    error InsufficientAllowance();\n\n    /// @dev The permit is invalid.\n    error InvalidPermit();\n\n    /// @dev The permit has expired.\n    error PermitExpired();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STORAGE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The storage slot for the total supply.\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\n\n    /// @dev The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\n\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\n\n    /// @dev The nonce slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\n    /// ```\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 private constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"1\")`.\n    bytes32 private constant _VERSION_HASH =\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       ERC20 METADATA                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the name of the token.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the decimals places of the token.\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           ERC20                            */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the amount of tokens in existence.\n    function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }\n\n    /// @dev Returns the amount of tokens owned by `owner`.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }\n\n    /// @dev Transfer `amount` tokens from the caller to `to`.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    ///\n    /// Emits a {Transfer} event.\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @dev Transfers `amount` tokens from `from` to `to`.\n    ///\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\n    ///\n    /// Requirements:\n    /// - `from` must at least have `amount`.\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the allowance slot and load its value.\n            mstore(0x20, caller())\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          EIP-2612                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev For more performance, override to return the constant value\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\n\n    /// @dev Returns the current nonce for `owner`.\n    /// This value is used to compute the signature for EIP-2612 permit.\n    function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\n    /// authorized by a signed approval by `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), _VERSION_HASH)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Moves `amount` of tokens from `from` to `to`.\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if add(allowance_, 1) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }\n\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\n    ///\n    /// Emits a {Approval} event.\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     HOOKS TO OVERRIDE                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Hook that is called before any transfer of tokens.\n    /// This includes minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /// @dev Hook that is called after any transfer of tokens.\n    /// This includes minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "lib/solady/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success :=\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                mstore(0x34, amount) // Store back the original `amount`.\n                // Retry the approval, reverting upon failure.\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "src/Errors/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nerror AlreadyInitialized();\nerror CannotAuthoriseSelf();\nerror CannotBridgeToSameNetwork();\nerror ContractCallNotAllowed();\nerror CumulativeSlippageTooHigh(uint256 minAmount, uint256 receivedAmount);\nerror ExternalCallFailed();\nerror InformationMismatch();\nerror InsufficientBalance(uint256 required, uint256 balance);\nerror InvalidAmount();\nerror InvalidCallData();\nerror InvalidConfig();\nerror InvalidContract();\nerror InvalidDestinationChain();\nerror InvalidFallbackAddress();\nerror InvalidReceiver();\nerror InvalidSendingToken();\nerror NativeAssetNotSupported();\nerror NativeAssetTransferFailed();\nerror NoSwapDataProvided();\nerror NoSwapFromZeroBalance();\nerror NotAContract();\nerror NotInitialized();\nerror NoTransferToNullAddress();\nerror NullAddrIsNotAnERC20Token();\nerror NullAddrIsNotAValidSpender();\nerror OnlyContractOwner();\nerror RecoveryAddressCannotBeZero();\nerror ReentrancyError();\nerror TokenNotSupported();\nerror UnAuthorized();\nerror UnsupportedChainId(uint256 chainId);\nerror WithdrawFailed();\nerror ZeroAmount();\n"
    },
    "src/Facets/AccessManagerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { CannotAuthoriseSelf } from \"../Errors/GenericErrors.sol\";\n\n/// @title Access Manager Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for managing method level access control\n/// @custom:version 1.0.0\ncontract AccessManagerFacet {\n    /// Events ///\n\n    event ExecutionAllowed(address indexed account, bytes4 indexed method);\n    event ExecutionDenied(address indexed account, bytes4 indexed method);\n\n    /// External Methods ///\n\n    /// @notice Sets whether a specific address can call a method\n    /// @param _selector The method selector to set access for\n    /// @param _executor The address to set method access for\n    /// @param _canExecute Whether or not the address can execute the specified method\n    function setCanExecute(\n        bytes4 _selector,\n        address _executor,\n        bool _canExecute\n    ) external {\n        if (_executor == address(this)) {\n            revert CannotAuthoriseSelf();\n        }\n        LibDiamond.enforceIsContractOwner();\n        _canExecute\n            ? LibAccess.addAccess(_selector, _executor)\n            : LibAccess.removeAccess(_selector, _executor);\n        if (_canExecute) {\n            emit ExecutionAllowed(_executor, _selector);\n        } else {\n            emit ExecutionDenied(_executor, _selector);\n        }\n    }\n\n    /// @notice Check if a method can be executed by a specific address\n    /// @param _selector The method selector to check\n    /// @param _executor The address to check\n    function addressCanExecuteMethod(\n        bytes4 _selector,\n        address _executor\n    ) external view returns (bool) {\n        return LibAccess.accessStorage().execAccess[_selector][_executor];\n    }\n}\n"
    },
    "src/Facets/AcrossFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAcrossSpokePool } from \"../Interfaces/IAcrossSpokePool.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Across Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Across Protocol\n/// @custom:version 2.0.0\ncontract AcrossFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the spoke pool on the source chain.\n    IAcrossSpokePool private immutable spokePool;\n\n    /// @notice The WETH address on the current chain.\n    address private immutable wrappedNative;\n\n    /// Types ///\n\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals.\n    /// @param quoteTimestamp The timestamp associated with the suggested fee.\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid.\n    struct AcrossData {\n        int64 relayerFeePct;\n        uint32 quoteTimestamp;\n        bytes message;\n        uint256 maxCount;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _spokePool The contract address of the spoke pool on the source chain.\n    /// @param _wrappedNative The address of the wrapped native token on the source chain.\n    constructor(IAcrossSpokePool _spokePool, address _wrappedNative) {\n        spokePool = _spokePool;\n        wrappedNative = _wrappedNative;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _acrossData data specific to Across\n    function startBridgeTokensViaAcross(\n        ILiFi.BridgeData memory _bridgeData,\n        AcrossData calldata _acrossData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _acrossData);\n    }\n\n    /// @notice Performs a swap before bridging via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _acrossData data specific to Across\n    function swapAndStartBridgeTokensViaAcross(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AcrossData calldata _acrossData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _acrossData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Across\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _acrossData data specific to Across\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AcrossData calldata _acrossData\n    ) internal {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            spokePool.deposit{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                wrappedNative,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _acrossData.relayerFeePct,\n                _acrossData.quoteTimestamp,\n                _acrossData.message,\n                _acrossData.maxCount\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(spokePool),\n                _bridgeData.minAmount\n            );\n            spokePool.deposit(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _acrossData.relayerFeePct,\n                _acrossData.quoteTimestamp,\n                _acrossData.message,\n                _acrossData.maxCount\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/AcrossFacetPacked.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IAcrossSpokePool } from \"../Interfaces/IAcrossSpokePool.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { AcrossFacet } from \"./AcrossFacet.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { SafeERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { console2 } from \"../../lib/forge-std/src/console2.sol\";\n\n/// @title AcrossFacetPacked\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Across in a gas-optimized way\n/// @custom:version 1.0.0\ncontract AcrossFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    bytes public constant ACROSS_REFERRER_DELIMITER = hex\"d00dfeeddeadbeef\";\n    uint8 private constant ACROSS_REFERRER_ADDRESS_LENGTH = 20;\n    uint256 private constant REFERRER_OFFSET = 28;\n\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    IAcrossSpokePool private immutable spokePool;\n\n    /// @notice The WETH address on the current chain.\n    address private immutable wrappedNative;\n\n    /// Events ///\n\n    event LiFiAcrossTransfer(bytes8 _transactionId);\n    event CallExecutedAndFundsWithdrawn();\n\n    /// Errors ///\n\n    error WithdrawFailed();\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract\n    /// @param _spokePool The contract address of the spoke pool on the source chain\n    /// @param _wrappedNative The address of the wrapped native token on the source chain\n    /// @param _owner The address of the contract owner\n    constructor(\n        IAcrossSpokePool _spokePool,\n        address _wrappedNative,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        spokePool = _spokePool;\n        wrappedNative = _wrappedNative;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Across spoke pool Router to spend the specified token\n    /// @param tokensToApprove The tokens to approve to the Across spoke pool\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        for (uint256 i; i < tokensToApprove.length; i++) {\n            // Give Across spoke pool approval to pull tokens from this facet\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(spokePool),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges native tokens via Across (packed implementation)\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaAcrossNativePacked() external payable {\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = msg.data.length - REFERRER_OFFSET;\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit{ value: msg.value }(\n            address(bytes20(msg.data[12:32])), // receiver\n            wrappedNative, // wrappedNative address\n            msg.value, // minAmount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            int64(uint64(bytes8(msg.data[36:44]))), // int64 relayerFeePct\n            uint32(bytes4(msg.data[44:48])), // uint32 quoteTimestamp\n            msg.data[80:calldataEndsAt], // bytes message (due to variable length positioned at the end of the calldata)\n            uint256(bytes32(msg.data[48:80])) // uint256 maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges native tokens via Across (minimal implementation)\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function startBridgeTokensViaAcrossNativeMin(\n        bytes32 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes calldata message,\n        uint256 maxCount\n    ) external payable {\n        // call Across spoke pool to bridge assets\n        spokePool.deposit{ value: msg.value }(\n            receiver,\n            wrappedNative,\n            msg.value,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message,\n            maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via Across (packed implementation)\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaAcrossERC20Packed() external payable {\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = msg.data.length - REFERRER_OFFSET;\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit(\n            address(bytes20(msg.data[12:32])), // receiver\n            address(bytes20(msg.data[32:52])), // sendingAssetID\n            minAmount,\n            uint64(uint32(bytes4(msg.data[68:72]))), // destinationChainId\n            int64(uint64(bytes8(msg.data[72:80]))), // int64 relayerFeePct\n            uint32(bytes4(msg.data[80:84])), // uint32 quoteTimestamp\n            msg.data[116:calldataEndsAt], // bytes message (due to variable length positioned at the end of the calldata)\n            uint256(bytes32(msg.data[84:116])) // uint256 maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Across (minimal implementation)\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param sendingAssetId The address of the asset/token to be bridged\n    /// @param minAmount The amount to be bridged\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function startBridgeTokensViaAcrossERC20Min(\n        bytes32 transactionId,\n        address sendingAssetId,\n        uint256 minAmount,\n        address receiver,\n        uint64 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes calldata message,\n        uint256 maxCount\n    ) external payable {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Across spoke pool to bridge assets\n        spokePool.deposit(\n            receiver,\n            sendingAssetId,\n            minAmount,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message,\n            maxCount\n        );\n\n        emit LiFiAcrossTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Encodes calldata that can be used to call the native 'packed' function\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function encode_startBridgeTokensViaAcrossNativePacked(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        uint256 maxCount,\n        bytes calldata message\n    ) external pure returns (bytes memory) {\n        // there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPacked\n                    .startBridgeTokensViaAcrossNativePacked\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes8(uint64(relayerFeePct)),\n                bytes4(quoteTimestamp),\n                bytes32(maxCount),\n                message\n            );\n    }\n\n    /// @notice Encodes calldata that can be used to call the ERC20 'packed' function\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId The address of the asset/token to be bridged\n    /// @param minAmount The amount to be bridged\n    /// @param destinationChainId Receiving chain\n    /// @param relayerFeePct The relayer fee in token percentage with 18 decimals\n    /// @param quoteTimestamp The timestamp associated with the suggested fee\n    /// @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens\n    /// @param maxCount Used to protect the depositor from frontrunning to guarantee their quote remains valid\n    function encode_startBridgeTokensViaAcrossERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes calldata message,\n        uint256 maxCount\n    ) external pure returns (bytes memory) {\n        // there are already existing networks with chainIds outside uint32 range but since we not support either of them yet,\n        // we feel comfortable using this approach to save further gas\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                AcrossFacetPacked\n                    .startBridgeTokensViaAcrossERC20Packed\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(uint32(destinationChainId)),\n                bytes8(uint64(relayerFeePct)),\n                bytes4(uint32(quoteTimestamp)),\n                bytes32(maxCount),\n                message\n            );\n    }\n\n    /// @notice Decodes calldata that is meant to be used for calling the native 'packed' function\n    /// @param data the calldata to be decoded\n    function decode_startBridgeTokensViaAcrossNativePacked(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            BridgeData memory bridgeData,\n            AcrossFacet.AcrossData memory acrossData\n        )\n    {\n        require(\n            data.length >= 108,\n            \"invalid calldata (must have length > 108)\"\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = data.length - REFERRER_OFFSET;\n\n        // extract bridgeData\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[32:36])));\n\n        // extract acrossData\n        acrossData.relayerFeePct = int64(uint64(bytes8(data[36:44])));\n        acrossData.quoteTimestamp = uint32(bytes4(data[44:48]));\n        acrossData.maxCount = uint256(bytes32(data[48:80]));\n        acrossData.message = data[80:calldataEndsAt];\n\n        return (bridgeData, acrossData);\n    }\n\n    /// @notice Decodes calldata that is meant to be used for calling the ERC20 'packed' function\n    /// @param data the calldata to be decoded\n    function decode_startBridgeTokensViaAcrossERC20Packed(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            BridgeData memory bridgeData,\n            AcrossFacet.AcrossData memory acrossData\n        )\n    {\n        require(\n            data.length >= 144,\n            \"invalid calldata (must have length > 144)\"\n        );\n\n        // calculate end of calldata (and start of delimiter + referrer address)\n        uint256 calldataEndsAt = data.length - REFERRER_OFFSET;\n\n        bridgeData.transactionId = bytes32(bytes8(data[4:12]));\n        bridgeData.receiver = address(bytes20(data[12:32]));\n        bridgeData.sendingAssetId = address(bytes20(data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(data[52:68])));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(data[68:72])));\n\n        // extract acrossData\n        acrossData.relayerFeePct = int64(uint64(bytes8(data[72:80])));\n        acrossData.quoteTimestamp = uint32(bytes4(data[80:84]));\n        acrossData.maxCount = uint256(bytes32(data[84:116]));\n        acrossData.message = data[116:calldataEndsAt];\n\n        return (bridgeData, acrossData);\n    }\n\n    /// @notice Execute calldata and withdraw asset\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to address to withdraw to\n    /// @param _amount amount of asset to withdraw\n    function executeCallAndWithdraw(\n        address _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        // execute calldata\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _callTo.call(_callData);\n\n        // check success of call\n        if (success) {\n            // call successful - withdraw the asset\n            LibAsset.transferAsset(_assetAddress, payable(_to), _amount);\n            emit CallExecutedAndFundsWithdrawn();\n        } else {\n            // call unsuccessful - revert\n            revert WithdrawFailed();\n        }\n    }\n}\n"
    },
    "src/Facets/AllBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAllBridge } from \"../Interfaces/IAllBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\n/// @title Allbridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through AllBridge\n/// @custom:version 2.0.0\ncontract AllBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// @notice The contract address of the AllBridge router on the source chain.\n    IAllBridge private immutable allBridge;\n\n    /// @notice The struct for the AllBridge data.\n    /// @param fees The amount of token to pay the messenger and the bridge\n    /// @param recipient The address of the token receiver after bridging.\n    /// @param destinationChainId The destination chain id.\n    /// @param receiveToken The token to receive on the destination chain.\n    /// @param nonce A random nonce to associate with the tx.\n    /// @param messenger The messenger protocol enum\n    /// @param payFeeWithSendingAsset Whether to pay the relayer fee with the sending asset or not\n    struct AllBridgeData {\n        uint256 fees;\n        bytes32 recipient;\n        uint256 destinationChainId;\n        bytes32 receiveToken;\n        uint256 nonce;\n        IAllBridge.MessengerProtocol messenger;\n        bool payFeeWithSendingAsset;\n    }\n\n    /// @notice Initializes the AllBridge contract\n    /// @param _allBridge The address of the AllBridge contract\n    constructor(IAllBridge _allBridge) {\n        allBridge = _allBridge;\n    }\n\n    /// @notice Bridge tokens to another chain via AllBridge\n    /// @param _bridgeData The bridge data struct\n    function startBridgeTokensViaAllBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AllBridgeData calldata _allBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _allBridgeData);\n    }\n\n    /// @notice Bridge tokens to another chain via AllBridge\n    /// @param _bridgeData The bridge data struct\n    /// @param _swapData The swap data struct\n    /// @param _allBridgeData The AllBridge data struct\n    function swapAndStartBridgeTokensViaAllBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AllBridgeData calldata _allBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _allBridgeData);\n    }\n\n    /// @notice Bridge tokens to another chain via AllBridge\n    /// @param _bridgeData The bridge data struct\n    /// @param _allBridgeData The allBridge data struct for AllBridge specicific data\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        AllBridgeData calldata _allBridgeData\n    ) internal {\n        LibAsset.maxApproveERC20(\n            IERC20(_bridgeData.sendingAssetId),\n            address(allBridge),\n            _bridgeData.minAmount\n        );\n\n        if (_allBridgeData.payFeeWithSendingAsset) {\n            allBridge.swapAndBridge(\n                bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                _bridgeData.minAmount,\n                _allBridgeData.recipient,\n                _allBridgeData.destinationChainId,\n                _allBridgeData.receiveToken,\n                _allBridgeData.nonce,\n                _allBridgeData.messenger,\n                _allBridgeData.fees\n            );\n        } else {\n            allBridge.swapAndBridge{ value: _allBridgeData.fees }(\n                bytes32(uint256(uint160(_bridgeData.sendingAssetId))),\n                _bridgeData.minAmount,\n                _allBridgeData.recipient,\n                _allBridgeData.destinationChainId,\n                _allBridgeData.receiveToken,\n                _allBridgeData.nonce,\n                _allBridgeData.messenger,\n                0\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/AmarokFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IConnextHandler } from \"../Interfaces/IConnextHandler.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Amarok Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Connext Amarok\n/// @custom:version 3.0.0\ncontract AmarokFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the connext handler on the source chain.\n    IConnextHandler private immutable connextHandler;\n\n    /// @param callData The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\n    /// @param callTo The address of the contract on dest chain that will receive bridged funds and execute data\n    /// @param relayerFee The amount of relayer fee the tx called xcall with\n    /// @param slippageTol Maximum acceptable slippage in BPS. For example, a value of 30 means 0.3% slippage\n    /// @param delegate Destination delegate address\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param payFeeWithSendingAsset Whether to pay the relayer fee with the sending asset or not\n    struct AmarokData {\n        bytes callData;\n        address callTo;\n        uint256 relayerFee;\n        uint256 slippageTol;\n        address delegate;\n        uint32 destChainDomainId;\n        bool payFeeWithSendingAsset;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _connextHandler The contract address of the connext handler on the source chain.\n    constructor(IConnextHandler _connextHandler) {\n        connextHandler = _connextHandler;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Amarok\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _amarokData Data specific to bridge\n    function startBridgeTokensViaAmarok(\n        BridgeData calldata _bridgeData,\n        AmarokData calldata _amarokData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n        noNativeAsset(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _amarokData);\n\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _amarokData);\n    }\n\n    /// @notice Performs a swap before bridging via Amarok\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _amarokData Data specific to Amarok\n    function swapAndStartBridgeTokensViaAmarok(\n        BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        AmarokData calldata _amarokData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n        noNativeAsset(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _amarokData);\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _amarokData.relayerFee\n        );\n\n        _startBridge(_bridgeData, _amarokData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Amarok\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _amarokData Data specific to Amarok\n    function _startBridge(\n        BridgeData memory _bridgeData,\n        AmarokData calldata _amarokData\n    ) private {\n        // ensure that receiver addresses match in case of no destination call\n        if (\n            !_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver != _amarokData.callTo)\n        ) revert InformationMismatch();\n\n        // give max approval for token to Amarok bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(_bridgeData.sendingAssetId),\n            address(connextHandler),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        if (_amarokData.payFeeWithSendingAsset) {\n            connextHandler.xcall(\n                _amarokData.destChainDomainId,\n                _amarokData.callTo,\n                _bridgeData.sendingAssetId,\n                _amarokData.delegate,\n                _bridgeData.minAmount - _amarokData.relayerFee,\n                _amarokData.slippageTol,\n                _amarokData.callData,\n                _amarokData.relayerFee\n            );\n        } else {\n            connextHandler.xcall{ value: _amarokData.relayerFee }(\n                _amarokData.destChainDomainId,\n                _amarokData.callTo,\n                _bridgeData.sendingAssetId,\n                _amarokData.delegate,\n                _bridgeData.minAmount,\n                _amarokData.slippageTol,\n                _amarokData.callData\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        AmarokData calldata _amarokData\n    ) private pure {\n        if (\n            (_amarokData.callData.length > 0) != _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n}\n"
    },
    "src/Facets/AmarokFacetPacked.sol": {
      "content": "// // SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IConnextHandler } from \"../Interfaces/IConnextHandler.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { AmarokFacet } from \"../../src/Facets/AmarokFacet.sol\";\nimport { console2 } from \"../../lib/forge-std/src/console2.sol\";\n\n/// @title AmarokFacetPacked\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Amarok in a gas-optimized way\n/// @custom:version 1.0.0\ncontract AmarokFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage\n\n    /// @notice The contract address of the connext handler on the source chain.\n    IConnextHandler private immutable connextHandler;\n\n    /// Events ///\n\n    event LiFiAmarokTransfer(bytes8 _transactionId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _connextHandler The contract address of the connext handler on the source chain.\n    /// @param _owner The contract owner to approve tokens.\n    constructor(\n        IConnextHandler _connextHandler,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        connextHandler = _connextHandler;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Amarok bridge to spend the specified token\n    /// @param tokensToApprove The tokens to approve to approve to the Amarok bridge\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        uint256 numTokens = tokensToApprove.length;\n\n        for (uint256 i; i < numTokens; i++) {\n            // Give Amarok approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(connextHandler),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges ERC20 tokens via Amarok\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset() external {\n        // extract parameters that are used multiple times in this function\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n        address receiver = address(bytes20(msg.data[12:32]));\n        uint256 relayerFee = uint64(uint32(bytes4(msg.data[76:92])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Amarok bridge\n        connextHandler.xcall(\n            uint32(bytes4(msg.data[68:72])), // _destChainDomainId\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount - relayerFee,\n            uint256(uint128(uint64(uint32(bytes4(msg.data[72:76]))))), // slippageTol\n            \"\", // calldata (not required)\n            relayerFee\n        );\n\n        emit LiFiAmarokTransfer(bytes8(msg.data[4:12]));\n    }\n\n    function startBridgeTokensViaAmarokERC20PackedPayFeeWithNative()\n        external\n        payable\n    {\n        // extract parameters that are used multiple times in this function\n        address sendingAssetId = address(bytes20(msg.data[32:52]));\n        uint256 minAmount = uint256(uint128(bytes16(msg.data[52:68])));\n        address receiver = address(bytes20(msg.data[12:32]));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // call Amarok bridge\n        connextHandler.xcall{ value: msg.value }(\n            uint32(bytes4(msg.data[68:72])), // destChainDomainId\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount,\n            uint256(uint128(uint64(uint32(bytes4(msg.data[72:76]))))), // slippageTol\n            \"\" // calldata (not required)\n        );\n\n        emit LiFiAmarokTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Maximum acceptable slippage in BPS. For example, a value of 30 means 0.3% slippage\n    /// @param relayerFee The amount of relayer fee the tx called xcall with\n    function startBridgeTokensViaAmarokERC20MinPayFeeWithAsset(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol,\n        uint256 relayerFee\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        connextHandler.xcall(\n            destChainDomainId,\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount - relayerFee,\n            slippageTol,\n            \"\", // calldata (not required)\n            relayerFee\n        );\n\n        emit LiFiAmarokTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Maximum acceptable slippage in BPS. For example, a value of 30 means 0.3% slippage\n    function startBridgeTokensViaAmarokERC20MinPayFeeWithNative(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol\n    ) external payable {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        connextHandler.xcall{ value: msg.value }(\n            destChainDomainId,\n            receiver, // _to\n            sendingAssetId,\n            receiver, // _delegate\n            minAmount,\n            slippageTol,\n            \"\" // calldata (not required)\n        );\n\n        emit LiFiAmarokTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Encode call data to bridge ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n    /// @param relayerFee The amount of relayer fee the tx called xcall with\n    function encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol,\n        uint256 relayerFee\n    ) external pure returns (bytes memory) {\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n        require(\n            slippageTol <= type(uint32).max,\n            \"slippageTol value passed too big to fit in uint32\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                AmarokFacetPacked\n                    .startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset\n                    .selector,\n                bytes8(transactionId), // we only use 8 bytes of the 32bytes txId in order to save gas\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(destChainDomainId),\n                bytes4(uint32(slippageTol)),\n                bytes16(uint128(relayerFee))\n            );\n    }\n\n    /// @notice Encode call data to bridge ERC20 tokens via Amarok\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destChainDomainId The Amarok-specific domainId of the destination chain\n    /// @param slippageTol Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n    function encode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative(\n        bytes32 transactionId,\n        address receiver,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint32 destChainDomainId,\n        uint256 slippageTol\n    ) external pure returns (bytes memory) {\n        require(\n            minAmount <= type(uint128).max,\n            \"minAmount value passed too big to fit in uint128\"\n        );\n        require(\n            slippageTol <= type(uint32).max,\n            \"slippageTol value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                AmarokFacetPacked\n                    .startBridgeTokensViaAmarokERC20PackedPayFeeWithNative\n                    .selector,\n                bytes8(transactionId), // we only use 8 bytes of the 32bytes txId in order to save gas\n                bytes20(receiver),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(destChainDomainId),\n                bytes4(uint32(slippageTol))\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithAsset(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, AmarokFacet.AmarokData memory)\n    {\n        require(\n            _data.length >= 92,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        AmarokFacet.AmarokData memory amarokData;\n\n        uint32 destChainDomainId = uint32(bytes4(_data[68:72]));\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = getChainIdForDomain(destChainDomainId);\n        bridgeData.sendingAssetId = address(bytes20(_data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[52:68])));\n\n        amarokData.callData = \"\";\n        amarokData.callTo = bridgeData.receiver;\n        amarokData.destChainDomainId = destChainDomainId;\n        amarokData.slippageTol = uint32(bytes4(_data[72:76]));\n        amarokData.relayerFee = uint256(uint128(bytes16(_data[76:92])));\n        amarokData.delegate = bridgeData.receiver;\n        amarokData.payFeeWithSendingAsset = true;\n\n        return (bridgeData, amarokData);\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaAmarokERC20PackedPayFeeWithNative\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaAmarokERC20PackedPayFeeWithNative(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, AmarokFacet.AmarokData memory)\n    {\n        require(\n            _data.length >= 76,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        AmarokFacet.AmarokData memory amarokData;\n\n        uint32 destChainDomainId = uint32(bytes4(_data[68:72]));\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = getChainIdForDomain(destChainDomainId);\n        bridgeData.sendingAssetId = address(bytes20(_data[32:52]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[52:68])));\n\n        amarokData.callData = \"\";\n        amarokData.callTo = bridgeData.receiver;\n        amarokData.destChainDomainId = destChainDomainId;\n        amarokData.slippageTol = uint256(\n            uint128(uint32(bytes4(_data[72:76])))\n        );\n        amarokData.delegate = bridgeData.receiver;\n        amarokData.payFeeWithSendingAsset = false;\n\n        return (bridgeData, amarokData);\n    }\n\n    function getChainIdForDomain(\n        uint32 domainId\n    ) public pure returns (uint32 chainId) {\n        if (domainId == 6648936) return 1;\n        // ETH\n        else if (domainId == 1886350457) return 137;\n        // POL\n        else if (domainId == 6450786) return 56;\n        // BSC\n        else if (domainId == 1869640809) return 10;\n        // OPT\n        else if (domainId == 6778479) return 100;\n        // GNO/DAI\n        else if (domainId == 1634886255) return 42161;\n        // ARB\n        else if (domainId == 1818848877) return 59144; // LIN\n    }\n}\n"
    },
    "src/Facets/ArbitrumBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IGatewayRouter } from \"../Interfaces/IGatewayRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidAmount } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Arbitrum Bridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Arbitrum Bridge\n/// @custom:version 1.0.0\ncontract ArbitrumBridgeFacet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @notice The contract address of the gateway router on the source chain.\n    IGatewayRouter private immutable gatewayRouter;\n\n    /// @notice The contract address of the inbox on the source chain.\n    IGatewayRouter private immutable inbox;\n\n    /// Types ///\n\n    /// @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee.\n    /// @param maxGas Max gas deducted from user's L2 balance to cover L2 execution.\n    /// @param maxGasPrice price bid for L2 execution.\n    struct ArbitrumData {\n        uint256 maxSubmissionCost;\n        uint256 maxGas;\n        uint256 maxGasPrice;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _gatewayRouter The contract address of the gateway router on the source chain.\n    /// @param _inbox The contract address of the inbox on the source chain.\n    constructor(IGatewayRouter _gatewayRouter, IGatewayRouter _inbox) {\n        gatewayRouter = _gatewayRouter;\n        inbox = _inbox;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Arbitrum Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _arbitrumData Data for gateway router address, asset id and amount\n    function startBridgeTokensViaArbitrumBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        ArbitrumData calldata _arbitrumData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        uint256 cost = _arbitrumData.maxSubmissionCost +\n            _arbitrumData.maxGas *\n            _arbitrumData.maxGasPrice;\n\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _arbitrumData, cost);\n    }\n\n    /// @notice Performs a swap before bridging via Arbitrum Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _arbitrumData Data for gateway router address, asset id and amount\n    function swapAndStartBridgeTokensViaArbitrumBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        ArbitrumData calldata _arbitrumData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        uint256 cost = _arbitrumData.maxSubmissionCost +\n            _arbitrumData.maxGas *\n            _arbitrumData.maxGasPrice;\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            cost\n        );\n\n        _startBridge(_bridgeData, _arbitrumData, cost);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Arbitrum Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _arbitrumData Data for gateway router address, asset id and amount\n    /// @param _cost Additional amount of native asset for the fee\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        ArbitrumData calldata _arbitrumData,\n        uint256 _cost\n    ) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            inbox.unsafeCreateRetryableTicket{\n                value: _bridgeData.minAmount + _cost\n            }(\n                _bridgeData.receiver,\n                _bridgeData.minAmount, // l2CallValue\n                _arbitrumData.maxSubmissionCost,\n                _bridgeData.receiver, // excessFeeRefundAddress\n                _bridgeData.receiver, // callValueRefundAddress\n                _arbitrumData.maxGas,\n                _arbitrumData.maxGasPrice,\n                \"\"\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                gatewayRouter.getGateway(_bridgeData.sendingAssetId),\n                _bridgeData.minAmount\n            );\n            gatewayRouter.outboundTransfer{ value: _cost }(\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _arbitrumData.maxGas,\n                _arbitrumData.maxGasPrice,\n                abi.encode(_arbitrumData.maxSubmissionCost, \"\")\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/CalldataVerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { AmarokFacet } from \"./AmarokFacet.sol\";\nimport { StargateFacet } from \"./StargateFacet.sol\";\nimport { CelerIMFacetBase, CelerIM } from \"../../src/Helpers/CelerIMFacetBase.sol\";\nimport { StandardizedCallFacet } from \"../../src/Facets/StandardizedCallFacet.sol\";\nimport { LibBytes } from \"../Libraries/LibBytes.sol\";\n\n/// @title Calldata Verification Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for verifying calldata\n/// @custom:version 1.1.1\ncontract CalldataVerificationFacet {\n    using LibBytes for bytes;\n\n    /// @notice Extracts the bridge data from the calldata\n    /// @param data The calldata to extract the bridge data from\n    /// @return bridgeData The bridge data extracted from the calldata\n    function extractBridgeData(\n        bytes calldata data\n    ) external pure returns (ILiFi.BridgeData memory bridgeData) {\n        bridgeData = _extractBridgeData(data);\n    }\n\n    /// @notice Extracts the swap data from the calldata\n    /// @param data The calldata to extract the swap data from\n    /// @return swapData The swap data extracted from the calldata\n    function extractSwapData(\n        bytes calldata data\n    ) external pure returns (LibSwap.SwapData[] memory swapData) {\n        swapData = _extractSwapData(data);\n    }\n\n    /// @notice Extracts the bridge data and swap data from the calldata\n    /// @param data The calldata to extract the bridge data and swap data from\n    /// @return bridgeData The bridge data extracted from the calldata\n    /// @return swapData The swap data extracted from the calldata\n    function extractData(\n        bytes calldata data\n    )\n        external\n        pure\n        returns (\n            ILiFi.BridgeData memory bridgeData,\n            LibSwap.SwapData[] memory swapData\n        )\n    {\n        bridgeData = _extractBridgeData(data);\n        if (bridgeData.hasSourceSwaps) {\n            swapData = _extractSwapData(data);\n        }\n    }\n\n    /// @notice Extracts the main parameters from the calldata\n    /// @param data The calldata to extract the main parameters from\n    /// @return bridge The bridge extracted from the calldata\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return amount The min amountfrom the calldata\n    /// @return destinationChainId The destination chain id extracted from the calldata\n    /// @return hasSourceSwaps Whether the calldata has source swaps\n    /// @return hasDestinationCall Whether the calldata has a destination call\n    function extractMainParameters(\n        bytes calldata data\n    )\n        public\n        pure\n        returns (\n            string memory bridge,\n            address sendingAssetId,\n            address receiver,\n            uint256 amount,\n            uint256 destinationChainId,\n            bool hasSourceSwaps,\n            bool hasDestinationCall\n        )\n    {\n        ILiFi.BridgeData memory bridgeData = _extractBridgeData(data);\n\n        if (bridgeData.hasSourceSwaps) {\n            LibSwap.SwapData[] memory swapData = _extractSwapData(data);\n            sendingAssetId = swapData[0].sendingAssetId;\n            amount = swapData[0].fromAmount;\n        } else {\n            sendingAssetId = bridgeData.sendingAssetId;\n            amount = bridgeData.minAmount;\n        }\n\n        return (\n            bridgeData.bridge,\n            sendingAssetId,\n            bridgeData.receiver,\n            amount,\n            bridgeData.destinationChainId,\n            bridgeData.hasSourceSwaps,\n            bridgeData.hasDestinationCall\n        );\n    }\n\n    // @notice Extracts the non-EVM address from the calldata\n    // @param data The calldata to extract the non-EVM address from\n    // @return nonEVMAddress The non-EVM address extracted from the calldata\n    function extractNonEVMAddress(\n        bytes calldata data\n    ) external pure returns (bytes32 nonEVMAddress) {\n        bytes memory callData = data;\n        ILiFi.BridgeData memory bridgeData = _extractBridgeData(data);\n\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // standardizedCall\n            callData = abi.decode(data[4:], (bytes));\n        }\n\n        // Non-EVM address is always the first parameter of bridge specific data\n        if (bridgeData.hasSourceSwaps) {\n            assembly {\n                let offset := mload(add(callData, 0x64)) // Get the offset of the bridge specific data\n                nonEVMAddress := mload(add(callData, add(offset, 0x24))) // Get the non-EVM address\n            }\n        } else {\n            assembly {\n                let offset := mload(add(callData, 0x44)) // Get the offset of the bridge specific data\n                nonEVMAddress := mload(add(callData, add(offset, 0x24))) // Get the non-EVM address\n            }\n        }\n    }\n\n    /// @notice Extracts the generic swap parameters from the calldata\n    /// @param data The calldata to extract the generic swap parameters from\n    /// @return sendingAssetId The sending asset id extracted from the calldata\n    /// @return amount The amount extracted from the calldata\n    /// @return receiver The receiver extracted from the calldata\n    /// @return receivingAssetId The receiving asset id extracted from the calldata\n    /// @return receivingAmount The receiving amount extracted from the calldata\n    function extractGenericSwapParameters(\n        bytes calldata data\n    )\n        public\n        pure\n        returns (\n            address sendingAssetId,\n            uint256 amount,\n            address receiver,\n            address receivingAssetId,\n            uint256 receivingAmount\n        )\n    {\n        LibSwap.SwapData[] memory swapData;\n        bytes memory callData = data;\n\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // standardizedCall\n            callData = abi.decode(data[4:], (bytes));\n        }\n        (, , , receiver, receivingAmount, swapData) = abi.decode(\n            callData.slice(4, callData.length - 4),\n            (bytes32, string, string, address, uint256, LibSwap.SwapData[])\n        );\n\n        sendingAssetId = swapData[0].sendingAssetId;\n        amount = swapData[0].fromAmount;\n        receivingAssetId = swapData[swapData.length - 1].receivingAssetId;\n        return (\n            sendingAssetId,\n            amount,\n            receiver,\n            receivingAssetId,\n            receivingAmount\n        );\n    }\n\n    /// @notice Validates the calldata\n    /// @param data The calldata to validate\n    /// @param bridge The bridge to validate or empty string to ignore\n    /// @param sendingAssetId The sending asset id to validate\n    ///        or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF to ignore\n    /// @param receiver The receiver to validate\n    ///        or 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF to ignore\n    /// @param amount The amount to validate or type(uint256).max to ignore\n    /// @param destinationChainId The destination chain id to validate\n    ///        or type(uint256).max to ignore\n    /// @param hasSourceSwaps Whether the calldata has source swaps\n    /// @param hasDestinationCall Whether the calldata has a destination call\n    /// @return isValid Whether the calldata is validate\n    function validateCalldata(\n        bytes calldata data,\n        string calldata bridge,\n        address sendingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 destinationChainId,\n        bool hasSourceSwaps,\n        bool hasDestinationCall\n    ) external pure returns (bool isValid) {\n        ILiFi.BridgeData memory bridgeData;\n        (\n            bridgeData.bridge,\n            bridgeData.sendingAssetId,\n            bridgeData.receiver,\n            bridgeData.minAmount,\n            bridgeData.destinationChainId,\n            bridgeData.hasSourceSwaps,\n            bridgeData.hasDestinationCall\n        ) = extractMainParameters(data);\n        return\n            // Check bridge\n            (keccak256(abi.encodePacked(bridge)) ==\n                keccak256(abi.encodePacked(\"\")) ||\n                keccak256(abi.encodePacked(bridgeData.bridge)) ==\n                keccak256(abi.encodePacked(bridge))) &&\n            // Check sendingAssetId\n            (sendingAssetId == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.sendingAssetId == sendingAssetId) &&\n            // Check receiver\n            (receiver == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                bridgeData.receiver == receiver) &&\n            // Check amount\n            (amount == type(uint256).max || bridgeData.minAmount == amount) &&\n            // Check destinationChainId\n            (destinationChainId == type(uint256).max ||\n                bridgeData.destinationChainId == destinationChainId) &&\n            // Check hasSourceSwaps\n            bridgeData.hasSourceSwaps == hasSourceSwaps &&\n            // Check hasDestinationCall\n            bridgeData.hasDestinationCall == hasDestinationCall;\n    }\n\n    /// @notice Validates the destination calldata\n    /// @param data The calldata to validate\n    /// @param callTo The call to address to validate\n    /// @param dstCalldata The destination calldata to validate\n    /// @return isValid Whether the destination calldata is validate\n    function validateDestinationCalldata(\n        bytes calldata data,\n        bytes calldata callTo,\n        bytes calldata dstCalldata\n    ) external pure returns (bool isValid) {\n        bytes memory callData = data;\n\n        // Handle standardizedCall\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            callData = abi.decode(data[4:], (bytes));\n        }\n\n        bytes4 selector = abi.decode(callData, (bytes4));\n\n        // Case: Amarok\n        if (selector == AmarokFacet.startBridgeTokensViaAmarok.selector) {\n            (, AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, AmarokFacet.AmarokData)\n            );\n\n            return\n                keccak256(dstCalldata) == keccak256(amarokData.callData) &&\n                abi.decode(callTo, (address)) == amarokData.callTo;\n        }\n        if (\n            selector == AmarokFacet.swapAndStartBridgeTokensViaAmarok.selector\n        ) {\n            (, , AmarokFacet.AmarokData memory amarokData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], AmarokFacet.AmarokData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(amarokData.callData) &&\n                abi.decode(callTo, (address)) == amarokData.callTo;\n        }\n\n        // Case: Stargate\n        if (selector == StargateFacet.startBridgeTokensViaStargate.selector) {\n            (, StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, StargateFacet.StargateData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(stargateData.callData) &&\n                keccak256(callTo) == keccak256(stargateData.callTo);\n        }\n        if (\n            selector ==\n            StargateFacet.swapAndStartBridgeTokensViaStargate.selector\n        ) {\n            (, , StargateFacet.StargateData memory stargateData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (\n                    ILiFi.BridgeData,\n                    LibSwap.SwapData[],\n                    StargateFacet.StargateData\n                )\n            );\n            return\n                keccak256(dstCalldata) == keccak256(stargateData.callData) &&\n                keccak256(callTo) == keccak256(stargateData.callTo);\n        }\n        // Case: Celer\n        if (\n            selector == CelerIMFacetBase.startBridgeTokensViaCelerIM.selector\n        ) {\n            (, CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, CelerIM.CelerIMData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(celerIMData.callData) &&\n                keccak256(callTo) == keccak256(celerIMData.callTo);\n        }\n        if (\n            selector ==\n            CelerIMFacetBase.swapAndStartBridgeTokensViaCelerIM.selector\n        ) {\n            (, , CelerIM.CelerIMData memory celerIMData) = abi.decode(\n                callData.slice(4, callData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[], CelerIM.CelerIMData)\n            );\n            return\n                keccak256(dstCalldata) == keccak256(celerIMData.callData) &&\n                keccak256(callTo) == keccak256(celerIMData.callTo);\n        }\n\n        // All other cases\n        return false;\n    }\n\n    /// Internal Methods ///\n\n    /// @notice Extracts the bridge data from the calldata\n    /// @param data The calldata to extract the bridge data from\n    /// @return bridgeData The bridge data extracted from the calldata\n    function _extractBridgeData(\n        bytes calldata data\n    ) internal pure returns (ILiFi.BridgeData memory bridgeData) {\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // StandardizedCall\n            bytes memory unwrappedData = abi.decode(data[4:], (bytes));\n            bridgeData = abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData)\n            );\n            return bridgeData;\n        }\n        // normal call\n        bridgeData = abi.decode(data[4:], (ILiFi.BridgeData));\n    }\n\n    /// @notice Extracts the swap data from the calldata\n    /// @param data The calldata to extract the swap data from\n    /// @return swapData The swap data extracted from the calldata\n    function _extractSwapData(\n        bytes calldata data\n    ) internal pure returns (LibSwap.SwapData[] memory swapData) {\n        if (\n            bytes4(data[:4]) == StandardizedCallFacet.standardizedCall.selector\n        ) {\n            // standardizedCall\n            bytes memory unwrappedData = abi.decode(data[4:], (bytes));\n            (, swapData) = abi.decode(\n                unwrappedData.slice(4, unwrappedData.length - 4),\n                (ILiFi.BridgeData, LibSwap.SwapData[])\n            );\n            return swapData;\n        }\n        // normal call\n        (, swapData) = abi.decode(\n            data[4:],\n            (ILiFi.BridgeData, LibSwap.SwapData[])\n        );\n    }\n}\n"
    },
    "src/Facets/CBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { CannotBridgeToSameNetwork } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { ContractCallNotAllowed, ExternalCallFailed } from \"../Errors/GenericErrors.sol\";\n\n/// @title CBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CBridge\n/// @custom:version 1.0.0\ncontract CBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    ICBridge private immutable cBridge;\n\n    /// Types ///\n\n    /// @param maxSlippage The max slippage accepted, given as percentage in point (pip).\n    /// @param nonce A number input to guarantee uniqueness of transferId.\n    ///              Can be timestamp in practice.\n    struct CBridgeData {\n        uint32 maxSlippage;\n        uint64 nonce;\n    }\n\n    /// Events ///\n    event CBridgeRefund(\n        address indexed _assetAddress,\n        address indexed _to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _cBridge The contract address of the cbridge on the source chain.\n    constructor(ICBridge _cBridge) {\n        cBridge = _cBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _cBridgeData data specific to CBridge\n    function startBridgeTokensViaCBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        CBridgeData calldata _cBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _cBridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via CBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _cBridgeData data specific to CBridge\n    function swapAndStartBridgeTokensViaCBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData calldata _cBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _cBridgeData);\n    }\n\n    /// @notice Triggers a cBridge refund with calldata produced by cBridge API\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to Address to withdraw to\n    /// @param _amount Amount of asset to withdraw\n    function triggerRefund(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        // make sure that callTo address is either of the cBridge addresses\n        if (address(cBridge) != _callTo) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        bool success;\n        (success, ) = _callTo.call(_callData);\n        if (!success) {\n            revert ExternalCallFailed();\n        }\n\n        // forward funds to _to address and emit event\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit CBridgeRefund(_assetAddress, sendTo, _amount);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _cBridgeData data specific to CBridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        CBridgeData calldata _cBridgeData\n    ) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            cBridge.sendNative{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(cBridge),\n                _bridgeData.minAmount\n            );\n            // solhint-disable check-send-result\n            cBridge.send(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/CBridgeFacetPacked.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { CBridgeFacet } from \"./CBridgeFacet.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ContractCallNotAllowed, ExternalCallFailed } from \"../Errors/GenericErrors.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title CBridge Facet Packed\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CBridge\n/// @custom:version 1.0.3\ncontract CBridgeFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage ///\n\n    /// @notice The contract address of the cbridge on the source chain.\n    ICBridge private immutable cBridge;\n\n    /// Events ///\n\n    event LiFiCBridgeTransfer(bytes8 _transactionId);\n\n    event CBridgeRefund(\n        address indexed _assetAddress,\n        address indexed _to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _cBridge The contract address of the cbridge on the source chain.\n    constructor(\n        ICBridge _cBridge,\n        address _owner\n    ) TransferrableOwnership(_owner) {\n        cBridge = _cBridge;\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the CBridge Router to spend the specified token\n    /// @param tokensToApprove The tokens to approve to the CBridge Router\n    function setApprovalForBridge(\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        for (uint256 i; i < tokensToApprove.length; i++) {\n            // Give CBridge approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(cBridge),\n                type(uint256).max\n            );\n        }\n    }\n\n    // This is needed to receive native asset if a refund asset is a native asset\n    receive() external payable {}\n\n    /// @notice Triggers a cBridge refund with calldata produced by cBridge API\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to Address to withdraw to\n    /// @param _amount Amount of asset to withdraw\n    function triggerRefund(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        // make sure that callTo address is either of the cBridge addresses\n        if (address(cBridge) != _callTo) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        bool success;\n        (success, ) = _callTo.call(_callData);\n        if (!success) {\n            revert ExternalCallFailed();\n        }\n\n        // forward funds to _to address and emit event\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit CBridgeRefund(_assetAddress, sendTo, _amount);\n    }\n\n    /// @notice Bridges Native tokens via cBridge (packed)\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaCBridgeNativePacked() external payable {\n        cBridge.sendNative{ value: msg.value }(\n            address(bytes20(msg.data[12:32])), // receiver\n            msg.value, // amount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            uint64(uint32(bytes4(msg.data[36:40]))), // nonce\n            uint32(bytes4(msg.data[40:44])) // maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(msg.data[4:12])); // transactionId\n    }\n\n    /// @notice Bridges native tokens via cBridge\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param nonce A number input to guarantee uniqueness of transferId.\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function startBridgeTokensViaCBridgeNativeMin(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external payable {\n        cBridge.sendNative{ value: msg.value }(\n            receiver,\n            msg.value,\n            destinationChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(transactionId));\n    }\n\n    /// @notice Bridges ERC20 tokens via cBridge\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaCBridgeERC20Packed() external {\n        address sendingAssetId = address(bytes20(msg.data[36:56]));\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        cBridge.send(\n            address(bytes20(msg.data[12:32])), // receiver\n            sendingAssetId, // sendingAssetId\n            amount, // amount\n            uint64(uint32(bytes4(msg.data[32:36]))), // destinationChainId\n            uint64(uint32(bytes4(msg.data[72:76]))), // nonce\n            uint32(bytes4(msg.data[76:80])) // maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via cBridge\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param amount Amount of the source asset to bridge\n    /// @param nonce A number input to guarantee uniqueness of transferId\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function startBridgeTokensViaCBridgeERC20Min(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        address sendingAssetId,\n        uint256 amount,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        cBridge.send(\n            receiver,\n            sendingAssetId,\n            amount,\n            destinationChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit LiFiCBridgeTransfer(bytes8(transactionId));\n    }\n\n    /// Encoder/Decoders ///\n\n    /// @notice Encodes calldata for startBridgeTokensViaCBridgeNativePacked\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param nonce A number input to guarantee uniqueness of transferId.\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function encode_startBridgeTokensViaCBridgeNativePacked(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            nonce <= type(uint32).max,\n            \"nonce value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                CBridgeFacetPacked\n                    .startBridgeTokensViaCBridgeNativePacked\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes4(uint32(nonce)),\n                bytes4(maxSlippage)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaCBridgeNativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaCBridgeNativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, CBridgeFacet.CBridgeData memory)\n    {\n        require(\n            _data.length >= 44,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        CBridgeFacet.CBridgeData memory cBridgeData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(_data[32:36])));\n        cBridgeData.nonce = uint64(uint32(bytes4(_data[36:40])));\n        cBridgeData.maxSlippage = uint32(bytes4(_data[40:44]));\n\n        return (bridgeData, cBridgeData);\n    }\n\n    /// @notice Encodes calldata for startBridgeTokensViaCBridgeERC20Packed\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param nonce A number input to guarantee uniqueness of transferId\n    /// @param maxSlippage Destination swap minimal accepted amount\n    function encode_startBridgeTokensViaCBridgeERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        uint64 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            nonce <= type(uint32).max,\n            \"nonce value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                CBridgeFacetPacked\n                    .startBridgeTokensViaCBridgeERC20Packed\n                    .selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes4(uint32(nonce)),\n                bytes4(maxSlippage)\n            );\n    }\n\n    function decode_startBridgeTokensViaCBridgeERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, CBridgeFacet.CBridgeData memory)\n    {\n        require(_data.length >= 80, \"data passed is not the correct length\");\n\n        BridgeData memory bridgeData;\n        CBridgeFacet.CBridgeData memory cBridgeData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint64(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        cBridgeData.nonce = uint64(uint32(bytes4(_data[72:76])));\n        cBridgeData.maxSlippage = uint32(bytes4(_data[76:80]));\n\n        return (bridgeData, cBridgeData);\n    }\n}\n"
    },
    "src/Facets/CelerCircleBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICircleBridgeProxy } from \"../Interfaces/ICircleBridgeProxy.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title CelerCircleBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CelerCircleBridge\n/// @custom:version 1.0.1\ncontract CelerCircleBridgeFacet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @notice The address of the CircleBridgeProxy on the current chain.\n    ICircleBridgeProxy private immutable circleBridgeProxy;\n\n    /// @notice The USDC address on the current chain.\n    address private immutable usdc;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _circleBridgeProxy The address of the CircleBridgeProxy on the current chain.\n    /// @param _usdc The address of USDC on the current chain.\n    constructor(ICircleBridgeProxy _circleBridgeProxy, address _usdc) {\n        circleBridgeProxy = _circleBridgeProxy;\n        usdc = _usdc;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CelerCircleBridge\n    /// @param _bridgeData Data containing core information for bridging\n    function startBridgeTokensViaCelerCircleBridge(\n        BridgeData calldata _bridgeData\n    )\n        external\n        nonReentrant\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        LibAsset.depositAsset(usdc, _bridgeData.minAmount);\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via CelerCircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaCelerCircleBridge(\n        BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CelerCircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    function _startBridge(BridgeData memory _bridgeData) private {\n        require(\n            _bridgeData.destinationChainId <= type(uint64).max,\n            \"_bridgeData.destinationChainId passed is too big to fit in uint64\"\n        );\n\n        // give max approval for token to CelerCircleBridge bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(usdc),\n            address(circleBridgeProxy),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        circleBridgeProxy.depositForBurn(\n            _bridgeData.minAmount,\n            uint64(_bridgeData.destinationChainId),\n            bytes32(uint256(uint160(_bridgeData.receiver))),\n            usdc\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/CelerIMFacetImmutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { CelerIMFacetBase, IMessageBus, MsgDataTypes, IERC20, CelerIM } from \"../Helpers/CelerIMFacetBase.sol\";\n\n/// @title CelerIMFacetImmutable\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging tokens and data through CBridge\n/// @notice This contract is exclusively used for immutable diamond contracts\n/// @custom:version 2.0.0\ncontract CelerIMFacetImmutable is CelerIMFacetBase {\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _messageBus The contract address of the cBridge Message Bus\n    /// @param _relayerOwner The address that will become the owner of the RelayerCelerIM contract\n    /// @param _diamondAddress The address of the diamond contract that will be connected with the RelayerCelerIM\n    /// @param _cfUSDC The contract address of the Celer Flow USDC\n    constructor(\n        IMessageBus _messageBus,\n        address _relayerOwner,\n        address _diamondAddress,\n        address _cfUSDC\n    ) CelerIMFacetBase(_messageBus, _relayerOwner, _diamondAddress, _cfUSDC) {}\n}\n"
    },
    "src/Facets/CelerIMFacetMutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { CelerIMFacetBase, IMessageBus, MsgDataTypes, IERC20, CelerIM } from \"../Helpers/CelerIMFacetBase.sol\";\n\n/// @title CelerIMFacetMutable\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging tokens and data through CBridge\n/// @notice This contract is exclusively used for mutable diamond contracts\n/// @custom:version 2.0.0\ncontract CelerIMFacetMutable is CelerIMFacetBase {\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _messageBus The contract address of the cBridge Message Bus\n    /// @param _relayerOwner The address that will become the owner of the RelayerCelerIM contract\n    /// @param _diamondAddress The address of the diamond contract that will be connected with the RelayerCelerIM\n    /// @param _cfUSDC The contract address of the Celer Flow USDC\n    constructor(\n        IMessageBus _messageBus,\n        address _relayerOwner,\n        address _diamondAddress,\n        address _cfUSDC\n    ) CelerIMFacetBase(_messageBus, _relayerOwner, _diamondAddress, _cfUSDC) {}\n}\n"
    },
    "src/Facets/CircleBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ITokenMessenger } from \"../Interfaces/ITokenMessenger.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title CircleBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through CircleBridge\n/// @custom:version 1.0.0\ncontract CircleBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The address of the TokenMessenger on the source chain.\n    ITokenMessenger private immutable tokenMessenger;\n\n    /// @notice The USDC address on the source chain.\n    address private immutable usdc;\n\n    /// @param dstDomain The CircleBridge-specific domainId of the destination chain\n    struct CircleBridgeData {\n        uint32 dstDomain;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _tokenMessenger The address of the TokenMessenger on the source chain.\n    /// @param _usdc The address of USDC on the source chain.\n    constructor(ITokenMessenger _tokenMessenger, address _usdc) {\n        tokenMessenger = _tokenMessenger;\n        usdc = _usdc;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CircleBridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _circleBridgeData Data specific to bridge\n    function startBridgeTokensViaCircleBridge(\n        BridgeData calldata _bridgeData,\n        CircleBridgeData calldata _circleBridgeData\n    )\n        external\n        nonReentrant\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        LibAsset.depositAsset(usdc, _bridgeData.minAmount);\n        _startBridge(_bridgeData, _circleBridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via CircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _circleBridgeData Data specific to CircleBridge\n    function swapAndStartBridgeTokensViaCircleBridge(\n        BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        CircleBridgeData calldata _circleBridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowSourceToken(_bridgeData, usdc)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _circleBridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CircleBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _circleBridgeData Data specific to CircleBridge\n    function _startBridge(\n        BridgeData memory _bridgeData,\n        CircleBridgeData calldata _circleBridgeData\n    ) private {\n        // give max approval for token to CircleBridge bridge, if not already\n        LibAsset.maxApproveERC20(\n            IERC20(usdc),\n            address(tokenMessenger),\n            _bridgeData.minAmount\n        );\n\n        // initiate bridge transaction\n        tokenMessenger.depositForBurn(\n            _bridgeData.minAmount,\n            _circleBridgeData.dstDomain,\n            bytes32(uint256(uint160(_bridgeData.receiver))),\n            usdc\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/DexManagerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { LibAllowList } from \"../Libraries/LibAllowList.sol\";\nimport { CannotAuthoriseSelf } from \"../Errors/GenericErrors.sol\";\n\n/// @title Dex Manager Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Facet contract for managing approved DEXs to be used in swaps.\n/// @custom:version 1.0.1\ncontract DexManagerFacet {\n    /// Events ///\n\n    event DexAdded(address indexed dexAddress);\n    event DexRemoved(address indexed dexAddress);\n    event FunctionSignatureApprovalChanged(\n        bytes4 indexed functionSignature,\n        bool indexed approved\n    );\n\n    /// External Methods ///\n\n    /// @notice Register the address of a DEX contract to be approved for swapping.\n    /// @param _dex The address of the DEX contract to be approved.\n    function addDex(address _dex) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        LibAllowList.addAllowedContract(_dex);\n\n        emit DexAdded(_dex);\n    }\n\n    /// @notice Batch register the address of DEX contracts to be approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be approved.\n    function batchAddDex(address[] calldata _dexs) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _dexs.length;\n\n        for (uint256 i = 0; i < length; ) {\n            address dex = _dexs[i];\n            if (dex == address(this)) {\n                revert CannotAuthoriseSelf();\n            }\n            if (LibAllowList.contractIsAllowed(dex)) continue;\n            LibAllowList.addAllowedContract(dex);\n            emit DexAdded(dex);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Unregister the address of a DEX contract approved for swapping.\n    /// @param _dex The address of the DEX contract to be unregistered.\n    function removeDex(address _dex) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        LibAllowList.removeAllowedContract(_dex);\n        emit DexRemoved(_dex);\n    }\n\n    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be unregistered.\n    function batchRemoveDex(address[] calldata _dexs) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _dexs.length;\n        for (uint256 i = 0; i < length; ) {\n            LibAllowList.removeAllowedContract(_dexs[i]);\n            emit DexRemoved(_dexs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Adds/removes a specific function signature to/from the allowlist\n    /// @param _signature the function signature to allow/disallow\n    /// @param _approval whether the function signature should be allowed\n    function setFunctionApprovalBySignature(\n        bytes4 _signature,\n        bool _approval\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        if (_approval) {\n            LibAllowList.addAllowedSelector(_signature);\n        } else {\n            LibAllowList.removeAllowedSelector(_signature);\n        }\n\n        emit FunctionSignatureApprovalChanged(_signature, _approval);\n    }\n\n    /// @notice Batch Adds/removes a specific function signature to/from the allowlist\n    /// @param _signatures the function signatures to allow/disallow\n    /// @param _approval whether the function signatures should be allowed\n    function batchSetFunctionApprovalBySignature(\n        bytes4[] calldata _signatures,\n        bool _approval\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        uint256 length = _signatures.length;\n        for (uint256 i = 0; i < length; ) {\n            bytes4 _signature = _signatures[i];\n            if (_approval) {\n                LibAllowList.addAllowedSelector(_signature);\n            } else {\n                LibAllowList.removeAllowedSelector(_signature);\n            }\n            emit FunctionSignatureApprovalChanged(_signature, _approval);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns whether a function signature is approved\n    /// @param _signature the function signature to query\n    /// @return approved Approved or not\n    function isFunctionApproved(\n        bytes4 _signature\n    ) public view returns (bool approved) {\n        return LibAllowList.selectorIsAllowed(_signature);\n    }\n\n    /// @notice Returns a list of all approved DEX addresses.\n    /// @return addresses List of approved DEX addresses\n    function approvedDexs()\n        external\n        view\n        returns (address[] memory addresses)\n    {\n        return LibAllowList.getAllowedContracts();\n    }\n}\n"
    },
    "src/Facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IDiamondCut } from \"../Interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Diamond Cut Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Core EIP-2535 Facet for upgrading Diamond Proxies.\n/// @custom:version 1.0.0\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n}\n"
    },
    "src/Facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../Interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../Interfaces/IERC165.sol\";\n\n/// @title Diamond Loupe Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Core EIP-2535 Facet for inspecting Diamond Proxies.\n/// @custom:version 1.0.0\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i = 0; i < numFacets; ) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds\n                .facetFunctionSelectors[facetAddress_]\n                .functionSelectors;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    )\n        external\n        view\n        override\n        returns (bytes4[] memory facetFunctionSelectors_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds\n            .facetFunctionSelectors[_facet]\n            .functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view override returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds\n            .selectorToFacetAndPosition[_functionSelector]\n            .facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view override returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "src/Facets/GenericSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { InvalidReceiver } from \"../Errors/GenericErrors.sol\";\n\n/// @title GenericSwapFacet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for swapping through ANY APPROVED DEX\n/// @dev Uses calldata to execute APPROVED arbitrary methods on DEXs\n/// @custom:version 1.0.0\ncontract GenericSwapFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// External Methods ///\n\n    /// @notice Performs multiple swaps in one transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensGeneric(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swapData\n    ) external payable nonReentrant refundExcessNative(_receiver) {\n        if (LibUtil.isZeroAddress(_receiver)) {\n            revert InvalidReceiver();\n        }\n\n        uint256 postSwapBalance = _depositAndSwap(\n            _transactionId,\n            _minAmount,\n            _swapData,\n            _receiver\n        );\n        address receivingAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        LibAsset.transferAsset(receivingAssetId, _receiver, postSwapBalance);\n\n        emit LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _swapData[0].sendingAssetId,\n            receivingAssetId,\n            _swapData[0].fromAmount,\n            postSwapBalance\n        );\n    }\n}\n"
    },
    "src/Facets/GenericSwapFacetV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAllowList } from \"../Libraries/LibAllowList.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ContractCallNotAllowed, CumulativeSlippageTooHigh, NativeAssetTransferFailed } from \"../Errors/GenericErrors.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\n\n/// @title GenericSwapFacetV3\n/// @author LI.FI (https://li.fi)\n/// @notice Provides gas-optimized functionality for fee collection and for swapping through any APPROVED DEX\n/// @dev Can only execute calldata for APPROVED function selectors\n/// @custom:version 1.0.1\ncontract GenericSwapFacetV3 is ILiFi {\n    using SafeTransferLib for ERC20;\n\n    /// Storage\n    address public immutable NATIVE_ADDRESS;\n\n    /// Constructor\n    /// @param _nativeAddress the address of the native token for this network\n    constructor(address _nativeAddress) {\n        NATIVE_ADDRESS = _nativeAddress;\n    }\n\n    /// External Methods ///\n\n    // SINGLE SWAPS\n\n    /// @notice Performs a single swap from an ERC20 token to another ERC20 token\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensSingleV3ERC20ToERC20(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData calldata _swapData\n    ) external {\n        _depositAndSwapERC20Single(_swapData, _receiver);\n\n        address receivingAssetId = _swapData.receivingAssetId;\n        address sendingAssetId = _swapData.sendingAssetId;\n\n        // get contract's balance (which will be sent in full to user)\n        uint256 amountReceived = ERC20(receivingAssetId).balanceOf(\n            address(this)\n        );\n\n        // ensure that minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        ERC20(receivingAssetId).safeTransfer(_receiver, amountReceived);\n\n        // emit events (both required for tracking)\n        uint256 fromAmount = _swapData.fromAmount;\n        emit LibSwap.AssetSwapped(\n            _transactionId,\n            _swapData.callTo,\n            sendingAssetId,\n            receivingAssetId,\n            fromAmount,\n            amountReceived,\n            block.timestamp\n        );\n\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            sendingAssetId,\n            receivingAssetId,\n            fromAmount,\n            amountReceived\n        );\n    }\n\n    /// @notice Performs a single swap from an ERC20 token to the network's native token\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensSingleV3ERC20ToNative(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData calldata _swapData\n    ) external {\n        _depositAndSwapERC20Single(_swapData, _receiver);\n\n        // get contract's balance (which will be sent in full to user)\n        uint256 amountReceived = address(this).balance;\n\n        // ensure that minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _receiver.call{ value: amountReceived }(\"\");\n        if (!success) revert NativeAssetTransferFailed();\n\n        // emit events (both required for tracking)\n        address sendingAssetId = _swapData.sendingAssetId;\n        uint256 fromAmount = _swapData.fromAmount;\n        emit LibSwap.AssetSwapped(\n            _transactionId,\n            _swapData.callTo,\n            sendingAssetId,\n            NATIVE_ADDRESS,\n            fromAmount,\n            amountReceived,\n            block.timestamp\n        );\n\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            sendingAssetId,\n            NATIVE_ADDRESS,\n            fromAmount,\n            amountReceived\n        );\n    }\n\n    /// @notice Performs a single swap from the network's native token to ERC20 token\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensSingleV3NativeToERC20(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData calldata _swapData\n    ) external payable {\n        address callTo = _swapData.callTo;\n        // ensure that contract (callTo) and function selector are whitelisted\n        if (\n            !(LibAllowList.contractIsAllowed(callTo) &&\n                LibAllowList.selectorIsAllowed(bytes4(_swapData.callData[:4])))\n        ) revert ContractCallNotAllowed();\n\n        // execute swap\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = callTo.call{ value: msg.value }(\n            _swapData.callData\n        );\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n\n        _returnPositiveSlippageNative(_receiver);\n\n        // get contract's balance (which will be sent in full to user)\n        address receivingAssetId = _swapData.receivingAssetId;\n        uint256 amountReceived = ERC20(receivingAssetId).balanceOf(\n            address(this)\n        );\n\n        // ensure that minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        ERC20(receivingAssetId).safeTransfer(_receiver, amountReceived);\n\n        // emit events (both required for tracking)\n        uint256 fromAmount = _swapData.fromAmount;\n        emit LibSwap.AssetSwapped(\n            _transactionId,\n            callTo,\n            NATIVE_ADDRESS,\n            receivingAssetId,\n            fromAmount,\n            amountReceived,\n            block.timestamp\n        );\n\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            NATIVE_ADDRESS,\n            receivingAssetId,\n            fromAmount,\n            amountReceived\n        );\n    }\n\n    // MULTIPLE SWAPS\n\n    /// @notice Performs multiple swaps in one transaction, starting with ERC20 and ending with native\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensMultipleV3ERC20ToNative(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) external {\n        _depositMultipleERC20Tokens(_swapData);\n        _executeSwaps(_swapData, _transactionId, _receiver);\n        _transferNativeTokensAndEmitEvent(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _minAmountOut,\n            _swapData\n        );\n    }\n\n    /// @notice Performs multiple swaps in one transaction, starting with ERC20 and ending with ERC20\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensMultipleV3ERC20ToERC20(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) external {\n        _depositMultipleERC20Tokens(_swapData);\n        _executeSwaps(_swapData, _transactionId, _receiver);\n        _transferERC20TokensAndEmitEvent(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _minAmountOut,\n            _swapData\n        );\n    }\n\n    /// @notice Performs multiple swaps in one transaction, starting with native and ending with ERC20\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _integrator the name of the integrator\n    /// @param _referrer the address of the referrer\n    /// @param _receiver the address to receive the swapped tokens into (also excess tokens)\n    /// @param _minAmountOut the minimum amount of the final asset to receive\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapTokensMultipleV3NativeToERC20(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) external payable {\n        _executeSwaps(_swapData, _transactionId, _receiver);\n        _transferERC20TokensAndEmitEvent(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _minAmountOut,\n            _swapData\n        );\n    }\n\n    /// Private helper methods ///\n    function _depositMultipleERC20Tokens(\n        LibSwap.SwapData[] calldata _swapData\n    ) private {\n        // initialize variables before loop to save gas\n        uint256 numOfSwaps = _swapData.length;\n        LibSwap.SwapData calldata currentSwap;\n\n        // go through all swaps and deposit tokens, where required\n        for (uint256 i = 0; i < numOfSwaps; ) {\n            currentSwap = _swapData[i];\n            if (currentSwap.requiresDeposit) {\n                // we will not check msg.value as tx will fail anyway if not enough value available\n                // thus we only deposit ERC20 tokens here\n                ERC20(currentSwap.sendingAssetId).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    currentSwap.fromAmount\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _depositAndSwapERC20Single(\n        LibSwap.SwapData calldata _swapData,\n        address _receiver\n    ) private {\n        ERC20 sendingAsset = ERC20(_swapData.sendingAssetId);\n        uint256 fromAmount = _swapData.fromAmount;\n        // deposit funds\n        sendingAsset.safeTransferFrom(msg.sender, address(this), fromAmount);\n\n        // ensure that contract (callTo) and function selector are whitelisted\n        address callTo = _swapData.callTo;\n        address approveTo = _swapData.approveTo;\n        bytes calldata callData = _swapData.callData;\n        if (\n            !(LibAllowList.contractIsAllowed(callTo) &&\n                LibAllowList.selectorIsAllowed(bytes4(callData[:4])))\n        ) revert ContractCallNotAllowed();\n\n        // ensure that approveTo address is also whitelisted if it differs from callTo\n        if (approveTo != callTo && !LibAllowList.contractIsAllowed(approveTo))\n            revert ContractCallNotAllowed();\n\n        // check if the current allowance is sufficient\n        uint256 currentAllowance = sendingAsset.allowance(\n            address(this),\n            approveTo\n        );\n\n        // check if existing allowance is sufficient\n        if (currentAllowance < fromAmount) {\n            // check if is non-zero, set to 0 if not\n            if (currentAllowance != 0) sendingAsset.safeApprove(approveTo, 0);\n            // set allowance to uint max to avoid future approvals\n            sendingAsset.safeApprove(approveTo, type(uint256).max);\n        }\n\n        // execute swap\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = callTo.call(callData);\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n\n        _returnPositiveSlippageERC20(sendingAsset, _receiver);\n    }\n\n    // @dev: this function will not work with swapData that has multiple swaps with the same sendingAssetId\n    //       as the _returnPositiveSlippage... functionality will refund all remaining tokens after the first swap\n    //       We accept this fact since the use case is not common yet. As an alternative you can always use the\n    //       \"swapTokensGeneric\" function of the original GenericSwapFacet\n    function _executeSwaps(\n        LibSwap.SwapData[] calldata _swapData,\n        bytes32 _transactionId,\n        address _receiver\n    ) private {\n        // initialize variables before loop to save gas\n        uint256 numOfSwaps = _swapData.length;\n        ERC20 sendingAsset;\n        address sendingAssetId;\n        address receivingAssetId;\n        LibSwap.SwapData calldata currentSwap;\n        bool success;\n        bytes memory returnData;\n        uint256 currentAllowance;\n\n        // go through all swaps\n        for (uint256 i = 0; i < numOfSwaps; ) {\n            currentSwap = _swapData[i];\n            sendingAssetId = currentSwap.sendingAssetId;\n            sendingAsset = ERC20(currentSwap.sendingAssetId);\n            receivingAssetId = currentSwap.receivingAssetId;\n\n            // check if callTo address is whitelisted\n            if (\n                !LibAllowList.contractIsAllowed(currentSwap.callTo) ||\n                !LibAllowList.selectorIsAllowed(\n                    bytes4(currentSwap.callData[:4])\n                )\n            ) {\n                revert ContractCallNotAllowed();\n            }\n\n            // if approveTo address is different to callTo, check if it's whitelisted, too\n            if (\n                currentSwap.approveTo != currentSwap.callTo &&\n                !LibAllowList.contractIsAllowed(currentSwap.approveTo)\n            ) {\n                revert ContractCallNotAllowed();\n            }\n\n            if (LibAsset.isNativeAsset(sendingAssetId)) {\n                // Native\n                // execute the swap\n                (success, returnData) = currentSwap.callTo.call{\n                    value: currentSwap.fromAmount\n                }(currentSwap.callData);\n                if (!success) {\n                    LibUtil.revertWith(returnData);\n                }\n\n                // return any potential leftover sendingAsset tokens\n                // but only for swaps, not for fee collections (otherwise the whole amount would be returned before the actual swap)\n                if (sendingAssetId != receivingAssetId)\n                    _returnPositiveSlippageNative(_receiver);\n            } else {\n                // ERC20\n                // check if the current allowance is sufficient\n                currentAllowance = sendingAsset.allowance(\n                    address(this),\n                    currentSwap.approveTo\n                );\n                if (currentAllowance < currentSwap.fromAmount) {\n                    sendingAsset.safeApprove(currentSwap.approveTo, 0);\n                    sendingAsset.safeApprove(\n                        currentSwap.approveTo,\n                        type(uint256).max\n                    );\n                }\n\n                // execute the swap\n                (success, returnData) = currentSwap.callTo.call(\n                    currentSwap.callData\n                );\n                if (!success) {\n                    LibUtil.revertWith(returnData);\n                }\n\n                // return any potential leftover sendingAsset tokens\n                // but only for swaps, not for fee collections (otherwise the whole amount would be returned before the actual swap)\n                if (sendingAssetId != receivingAssetId)\n                    _returnPositiveSlippageERC20(sendingAsset, _receiver);\n            }\n\n            // emit AssetSwapped event\n            // @dev: this event might in some cases emit inaccurate information. e.g. if a token is swapped and this contract already held a balance of the receivingAsset\n            //       then the event will show swapOutputAmount + existingBalance as toAmount. We accept this potential inaccuracy in return for gas savings and may update this\n            //       at a later stage when the described use case becomes more common\n            emit LibSwap.AssetSwapped(\n                _transactionId,\n                currentSwap.callTo,\n                sendingAssetId,\n                receivingAssetId,\n                currentSwap.fromAmount,\n                LibAsset.isNativeAsset(receivingAssetId)\n                    ? address(this).balance\n                    : ERC20(receivingAssetId).balanceOf(address(this)),\n                block.timestamp\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _transferERC20TokensAndEmitEvent(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) private {\n        // determine the end result of the swap\n        address finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        uint256 amountReceived = ERC20(finalAssetId).balanceOf(address(this));\n\n        // make sure minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer to receiver\n        ERC20(finalAssetId).safeTransfer(_receiver, amountReceived);\n\n        // emit event\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _swapData[0].sendingAssetId,\n            finalAssetId,\n            _swapData[0].fromAmount,\n            amountReceived\n        );\n    }\n\n    function _transferNativeTokensAndEmitEvent(\n        bytes32 _transactionId,\n        string calldata _integrator,\n        string calldata _referrer,\n        address payable _receiver,\n        uint256 _minAmountOut,\n        LibSwap.SwapData[] calldata _swapData\n    ) private {\n        uint256 amountReceived = address(this).balance;\n\n        // make sure minAmountOut was received\n        if (amountReceived < _minAmountOut)\n            revert CumulativeSlippageTooHigh(_minAmountOut, amountReceived);\n\n        // transfer funds to receiver\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _receiver.call{ value: amountReceived }(\"\");\n        if (!success) {\n            revert NativeAssetTransferFailed();\n        }\n\n        // emit event\n        emit ILiFi.LiFiGenericSwapCompleted(\n            _transactionId,\n            _integrator,\n            _referrer,\n            _receiver,\n            _swapData[0].sendingAssetId,\n            NATIVE_ADDRESS,\n            _swapData[0].fromAmount,\n            amountReceived\n        );\n    }\n\n    // returns any unused 'sendingAsset' tokens (=> positive slippage) to the receiver address\n    function _returnPositiveSlippageERC20(\n        ERC20 sendingAsset,\n        address receiver\n    ) private {\n        // if a balance exists in sendingAsset, it must be positive slippage\n        if (address(sendingAsset) != NATIVE_ADDRESS) {\n            uint256 sendingAssetBalance = sendingAsset.balanceOf(\n                address(this)\n            );\n\n            if (sendingAssetBalance > 0) {\n                sendingAsset.safeTransfer(receiver, sendingAssetBalance);\n            }\n        }\n    }\n\n    // returns any unused native tokens (=> positive slippage) to the receiver address\n    function _returnPositiveSlippageNative(address receiver) private {\n        // if a native balance exists in sendingAsset, it must be positive slippage\n        uint256 nativeBalance = address(this).balance;\n\n        if (nativeBalance > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = receiver.call{ value: nativeBalance }(\"\");\n            if (!success) revert NativeAssetTransferFailed();\n        }\n    }\n}\n"
    },
    "src/Facets/GnosisBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IXDaiBridge } from \"../Interfaces/IXDaiBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidSendingToken, NoSwapDataProvided } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Gnosis Bridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through XDaiBridge\n/// @custom:version 1.0.0\ncontract GnosisBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The DAI address on the source chain.\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    /// @notice The chain id of Gnosis.\n    uint64 private constant GNOSIS_CHAIN_ID = 100;\n\n    /// @notice The contract address of the xdai bridge on the source chain.\n    IXDaiBridge private immutable xDaiBridge;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _xDaiBridge The contract address of the xdai bridge on the source chain.\n    constructor(IXDaiBridge _xDaiBridge) {\n        xDaiBridge = _xDaiBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function startBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        nonReentrant\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, GNOSIS_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, DAI)\n    {\n        LibAsset.depositAsset(DAI, _bridgeData.minAmount);\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapAndStartBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, GNOSIS_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, DAI)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        LibAsset.maxApproveERC20(\n            IERC20(DAI),\n            address(xDaiBridge),\n            _bridgeData.minAmount\n        );\n        xDaiBridge.relayTokens(_bridgeData.receiver, _bridgeData.minAmount);\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/GnosisBridgeL2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IXDaiBridgeL2 } from \"../Interfaces/IXDaiBridgeL2.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidSendingToken, NoSwapDataProvided } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Gnosis Bridge Facet on Gnosis Chain\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through XDaiBridge\n/// @custom:version 1.0.0\ncontract GnosisBridgeL2Facet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @notice The xDAI address on the source chain.\n    address private constant XDAI = address(0);\n\n    /// @notice The chain id of Ethereum Mainnet.\n    uint64 private constant ETHEREUM_CHAIN_ID = 1;\n\n    /// @notice The contract address of the xdai bridge on the source chain.\n    IXDaiBridgeL2 private immutable xDaiBridge;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _xDaiBridge The contract address of the xdai bridge on the source chain.\n    constructor(IXDaiBridgeL2 _xDaiBridge) {\n        xDaiBridge = _xDaiBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function startBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, ETHEREUM_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, XDAI)\n    {\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an object containing swap related data to perform swaps before bridging\n    function swapAndStartBridgeTokensViaXDaiBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n        onlyAllowDestinationChain(_bridgeData, ETHEREUM_CHAIN_ID)\n        onlyAllowSourceToken(_bridgeData, XDAI)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via XDaiBridge\n    /// @param _bridgeData the core information needed for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        xDaiBridge.relayTokens{ value: _bridgeData.minAmount }(\n            _bridgeData.receiver\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/HopFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidConfig, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Hop Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 2.0.0\ncontract HopFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.hop\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(address => IHopBridge) bridges;\n        bool initialized; // no longer used but kept here to maintain the same storage layout\n    }\n\n    struct Config {\n        address assetId;\n        address bridge;\n    }\n\n    struct HopData {\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n        address relayer;\n        uint256 relayerFee;\n        uint256 nativeFee;\n    }\n\n    /// Events ///\n\n    event HopInitialized(Config[] configs);\n    event HopBridgeRegistered(address indexed assetId, address bridge);\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Hop Facet\n    /// @param configs Bridge configuration data\n    function initHop(Config[] calldata configs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        for (uint256 i = 0; i < configs.length; i++) {\n            if (configs[i].bridge == address(0)) {\n                revert InvalidConfig();\n            }\n            s.bridges[configs[i].assetId] = IHopBridge(configs[i].bridge);\n        }\n\n        emit HopInitialized(configs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Register token and bridge\n    /// @param assetId Address of token\n    /// @param bridge Address of bridge for asset\n    function registerBridge(address assetId, address bridge) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (bridge == address(0)) {\n            revert InvalidConfig();\n        }\n\n        s.bridges[assetId] = IHopBridge(bridge);\n\n        emit HopBridgeRegistered(assetId, bridge);\n    }\n\n    /// @notice Bridges tokens via Hop Protocol\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHop(\n        ILiFi.BridgeData memory _bridgeData,\n        HopData calldata _hopData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _hopData);\n    }\n\n    /// @notice Performs a swap before bridging via Hop Protocol\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHop(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n        _startBridge(_bridgeData, _hopData);\n    }\n\n    /// private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Hop Protocol\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        HopData calldata _hopData\n    ) private {\n        address sendingAssetId = _bridgeData.sendingAssetId;\n        Storage storage s = getStorage();\n        IHopBridge bridge = s.bridges[sendingAssetId];\n\n        // Give Hop approval to bridge tokens\n        LibAsset.maxApproveERC20(\n            IERC20(sendingAssetId),\n            address(bridge),\n            _bridgeData.minAmount\n        );\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId))\n            ? _hopData.nativeFee + _bridgeData.minAmount\n            : _hopData.nativeFee;\n\n        if (block.chainid == 1 || block.chainid == 5) {\n            // Ethereum L1\n            bridge.sendToL2{ value: value }(\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline,\n                _hopData.relayer,\n                _hopData.relayerFee\n            );\n        } else {\n            // L2\n            // solhint-disable-next-line check-send-result\n            bridge.swapAndSend{ value: value }(\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                _hopData.bonderFee,\n                _hopData.amountOutMin,\n                _hopData.deadline,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline\n            );\n        }\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/HopFacetOptimized.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Hop Facet (Optimized)\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 2.0.0\ncontract HopFacetOptimized is ILiFi, SwapperV2 {\n    /// Types ///\n\n    struct HopData {\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n        IHopBridge hopBridge;\n        address relayer;\n        uint256 relayerFee;\n        uint256 nativeFee;\n    }\n\n    /// External Methods ///\n\n    /// @notice Sets approval for the Hop Bridge to spend the specified token\n    /// @param bridges The Hop Bridges to approve\n    /// @param tokensToApprove The tokens to approve to approve to the Hop Bridges\n    function setApprovalForBridges(\n        address[] calldata bridges,\n        address[] calldata tokensToApprove\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        for (uint256 i; i < bridges.length; i++) {\n            // Give Hop approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(bridges[i]),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL1ERC20(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL1Native(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging ERC20 tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL1ERC20(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging Native tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL1Native(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL2ERC20(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external {\n        // Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL2Native(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging ERC20 tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL2ERC20(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging Native tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL2Native(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/HopFacetPacked.sol": {
      "content": "// // SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IHopBridge, IL2AmmWrapper, ISwap } from \"../Interfaces/IHopBridge.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { HopFacetOptimized } from \"../../src/Facets/HopFacetOptimized.sol\";\nimport { WETH } from \"../../lib/solmate/src/tokens/WETH.sol\";\n\n/// @title Hop Facet (Optimized for Rollups)\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 1.0.6\ncontract HopFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage ///\n\n    address public immutable nativeBridge;\n    address public immutable nativeL2CanonicalToken;\n    address public immutable nativeHToken;\n    address public immutable nativeExchangeAddress;\n\n    /// Errors ///\n\n    error Invalid();\n\n    /// Events ///\n\n    event LiFiHopTransfer(bytes8 _transactionId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _owner The contract owner to approve tokens.\n    /// @param _wrapper The address of Hop L2_AmmWrapper for native asset.\n    constructor(\n        address _owner,\n        address _wrapper\n    ) TransferrableOwnership(_owner) {\n        bool wrapperIsSet = _wrapper != address(0);\n\n        if (block.chainid == 1 && wrapperIsSet) {\n            revert Invalid();\n        }\n\n        nativeL2CanonicalToken = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).l2CanonicalToken()\n            : address(0);\n        nativeHToken = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).hToken()\n            : address(0);\n        nativeExchangeAddress = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).exchangeAddress()\n            : address(0);\n        nativeBridge = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).bridge()\n            : address(0);\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Hop Bridge to spend the specified token\n    /// @param bridges The Hop Bridges to approve\n    /// @param tokensToApprove The tokens to approve to approve to the Hop Bridges\n    function setApprovalForHopBridges(\n        address[] calldata bridges,\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        uint256 numBridges = bridges.length;\n\n        for (uint256 i; i < numBridges; i++) {\n            // Give Hop approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(bridges[i]),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL2NativePacked() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[36:52]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[52:68])))\n        // => total calldata length required: 68\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[52:68])));\n        bool toL1 = destinationChainId == 1;\n\n        // Wrap ETH\n        WETH(payable(nativeL2CanonicalToken)).deposit{ value: msg.value }();\n\n        // Exchange WETH for hToken\n        uint256 swapAmount = ISwap(nativeExchangeAddress).swap(\n            0,\n            1,\n            msg.value,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(nativeBridge).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])), // receiver\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[36:52]))), // bonderFee\n            toL1 ? 0 : amountOutMin,\n            toL1 ? 0 : block.timestamp + 7 * 24 * 60 * 60\n        );\n\n        emit LiFiHopTransfer(\n            bytes8(msg.data[4:12]) // transactionId\n        );\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param hopBridge Address of the Hop L2_AmmWrapper\n    function startBridgeTokensViaHopL2NativeMin(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address hopBridge\n    ) external payable {\n        // Bridge assets\n        IHopBridge(hopBridge).swapAndSend{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    function encode_startBridgeTokensViaHopL2NativePacked(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 bonderFee,\n        uint256 amountOutMin\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin))\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL2NativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL2NativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 68,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[36:52])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[52:68])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL2ERC20Packed() external {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[88:104]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[104:120]))),\n        // destinationDeadline: uint256(uint32(bytes4(msg.data[120:124]))),\n        // wrapper: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[88:104])));\n        bool toL1 = destinationChainId == 1;\n\n        IL2AmmWrapper wrapper = IL2AmmWrapper(\n            address(bytes20(msg.data[124:144]))\n        );\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Exchange sending asset to hToken\n        uint256 swapAmount = ISwap(wrapper.exchangeAddress()).swap(\n            0,\n            1,\n            amount,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(wrapper.bridge()).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])),\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            toL1 ? 0 : uint256(uint128(bytes16(msg.data[104:120]))),\n            toL1 ? 0 : uint256(uint32(bytes4(msg.data[120:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param hopBridge Address of the Hop L2_AmmWrapper\n    function startBridgeTokensViaHopL2ERC20Min(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address hopBridge\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).swapAndSend(\n            destinationChainId,\n            receiver,\n            minAmount,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param wrapper Address of the Hop L2_AmmWrapper\n    function encode_startBridgeTokensViaHopL2ERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address wrapper\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationDeadline <= type(uint32).max,\n            \"destinationDeadline value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes4(uint32(destinationDeadline)),\n                bytes20(wrapper)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL2ERC20Packed\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL2ERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[88:104])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[104:120]))\n        );\n        hopData.destinationDeadline = uint256(uint32(bytes4(_data[120:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL1NativePacked() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[36:52]))),\n        // relayer: address(bytes20(msg.data[52:72])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // hopBridge: address(bytes20(msg.data[88:108]))\n        // => total calldata length required: 108\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[88:108]))).sendToL2{\n            value: msg.value\n        }(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            msg.value,\n            uint256(uint128(bytes16(msg.data[36:52]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[52:72])),\n            uint256(uint128(bytes16(msg.data[72:88])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function startBridgeTokensViaHopL1NativeMin(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external payable {\n        // Bridge assets\n        IHopBridge(hopBridge).sendToL2{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function encode_startBridgeTokensViaHopL1NativePacked(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL1NativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL1NativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 108,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[36:52]))\n        );\n        // relayer = address(bytes20(_data[52:72]));\n        // relayerFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[88:108])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL1ERC20Packed() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[72:88]))),\n        // relayer: address(bytes20(msg.data[88:108])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[108:124]))),\n        // hopBridge: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[124:144]))).sendToL2(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            amount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[88:108])),\n            uint256(uint128(bytes16(msg.data[108:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function startBridgeTokensViaHopL1ERC20Min(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).sendToL2(\n            destinationChainId,\n            receiver,\n            minAmount,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function encode_startBridgeTokensViaHopL1ERC20Packed(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL1ERC20Packed\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL1ERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[72:88]))\n        );\n        // relayer = address(bytes20(_data[88:108]));\n        // relayerFee = uint256(uint128(bytes16(_data[108:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }\n}\n"
    },
    "src/Facets/HyphenFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHyphenRouter } from \"../Interfaces/IHyphenRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Hyphen Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hyphen\n/// @custom:version 1.0.0\ncontract HyphenFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the router on the source chain.\n    IHyphenRouter private immutable router;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _router The contract address of the router on the source chain.\n    constructor(IHyphenRouter _router) {\n        router = _router;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Hyphen\n    /// @param _bridgeData the core information needed for bridging\n    function startBridgeTokensViaHyphen(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via Hyphen\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaHyphen(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Hyphen\n    /// @param _bridgeData the core information needed for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Give the Hyphen router approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(router),\n                _bridgeData.minAmount\n            );\n\n            router.depositErc20(\n                _bridgeData.destinationChainId,\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount,\n                \"LIFI\"\n            );\n        } else {\n            router.depositNative{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _bridgeData.destinationChainId,\n                \"LIFI\"\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/LIFuelFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LiFuelFeeCollector } from \"../Periphery/LiFuelFeeCollector.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title LIFuel Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging gas through LIFuel\n/// @custom:version 1.0.1\ncontract LIFuelFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.periphery_registry\");\n    string internal constant FEE_COLLECTOR_NAME = \"LiFuelFeeCollector\";\n\n    /// Types ///\n\n    struct Storage {\n        mapping(string => address) contracts;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via LIFuel Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    function startBridgeTokensViaLIFuel(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via LIFuel Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaLIFuel(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via LIFuel Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        LiFuelFeeCollector liFuelFeeCollector = LiFuelFeeCollector(\n            getStorage().contracts[FEE_COLLECTOR_NAME]\n        );\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            liFuelFeeCollector.collectNativeGasFees{\n                value: _bridgeData.minAmount\n            }(\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(liFuelFeeCollector),\n                _bridgeData.minAmount\n            );\n\n            liFuelFeeCollector.collectTokenGasFees(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.destinationChainId,\n                _bridgeData.receiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/MayanFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { IMayan } from \"../Interfaces/IMayan.sol\";\nimport { UnsupportedChainId } from \"../Errors/GenericErrors.sol\";\n\n/// @title Mayan Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Mayan Bridge\n/// @custom:version 1.0.0\ncontract MayanFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.mayan\");\n    address internal constant NON_EVM_ADDRESS =\n        0x11f111f111f111F111f111f111F111f111f111F1;\n\n    IMayan public immutable mayan;\n\n    /// @dev Mayan specific bridge data\n    /// @param nonEVMReceiver The address of the non-EVM receiver if applicable\n    /// @param mayanProtocol The address of the Mayan protocol final contract\n    /// @param protocolData The protocol data for the Mayan protocol\n    struct MayanData {\n        bytes32 nonEVMReceiver;\n        address mayanProtocol;\n        bytes protocolData;\n    }\n\n    /// Errors ///\n    error InvalidReceiver(address expected, address actual);\n    error InvalidNonEVMReceiver(bytes32 expected, bytes32 actual);\n\n    /// Events ///\n\n    event BridgeToNonEVMChain(\n        bytes32 indexed transactionId,\n        uint256 indexed destinationChainId,\n        bytes32 receiver\n    );\n\n    /// Constructor ///\n\n    /// @notice Constructor for the contract.\n    constructor(IMayan _mayan) {\n        mayan = _mayan;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Mayan\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _mayanData Data specific to Mayan\n    function startBridgeTokensViaMayan(\n        ILiFi.BridgeData memory _bridgeData,\n        MayanData calldata _mayanData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Normalize the amount to 8 decimals\n            _bridgeData.minAmount = _normalizeAmount(\n                _bridgeData.minAmount,\n                18\n            );\n        }\n\n        _startBridge(_bridgeData, _mayanData);\n    }\n\n    /// @notice Performs a swap before bridging via Mayan\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _mayanData Data specific to Mayan\n    function swapAndStartBridgeTokensViaMayan(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        MayanData memory _mayanData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        uint256 decimals;\n        bool isNative = LibAsset.isNativeAsset(_bridgeData.sendingAssetId);\n        decimals = isNative\n            ? 18\n            : ERC20(_bridgeData.sendingAssetId).decimals();\n\n        // Normalize the amount to 8 decimals\n        _bridgeData.minAmount = _normalizeAmount(\n            _bridgeData.minAmount,\n            uint8(decimals)\n        );\n\n        // Native values are not passed as calldata\n        if (!isNative) {\n            // Update the protocol data with the new input amount\n            _mayanData.protocolData = _replaceInputAmount(\n                _mayanData.protocolData,\n                _bridgeData.minAmount\n            );\n        }\n\n        _startBridge(_bridgeData, _mayanData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Mayan\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _mayanData Data specific to Mayan\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        MayanData memory _mayanData\n    ) internal {\n        // Validate receiver address\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            if (_mayanData.nonEVMReceiver == bytes32(0)) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    bytes32(0)\n                );\n            }\n            bytes32 receiver = _parseReceiver(_mayanData.protocolData);\n            if (_mayanData.nonEVMReceiver != receiver) {\n                revert InvalidNonEVMReceiver(\n                    _mayanData.nonEVMReceiver,\n                    receiver\n                );\n            }\n        } else {\n            address receiver = address(\n                uint160(uint256(_parseReceiver(_mayanData.protocolData)))\n            );\n            if (_bridgeData.receiver != receiver) {\n                revert InvalidReceiver(_bridgeData.receiver, receiver);\n            }\n        }\n\n        IMayan.PermitParams memory emptyPermitParams;\n\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(mayan),\n                _bridgeData.minAmount\n            );\n\n            mayan.forwardERC20(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                emptyPermitParams,\n                _mayanData.mayanProtocol,\n                _mayanData.protocolData\n            );\n        } else {\n            mayan.forwardEth{ value: _bridgeData.minAmount }(\n                _mayanData.mayanProtocol,\n                _mayanData.protocolData\n            );\n        }\n\n        if (_bridgeData.receiver == NON_EVM_ADDRESS) {\n            emit BridgeToNonEVMChain(\n                _bridgeData.transactionId,\n                _bridgeData.destinationChainId,\n                _mayanData.nonEVMReceiver\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    // @dev Parses the receiver address from the protocol data\n    // @param protocolData The protocol data for the Mayan protocol\n    // @return receiver The receiver address\n    function _parseReceiver(\n        bytes memory protocolData\n    ) internal pure returns (bytes32 receiver) {\n        bytes4 selector;\n        assembly {\n            // Load the selector from the protocol data\n            selector := mload(add(protocolData, 0x20))\n            // Shift the selector to the right by 224 bits to match shape of literal in switch statement\n            let shiftedSelector := shr(224, selector)\n            switch shiftedSelector\n            // Note: [*bytes32*] = location of receiver address\n            case 0x94454a5d {\n                // 0x94454a5d bridgeWithFee(address,uint256,uint64,uint64,[*bytes32*],(uint32,bytes32,bytes32))\n                receiver := mload(add(protocolData, 0xa4)) // MayanCircle::bridgeWithFee()\n            }\n            case 0x32ad465f {\n                // 0x32ad465f bridgeWithLockedFee(address,uint256,uint64,uint256,(uint32,[*bytes32*],bytes32))\n                receiver := mload(add(protocolData, 0xc4)) // MayanCircle::bridgeWithLockedFee()\n            }\n            case 0xafd9b706 {\n                // 0xafd9b706 createOrder((address,uint256,uint64,[*bytes32*],uint16,bytes32,uint64,uint64,uint64,bytes32,uint8),(uint32,bytes32,bytes32))\n                receiver := mload(add(protocolData, 0x84)) // MayanCircle::createOrder()\n            }\n            case 0x6111ad25 {\n                // 0x6111ad25 swap((uint64,uint64,uint64),(bytes32,uint16,bytes32,[*bytes32*],uint16,bytes32,bytes32),bytes32,uint16,(uint256,uint64,uint64,bool,uint64,bytes),address,uint256)\n                receiver := mload(add(protocolData, 0xe4)) // MayanSwap::swap()\n            }\n            case 0x1eb1cff0 {\n                // 0x1eb1cff0 wrapAndSwapETH((uint64,uint64,uint64),(bytes32,uint16,bytes32,[*bytes32*],uint16,bytes32,bytes32),bytes32,uint16,(uint256,uint64,uint64,bool,uint64,bytes))\n                receiver := mload(add(protocolData, 0xe4)) // MayanSwap::wrapAndSwapETH()\n            }\n            case 0xb866e173 {\n                // 0xb866e173 createOrderWithEth((bytes32,bytes32,uint64,uint64,uint64,uint64,uint64,[*bytes32*],uint16,bytes32,uint8,uint8,bytes32))\n                receiver := mload(add(protocolData, 0x104)) // MayanSwift::createOrderWithEth()\n            }\n            case 0x8e8d142b {\n                // 0x8e8d142b createOrderWithToken(address,uint256,(bytes32,bytes32,uint64,uint64,uint64,uint64,uint64,[*bytes32*],uint16,bytes32,uint8,uint8,bytes32))\n                receiver := mload(add(protocolData, 0x144)) // MayanSwift::createOrderWithToken()\n            }\n            default {\n                receiver := 0x0\n            }\n        }\n    }\n\n    // @dev Normalizes the amount to 8 decimals\n    // @param amount The amount to normalize\n    // @param decimals The number of decimals in the asset\n    function _normalizeAmount(\n        uint256 amount,\n        uint8 decimals\n    ) internal pure returns (uint256) {\n        if (decimals > 8) {\n            amount /= 10 ** (decimals - 8);\n            amount *= 10 ** (decimals - 8);\n        }\n        return amount;\n    }\n\n    // @dev Replaces the input amount in the protocol data\n    // @param protocolData The protocol data for the Mayan protocol\n    // @param inputAmount The new input amount\n    // @return modifiedData The modified protocol data\n    function _replaceInputAmount(\n        bytes memory protocolData,\n        uint256 inputAmount\n    ) internal pure returns (bytes memory) {\n        require(protocolData.length >= 68, \"protocol data too short\");\n        bytes memory modifiedData = new bytes(protocolData.length);\n        bytes4 functionSelector = bytes4(protocolData[0]) |\n            (bytes4(protocolData[1]) >> 8) |\n            (bytes4(protocolData[2]) >> 16) |\n            (bytes4(protocolData[3]) >> 24);\n\n        uint256 amountIndex;\n        // Only the wh swap method has the amount as last argument\n        bytes4 swapSelector = 0x6111ad25;\n        if (functionSelector == swapSelector) {\n            amountIndex = protocolData.length - 256;\n        } else {\n            amountIndex = 36;\n        }\n\n        // Copy the function selector and params before amount in\n        for (uint i = 0; i < amountIndex; i++) {\n            modifiedData[i] = protocolData[i];\n        }\n\n        // Encode the amount and place it into the modified call data\n        bytes memory encodedAmount = abi.encode(inputAmount);\n        for (uint i = 0; i < 32; i++) {\n            modifiedData[i + amountIndex] = encodedAmount[i];\n        }\n\n        // Copy the rest of the original data after the input argument\n        for (uint i = amountIndex + 32; i < protocolData.length; i++) {\n            modifiedData[i] = protocolData[i];\n        }\n\n        return modifiedData;\n    }\n}\n"
    },
    "src/Facets/NonStandardSelectorsRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Non Standard Selectors Registry Facet\n/// @author LIFI (https://li.finance)\n/// @notice Registry for non-standard selectors\n/// @custom:version 1.0.0\ncontract NonStandardSelectorsRegistryFacet {\n    // Storage //\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.nonstandardselectorsregistry\");\n\n    // Types //\n    struct Storage {\n        mapping(bytes4 => bool) selectors;\n    }\n\n    // @notice set a selector as non-standard\n    // @param _selector the selector to set\n    // @param _isNonStandardSelector whether the selector is non-standard\n    function setNonStandardSelector(\n        bytes4 _selector,\n        bool _isNonStandardSelector\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n        s.selectors[_selector] = _isNonStandardSelector;\n    }\n\n    // @notice batch set selectors as non-standard\n    // @param _selectors the selectors to set\n    // @param _isNonStandardSelectors whether the selectors are non-standard\n    function batchSetNonStandardSelectors(\n        bytes4[] calldata _selectors,\n        bool[] calldata _isNonStandardSelectors\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n        require(\n            _selectors.length == _isNonStandardSelectors.length,\n            \"NonStandardSelectorsRegistryFacet: selectors and isNonStandardSelectors length mismatch\"\n        );\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            s.selectors[_selectors[i]] = _isNonStandardSelectors[i];\n        }\n    }\n\n    // @notice check if a selector is non-standard\n    // @param _selector the selector to check\n    // @return whether the selector is non-standard\n    function isNonStandardSelector(\n        bytes4 _selector\n    ) external view returns (bool) {\n        return getStorage().selectors[_selector];\n    }\n\n    // Internal Functions //\n\n    // @notice get the storage slot for the NonStandardSelectorsRegistry\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 position = NAMESPACE;\n        assembly {\n            s.slot := position\n        }\n    }\n}\n"
    },
    "src/Facets/OmniBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IOmniBridge } from \"../Interfaces/IOmniBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title OmniBridge Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through OmniBridge\n/// @custom:version 1.0.0\ncontract OmniBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the foreign omni bridge on the source chain.\n    IOmniBridge private immutable foreignOmniBridge;\n\n    /// @notice The contract address of the weth omni bridge on the source chain.\n    IOmniBridge private immutable wethOmniBridge;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _foreignOmniBridge The contract address of the foreign omni bridge on the source chain.\n    /// @param _wethOmniBridge The contract address of the weth omni bridge on the source chain.\n    constructor(IOmniBridge _foreignOmniBridge, IOmniBridge _wethOmniBridge) {\n        foreignOmniBridge = _foreignOmniBridge;\n        wethOmniBridge = _wethOmniBridge;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via OmniBridge\n    /// @param _bridgeData Data contaning core information for bridging\n    function startBridgeTokensViaOmniBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via OmniBridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaOmniBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via OmniBridge\n    /// @param _bridgeData Data contaning core information for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            wethOmniBridge.wrapAndRelayTokens{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(foreignOmniBridge),\n                _bridgeData.minAmount\n            );\n            foreignOmniBridge.relayTokens(\n                _bridgeData.sendingAssetId,\n                _bridgeData.receiver,\n                _bridgeData.minAmount\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/OptimismBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IL1StandardBridge } from \"../Interfaces/IL1StandardBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InvalidConfig, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\n\n/// @title Optimism Bridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Optimism Bridge\n/// @custom:version 1.0.0\ncontract OptimismBridgeFacet is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.optimism\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(address => IL1StandardBridge) bridges;\n        IL1StandardBridge standardBridge;\n        bool initialized;\n    }\n\n    struct Config {\n        address assetId;\n        address bridge;\n    }\n\n    struct OptimismData {\n        address assetIdOnL2;\n        uint32 l2Gas;\n        bool isSynthetix;\n    }\n\n    /// Events ///\n\n    event OptimismInitialized(Config[] configs);\n    event OptimismBridgeRegistered(address indexed assetId, address bridge);\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Optimism Bridge Facet\n    /// @param configs Bridge configuration data\n    function initOptimism(\n        Config[] calldata configs,\n        IL1StandardBridge standardBridge\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (s.initialized) {\n            revert AlreadyInitialized();\n        }\n\n        for (uint256 i = 0; i < configs.length; i++) {\n            if (configs[i].bridge == address(0)) {\n                revert InvalidConfig();\n            }\n            s.bridges[configs[i].assetId] = IL1StandardBridge(\n                configs[i].bridge\n            );\n        }\n\n        s.standardBridge = standardBridge;\n        s.initialized = true;\n\n        emit OptimismInitialized(configs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Register token and bridge\n    /// @param assetId Address of token\n    /// @param bridge Address of bridge for asset\n    function registerOptimismBridge(address assetId, address bridge) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage s = getStorage();\n\n        if (!s.initialized) revert NotInitialized();\n\n        if (bridge == address(0)) {\n            revert InvalidConfig();\n        }\n\n        s.bridges[assetId] = IL1StandardBridge(bridge);\n\n        emit OptimismBridgeRegistered(assetId, bridge);\n    }\n\n    /// @notice Bridges tokens via Optimism Bridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _bridgeData Data specific to Optimism Bridge\n    function startBridgeTokensViaOptimismBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        OptimismData calldata _optimismData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _optimismData);\n    }\n\n    /// @notice Performs a swap before bridging via Optimism Bridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _bridgeData Data specific to Optimism Bridge\n    function swapAndStartBridgeTokensViaOptimismBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        OptimismData calldata _optimismData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _optimismData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Optimism Bridge\n    /// @param _bridgeData Data contaning core information for bridging\n    /// @param _bridgeData Data specific to Optimism Bridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        OptimismData calldata _optimismData\n    ) private {\n        Storage storage s = getStorage();\n        IL1StandardBridge nonStandardBridge = s.bridges[\n            _bridgeData.sendingAssetId\n        ];\n        IL1StandardBridge bridge = LibUtil.isZeroAddress(\n            address(nonStandardBridge)\n        )\n            ? s.standardBridge\n            : nonStandardBridge;\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            bridge.depositETHTo{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver,\n                _optimismData.l2Gas,\n                \"\"\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(bridge),\n                _bridgeData.minAmount\n            );\n\n            if (_optimismData.isSynthetix) {\n                bridge.depositTo(_bridgeData.receiver, _bridgeData.minAmount);\n            } else {\n                bridge.depositERC20To(\n                    _bridgeData.sendingAssetId,\n                    _optimismData.assetIdOnL2,\n                    _bridgeData.receiver,\n                    _bridgeData.minAmount,\n                    _optimismData.l2Gas,\n                    \"\"\n                );\n            }\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../Interfaces/IERC173.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\n/// @title Ownership Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Manages ownership of the LiFi Diamond contract for admin purposes\n/// @custom:version 1.0.0\ncontract OwnershipFacet is IERC173 {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.ownership\");\n\n    /// Types ///\n\n    struct Storage {\n        address newOwner;\n    }\n\n    /// Errors ///\n\n    error NoNullOwner();\n    error NewOwnerMustNotBeSelf();\n    error NoPendingOwnershipTransfer();\n    error NotPendingOwner();\n\n    /// Events ///\n\n    event OwnershipTransferRequested(\n        address indexed _from,\n        address indexed _to\n    );\n\n    /// External Methods ///\n\n    /// @notice Initiates transfer of ownership to a new address\n    /// @param _newOwner the address to transfer ownership to\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n\n        if (LibUtil.isZeroAddress(_newOwner)) revert NoNullOwner();\n\n        if (_newOwner == LibDiamond.contractOwner())\n            revert NewOwnerMustNotBeSelf();\n\n        s.newOwner = _newOwner;\n        emit OwnershipTransferRequested(msg.sender, s.newOwner);\n    }\n\n    /// @notice Cancel transfer of ownership\n    function cancelOwnershipTransfer() external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n\n        if (LibUtil.isZeroAddress(s.newOwner))\n            revert NoPendingOwnershipTransfer();\n        s.newOwner = address(0);\n    }\n\n    /// @notice Confirms transfer of ownership to the calling address (msg.sender)\n    function confirmOwnershipTransfer() external {\n        Storage storage s = getStorage();\n        address _pendingOwner = s.newOwner;\n        if (msg.sender != _pendingOwner) revert NotPendingOwner();\n        emit OwnershipTransferred(LibDiamond.contractOwner(), _pendingOwner);\n        LibDiamond.setContractOwner(_pendingOwner);\n        s.newOwner = LibAsset.NULL_ADDRESS;\n    }\n\n    /// @notice Return the current owner address\n    /// @return owner_ The current owner address\n    function owner() external view override returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n\n    /// Private Methods ///\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/PeripheryRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Periphery Registry Facet\n/// @author LI.FI (https://li.fi)\n/// @notice A simple registry to track LIFI periphery contracts\n/// @custom:version 1.0.0\ncontract PeripheryRegistryFacet {\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.periphery_registry\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(string => address) contracts;\n    }\n\n    /// Events ///\n\n    event PeripheryContractRegistered(string name, address contractAddress);\n\n    /// External Methods ///\n\n    /// @notice Registers a periphery contract address with a specified name\n    /// @param _name the name to register the contract address under\n    /// @param _contractAddress the address of the contract to register\n    function registerPeripheryContract(\n        string calldata _name,\n        address _contractAddress\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage s = getStorage();\n        s.contracts[_name] = _contractAddress;\n        emit PeripheryContractRegistered(_name, _contractAddress);\n    }\n\n    /// @notice Returns the registered contract address by its name\n    /// @param _name the registered name of the contract\n    function getPeripheryContract(\n        string calldata _name\n    ) external view returns (address) {\n        return getStorage().contracts[_name];\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/PolygonBridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IRootChainManager } from \"../Interfaces/IRootChainManager.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Polygon Bridge Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Polygon Bridge\n/// @custom:version 1.0.0\ncontract PolygonBridgeFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the RootChainManager on the source chain.\n    IRootChainManager private immutable rootChainManager;\n\n    /// @notice The contract address of the ERC20Predicate on the source chain.\n    address private immutable erc20Predicate;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _rootChainManager The contract address of the RootChainManager on the source chain.\n    /// @param _erc20Predicate The contract address of the ERC20Predicate on the source chain.\n    constructor(IRootChainManager _rootChainManager, address _erc20Predicate) {\n        rootChainManager = _rootChainManager;\n        erc20Predicate = _erc20Predicate;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Polygon Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    function startBridgeTokensViaPolygonBridge(\n        ILiFi.BridgeData memory _bridgeData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging via Polygon Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    function swapAndStartBridgeTokensViaPolygonBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Polygon Bridge\n    /// @param _bridgeData Data containing core information for bridging\n    function _startBridge(ILiFi.BridgeData memory _bridgeData) private {\n        address childToken;\n\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            rootChainManager.depositEtherFor{ value: _bridgeData.minAmount }(\n                _bridgeData.receiver\n            );\n        } else {\n            childToken = rootChainManager.rootToChildToken(\n                _bridgeData.sendingAssetId\n            );\n\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                erc20Predicate,\n                _bridgeData.minAmount\n            );\n\n            bytes memory depositData = abi.encode(_bridgeData.minAmount);\n            rootChainManager.depositFor(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                depositData\n            );\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/SquidFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ISquidRouter } from \"../Interfaces/ISquidRouter.sol\";\nimport { ISquidMulticall } from \"../Interfaces/ISquidMulticall.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibBytes } from \"../Libraries/LibBytes.sol\";\nimport { InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { ERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\n/// @title Squid Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Squid Router\n/// @custom:version 1.0.0\ncontract SquidFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Types ///\n\n    enum RouteType {\n        BridgeCall,\n        CallBridge,\n        CallBridgeCall\n    }\n\n    /// @dev Contains the data needed for bridging via Squid squidRouter\n    /// @param RouteType The type of route to use\n    /// @param destinationChain The chain to bridge tokens to\n    /// @param destinationAddress The receiver address in dst chain format\n    /// @param bridgedTokenSymbol The symbol of the to-be-bridged token\n    /// @param depositAssetId The asset to be deposited on src network (input for optional Squid-internal src swaps)\n    /// @param sourceCalls The calls to be made by Squid on the source chain before bridging the bridgeData.sendingAsssetId token\n    /// @param payload The payload for the calls to be made at dest chain\n    /// @param fee The fee to be payed in native token on src chain\n    /// @param enableExpress enable Squid Router's instant execution service\n    struct SquidData {\n        RouteType routeType;\n        string destinationChain;\n        string destinationAddress; // required to allow future bridging to non-EVM networks\n        string bridgedTokenSymbol;\n        address depositAssetId;\n        ISquidMulticall.Call[] sourceCalls;\n        bytes payload;\n        uint256 fee;\n        bool enableExpress;\n    }\n\n    // introduced to tacke a stack-too-deep error\n    struct BridgeContext {\n        ILiFi.BridgeData bridgeData;\n        SquidData squidData;\n        uint256 msgValue;\n    }\n\n    /// Errors ///\n    error InvalidRouteType();\n\n    /// State ///\n\n    ISquidRouter private immutable squidRouter;\n\n    /// Constructor ///\n\n    constructor(ISquidRouter _squidRouter) {\n        squidRouter = _squidRouter;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Squid Router\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _squidData Data specific to Squid Router\n    function startBridgeTokensViaSquid(\n        ILiFi.BridgeData memory _bridgeData,\n        SquidData calldata _squidData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _squidData.depositAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _squidData);\n    }\n\n    /// @notice Swaps and bridges tokens via Squid Router\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _squidData Data specific to Squid Router\n    function swapAndStartBridgeTokensViaSquid(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        SquidData calldata _squidData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        // in case of native we need to keep the fee as reserve from the swap\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _squidData.fee\n        );\n\n        _startBridge(_bridgeData, _squidData);\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via Squid Router\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _squidData Data specific to Squid Router\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        SquidData calldata _squidData\n    ) internal {\n        BridgeContext memory context = BridgeContext({\n            bridgeData: _bridgeData,\n            squidData: _squidData,\n            msgValue: _calculateMsgValue(_bridgeData, _squidData)\n        });\n\n        // ensure max approval if non-native asset\n        if (!LibAsset.isNativeAsset(context.squidData.depositAssetId)) {\n            LibAsset.maxApproveERC20(\n                IERC20(context.squidData.depositAssetId),\n                address(squidRouter),\n                context.bridgeData.minAmount\n            );\n        }\n\n        // make the call to Squid router based on RouteType\n        if (_squidData.routeType == RouteType.BridgeCall) {\n            _bridgeCall(context);\n        } else if (_squidData.routeType == RouteType.CallBridge) {\n            _callBridge(context);\n        } else if (_squidData.routeType == RouteType.CallBridgeCall) {\n            _callBridgeCall(context);\n        } else {\n            revert InvalidRouteType();\n        }\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    function _bridgeCall(BridgeContext memory _context) internal {\n        squidRouter.bridgeCall{ value: _context.msgValue }(\n            _context.squidData.bridgedTokenSymbol,\n            _context.bridgeData.minAmount,\n            _context.squidData.destinationChain,\n            _context.squidData.destinationAddress,\n            _context.squidData.payload,\n            _context.bridgeData.receiver,\n            _context.squidData.enableExpress\n        );\n    }\n\n    function _callBridge(BridgeContext memory _context) private {\n        squidRouter.callBridge{ value: _context.msgValue }(\n            LibAsset.isNativeAsset(_context.squidData.depositAssetId)\n                ? 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                : _context.squidData.depositAssetId,\n            _context.bridgeData.minAmount,\n            _context.squidData.sourceCalls,\n            _context.squidData.bridgedTokenSymbol,\n            _context.squidData.destinationChain,\n            LibBytes.toHexString(uint160(_context.bridgeData.receiver), 20)\n        );\n    }\n\n    function _callBridgeCall(BridgeContext memory _context) private {\n        squidRouter.callBridgeCall{ value: _context.msgValue }(\n            LibAsset.isNativeAsset(_context.squidData.depositAssetId)\n                ? 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n                : _context.squidData.depositAssetId,\n            _context.bridgeData.minAmount,\n            _context.squidData.sourceCalls,\n            _context.squidData.bridgedTokenSymbol,\n            _context.squidData.destinationChain,\n            _context.squidData.destinationAddress,\n            _context.squidData.payload,\n            _context.bridgeData.receiver,\n            _context.squidData.enableExpress\n        );\n    }\n\n    function _calculateMsgValue(\n        ILiFi.BridgeData memory _bridgeData,\n        SquidData calldata _squidData\n    ) private pure returns (uint256) {\n        uint256 msgValue = _squidData.fee;\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            msgValue += _bridgeData.minAmount;\n        }\n        return msgValue;\n    }\n}\n"
    },
    "src/Facets/StandardizedCallFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Standardized Call Facet\n/// @author LIFI https://li.finance ed@li.finance\n/// @notice Allows calling different facet methods through a single standardized entrypoint\n/// @custom:version 1.1.0\ncontract StandardizedCallFacet {\n    /// External Methods ///\n\n    /// @notice Make a standardized call to a facet\n    /// @param callData The calldata to forward to the facet\n    function standardizedCall(bytes memory callData) external payable {\n        execute(callData);\n    }\n\n    /// @notice Make a standardized call to a facet\n    /// @param callData The calldata to forward to the facet\n    function standardizedSwapCall(bytes memory callData) external payable {\n        execute(callData);\n    }\n\n    /// @notice Make a standardized call to a facet\n    /// @param callData The calldata to forward to the facet\n    function standardizedBridgeCall(bytes memory callData) external payable {\n        execute(callData);\n    }\n\n    /// @notice Make a standardized call to a facet\n    /// @param callData The calldata to forward to the facet\n    function standardizedSwapAndBridgeCall(\n        bytes memory callData\n    ) external payable {\n        execute(callData);\n    }\n\n    function execute(bytes memory callData) internal {\n        // Fetch the facetAddress from the dimaond's internal storage\n        // Cheaper than calling the external facetAddress(selector) method directly\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        address facetAddress = ds\n            .selectorToFacetAndPosition[bytes4(callData)]\n            .facetAddress;\n\n        if (facetAddress == address(0)) {\n            revert LibDiamond.FunctionDoesNotExist();\n        }\n\n        // Execute external function from facet using delegatecall and return any value.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // execute function call using the facet\n            let result := delegatecall(\n                gas(),\n                facetAddress,\n                add(callData, 0x20),\n                mload(callData),\n                0,\n                0\n            )\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "src/Facets/StargateFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IStargateRouter } from \"../Interfaces/IStargateRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InformationMismatch, AlreadyInitialized, NotInitialized } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Stargate Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Stargate\n/// @custom:version 2.2.0\ncontract StargateFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// CONSTANTS ///\n\n    /// @notice The contract address of the stargate composer on the source chain.\n    IStargateRouter private immutable composer;\n\n    /// Storage ///\n\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.facets.stargate\");\n\n    /// Types ///\n\n    struct Storage {\n        mapping(uint256 => uint16) layerZeroChainId;\n        bool initialized;\n    }\n\n    struct ChainIdConfig {\n        uint256 chainId;\n        uint16 layerZeroChainId;\n    }\n\n    /// @param srcPoolId Source pool id.\n    /// @param dstPoolId Dest pool id.\n    /// @param minAmountLD The min qty you would accept on the destination.\n    /// @param dstGasForCall Additional gas fee for extral call on the destination.\n    /// @param lzFee Estimated message fee.\n    /// @param refundAddress Refund adddress. Extra gas (if any) is returned to this address\n    /// @param callTo The address to send the tokens to on the destination.\n    /// @param callData Additional payload.\n    struct StargateData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        uint256 minAmountLD;\n        uint256 dstGasForCall;\n        uint256 lzFee;\n        address payable refundAddress;\n        bytes callTo;\n        bytes callData;\n    }\n\n    /// Errors ///\n\n    error UnknownLayerZeroChain();\n\n    /// Events ///\n\n    event StargateInitialized(ChainIdConfig[] chainIdConfigs);\n\n    event LayerZeroChainIdSet(\n        uint256 indexed chainId,\n        uint16 layerZeroChainId\n    );\n\n    /// @notice Emit to get credited for referral\n    /// @dev Our partner id is 0x0006\n    event PartnerSwap(bytes2 partnerId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _composer The contract address of the stargate composer router on the source chain.\n    constructor(IStargateRouter _composer) {\n        composer = _composer;\n    }\n\n    /// Init ///\n\n    /// @notice Initialize local variables for the Stargate Facet\n    /// @param chainIdConfigs Chain Id configuration data\n    function initStargate(ChainIdConfig[] calldata chainIdConfigs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        Storage storage sm = getStorage();\n\n        for (uint256 i = 0; i < chainIdConfigs.length; i++) {\n            sm.layerZeroChainId[chainIdConfigs[i].chainId] = chainIdConfigs[i]\n                .layerZeroChainId;\n        }\n\n        sm.initialized = true;\n\n        emit StargateInitialized(chainIdConfigs);\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function startBridgeTokensViaStargate(\n        ILiFi.BridgeData calldata _bridgeData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _stargateData);\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    /// @notice Performs a swap before bridging via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _stargateData Data specific to Stargate Bridge\n    function swapAndStartBridgeTokensViaStargate(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _stargateData);\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _stargateData.lzFee\n        );\n\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    function quoteLayerZeroFee(\n        uint256 _destinationChainId,\n        StargateData calldata _stargateData\n    ) external view returns (uint256, uint256) {\n        return\n            composer.quoteLayerZeroFee(\n                getLayerZeroChainId(_destinationChainId),\n                1, // TYPE_SWAP_REMOTE on Bridge\n                _stargateData.callTo,\n                _stargateData.callData,\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                )\n            );\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        StargateData calldata _stargateData\n    ) private {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            composer.swapETHAndCall{\n                value: _bridgeData.minAmount + _stargateData.lzFee\n            }(\n                getLayerZeroChainId(_bridgeData.destinationChainId),\n                _stargateData.refundAddress,\n                _stargateData.callTo,\n                IStargateRouter.SwapAmount(\n                    _bridgeData.minAmount,\n                    _stargateData.minAmountLD\n                ),\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                ),\n                _stargateData.callData\n            );\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                address(composer),\n                _bridgeData.minAmount\n            );\n\n            composer.swap{ value: _stargateData.lzFee }(\n                getLayerZeroChainId(_bridgeData.destinationChainId),\n                _stargateData.srcPoolId,\n                _stargateData.dstPoolId,\n                _stargateData.refundAddress,\n                _bridgeData.minAmount,\n                _stargateData.minAmountLD,\n                IStargateRouter.lzTxObj(\n                    _stargateData.dstGasForCall,\n                    0,\n                    toBytes(address(0))\n                ),\n                _stargateData.callTo,\n                _stargateData.callData\n            );\n        }\n\n        emit PartnerSwap(0x0006);\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        StargateData calldata _stargateData\n    ) private pure {\n        if (\n            (_stargateData.callData.length > 0) !=\n            _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n\n    /// Mappings management ///\n\n    /// @notice Sets the Layer 0 chain ID for a given chain ID\n    /// @param _chainId uint16 of the chain ID\n    /// @param _layerZeroChainId uint16 of the Layer 0 chain ID\n    /// @dev This is used to map a chain ID to its Layer 0 chain ID\n    function setLayerZeroChainId(\n        uint256 _chainId,\n        uint16 _layerZeroChainId\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        Storage storage sm = getStorage();\n\n        if (!sm.initialized) {\n            revert NotInitialized();\n        }\n\n        sm.layerZeroChainId[_chainId] = _layerZeroChainId;\n        emit LayerZeroChainIdSet(_chainId, _layerZeroChainId);\n    }\n\n    /// @notice Gets the Layer 0 chain ID for a given chain ID\n    /// @param _chainId uint256 of the chain ID\n    /// @return uint16 of the Layer 0 chain ID\n    function getLayerZeroChainId(\n        uint256 _chainId\n    ) private view returns (uint16) {\n        Storage storage sm = getStorage();\n        uint16 chainId = sm.layerZeroChainId[_chainId];\n        if (chainId == 0) revert UnknownLayerZeroChain();\n        return chainId;\n    }\n\n    function toBytes(address _address) private pure returns (bytes memory) {\n        return abi.encodePacked(_address);\n    }\n\n    /// @dev fetch local storage\n    function getStorage() private pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n"
    },
    "src/Facets/StargateFacetV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IStargate, ITokenMessaging } from \"../Interfaces/IStargate.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { SafeTransferLib } from \"../../lib/solady/src/utils/SafeTransferLib.sol\";\nimport { ERC20 } from \"../../lib/solady/src/tokens/ERC20.sol\";\n\n/// @title StargateFacetV2\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through Stargate (V2)\n/// @custom:version 1.0.1\ncontract StargateFacetV2 is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    using SafeTransferLib for address;\n\n    /// STORAGE ///\n    ITokenMessaging public immutable tokenMessaging;\n\n    /// @param assetId The Stargate-specific assetId for the token that should be bridged\n    /// @param sendParams Various parameters that describe what needs to be bridged, how to bridge it and what to do with it on dst\n    /// @param fee Information about the (native) LayerZero fee that needs to be sent with the tx\n    /// @param refundAddress the address that is used for potential refunds\n    struct StargateData {\n        uint16 assetId;\n        IStargate.SendParam sendParams;\n        IStargate.MessagingFee fee;\n        address payable refundAddress;\n    }\n\n    /// ERRORS ///\n    error InvalidAssetId(uint16 invalidAssetId);\n\n    /// CONSTRUCTOR ///\n    /// @param _tokenMessaging The address of the tokenMessaging contract (used to obtain pool addresses)\n    constructor(address _tokenMessaging) {\n        tokenMessaging = ITokenMessaging(_tokenMessaging);\n    }\n\n    /// EXTERNAL METHODS ///\n\n    /// @notice Bridges tokens via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function startBridgeTokensViaStargate(\n        ILiFi.BridgeData calldata _bridgeData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    /// @notice Performs a swap before bridging via Stargate Bridge\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _stargateData Data specific to Stargate Bridge\n    function swapAndStartBridgeTokensViaStargate(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        StargateData calldata _stargateData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _stargateData.fee.nativeFee\n        );\n\n        _startBridge(_bridgeData, _stargateData);\n    }\n\n    /// PRIVATE METHODS ///\n\n    /// @dev Contains the business logic for the bridging via StargateV2\n    /// @param _bridgeData Data used purely for tracking and analytics\n    /// @param _stargateData Data specific to Stargate Bridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        StargateData memory _stargateData\n    ) private {\n        // validate destination call flag\n        if (\n            (_stargateData.sendParams.composeMsg.length > 0 !=\n                _bridgeData.hasDestinationCall) ||\n            (_bridgeData.hasDestinationCall &&\n                _stargateData.sendParams.oftCmd.length != 0)\n        ) revert InformationMismatch();\n\n        // ensure that receiver addresses match in case of no destination call\n        if (\n            !_bridgeData.hasDestinationCall &&\n            (_bridgeData.receiver !=\n                address(uint160(uint256(_stargateData.sendParams.to))))\n        ) revert InformationMismatch();\n\n        // get the router-/pool address through the TokenMessaging contract\n        address routerAddress = tokenMessaging.stargateImpls(\n            _stargateData.assetId\n        );\n        if (routerAddress == address(0))\n            revert InvalidAssetId(_stargateData.assetId);\n\n        // check if NATIVE or ERC20\n        uint256 msgValue = _stargateData.fee.nativeFee;\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // NATIVE\n            // add minAmount to msgValue\n            msgValue += _bridgeData.minAmount;\n        } else {\n            // ERC20\n            // check current allowance to router\n            address sendingAssetId = _bridgeData.sendingAssetId;\n            uint256 currentAllowance = ERC20(sendingAssetId).allowance(\n                address(this),\n                routerAddress\n            );\n            // check if allowance is sufficient\n            if (currentAllowance < _bridgeData.minAmount) {\n                // check if allowance is 0\n                if (currentAllowance != 0) {\n                    sendingAssetId.safeApprove(routerAddress, 0);\n                }\n                // set allowance to uintMax\n                sendingAssetId.safeApprove(routerAddress, type(uint256).max);\n            }\n        }\n\n        // update amount in sendParams\n        _stargateData.sendParams.amountLD = _bridgeData.minAmount;\n\n        // execute call to Stargate router\n        IStargate(routerAddress).sendToken{ value: msgValue }(\n            _stargateData.sendParams,\n            _stargateData.fee,\n            _stargateData.refundAddress\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/SymbiosisFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ISymbiosisMetaRouter } from \"../Interfaces/ISymbiosisMetaRouter.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Symbiosis Facet\n/// @author Symbiosis (https://symbiosis.finance)\n/// @notice Provides functionality for bridging through Symbiosis Protocol\n/// @custom:version 1.0.0\ncontract SymbiosisFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    /// Storage ///\n\n    /// @notice The contract address of the Symbiosis router on the source chain\n    ISymbiosisMetaRouter private immutable symbiosisMetaRouter;\n    address private immutable symbiosisGateway;\n\n    /// Types ///\n\n    /// @notice The data specific to Symbiosis\n    /// @param firstSwapCalldata The calldata for the first swap\n    /// @param secondSwapCalldata The calldata for the second swap\n    /// @param intermediateToken The intermediate token used for swapping\n    /// @param firstDexRouter The router for the first swap\n    /// @param secondDexRouter The router for the second swap\n    /// @param approvedTokens The tokens approved for swapping\n    /// @param callTo The bridging entrypoint\n    /// @param callData The bridging calldata\n    struct SymbiosisData {\n        bytes firstSwapCalldata;\n        bytes secondSwapCalldata;\n        address intermediateToken;\n        address firstDexRouter;\n        address secondDexRouter;\n        address[] approvedTokens;\n        address callTo;\n        bytes callData;\n    }\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _symbiosisMetaRouter The contract address of the Symbiosis MetaRouter on the source chain.\n    /// @param _symbiosisGateway The contract address of the Symbiosis Gateway on the source chain.\n    constructor(\n        ISymbiosisMetaRouter _symbiosisMetaRouter,\n        address _symbiosisGateway\n    ) {\n        symbiosisMetaRouter = _symbiosisMetaRouter;\n        symbiosisGateway = _symbiosisGateway;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via Symbiosis\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _symbiosisData The data specific to Symbiosis\n    function startBridgeTokensViaSymbiosis(\n        ILiFi.BridgeData memory _bridgeData,\n        SymbiosisData calldata _symbiosisData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n\n        _startBridge(_bridgeData, _symbiosisData);\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before bridging via Symbiosis\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _symbiosisData The data specific to Symbiosis\n    function swapAndStartBridgeTokensViaSymbiosis(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        SymbiosisData calldata _symbiosisData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        _startBridge(_bridgeData, _symbiosisData);\n    }\n\n    /// @dev Contains the business logic for the bridge via Symbiosis\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _symbiosisData data specific to Symbiosis\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        SymbiosisData calldata _symbiosisData\n    ) internal {\n        bool isNative = LibAsset.isNativeAsset(_bridgeData.sendingAssetId);\n        uint256 nativeAssetAmount;\n\n        if (isNative) {\n            nativeAssetAmount = _bridgeData.minAmount;\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                symbiosisGateway,\n                _bridgeData.minAmount\n            );\n        }\n\n        symbiosisMetaRouter.metaRoute{ value: nativeAssetAmount }(\n            ISymbiosisMetaRouter.MetaRouteTransaction(\n                _symbiosisData.firstSwapCalldata,\n                _symbiosisData.secondSwapCalldata,\n                _symbiosisData.approvedTokens,\n                _symbiosisData.firstDexRouter,\n                _symbiosisData.secondDexRouter,\n                _bridgeData.minAmount,\n                isNative,\n                _symbiosisData.callTo,\n                _symbiosisData.callData\n            )\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/ThorSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IThorSwap } from \"../Interfaces/IThorSwap.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2 } from \"../Helpers/SwapperV2.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ContractCallNotAllowed } from \"../Errors/GenericErrors.sol\";\n\n/// @title ThorSwap Facet\n/// @author Li.Finance (https://li.finance)\n/// @notice Provides functionality for bridging through ThorSwap\n/// @custom:version 1.2.0\ncontract ThorSwapFacet is ILiFi, ReentrancyGuard, SwapperV2, Validatable {\n    address private immutable thorchainRouter;\n\n    /// @notice The struct for the ThorSwap data.\n    /// @param vault The Thorchain vault address\n    /// @param memo The memo to send to Thorchain for the swap\n    /// @param expiration The expiration time for the swap\n    struct ThorSwapData {\n        address vault;\n        string memo;\n        uint256 expiration;\n    }\n\n    /// @notice Initializes the ThorSwap contract\n    constructor(address _thorchainRouter) {\n        thorchainRouter = _thorchainRouter;\n    }\n\n    /// @notice Bridge tokens to another chain via ThorSwap\n    /// @param _bridgeData The bridge data struct\n    /// @param _thorSwapData The ThorSwap data struct\n    function startBridgeTokensViaThorSwap(\n        ILiFi.BridgeData memory _bridgeData,\n        ThorSwapData calldata _thorSwapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        validateBridgeData(_bridgeData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        LibAsset.depositAsset(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount\n        );\n        _startBridge(_bridgeData, _thorSwapData);\n    }\n\n    /// @notice Bridge tokens to another chain via ThorSwap\n    /// @param _bridgeData The bridge data struct\n    /// @param _swapData The swap data struct\n    /// @param _thorSwapData The ThorSwap data struct\n    function swapAndStartBridgeTokensViaThorSwap(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        ThorSwapData calldata _thorSwapData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        _startBridge(_bridgeData, _thorSwapData);\n    }\n\n    /// @notice Bridge tokens to another chain via ThorSwap\n    /// @param _bridgeData The bridge data struct\n    /// @param _thorSwapData The thorSwap data struct for ThorSwap specicific data\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        ThorSwapData calldata _thorSwapData\n    ) internal {\n        IERC20 sendingAssetId = IERC20(_bridgeData.sendingAssetId);\n        bool isNative = LibAsset.isNativeAsset(address(sendingAssetId));\n\n        if (!isNative) {\n            LibAsset.maxApproveERC20(\n                sendingAssetId,\n                thorchainRouter,\n                _bridgeData.minAmount\n            );\n        }\n        IThorSwap(thorchainRouter).depositWithExpiry{\n            value: isNative ? _bridgeData.minAmount : 0\n        }(\n            _thorSwapData.vault,\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount,\n            _thorSwapData.memo,\n            _thorSwapData.expiration\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"
    },
    "src/Facets/WithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibAccess } from \"../Libraries/LibAccess.sol\";\nimport { NotAContract } from \"../Errors/GenericErrors.sol\";\n\n/// @title Withdraw Facet\n/// @author LI.FI (https://li.fi)\n/// @notice Allows admin to withdraw funds that are kept in the contract by accident\n/// @custom:version 1.0.0\ncontract WithdrawFacet {\n    /// Errors ///\n\n    error WithdrawFailed();\n\n    /// Events ///\n\n    event LogWithdraw(\n        address indexed _assetAddress,\n        address _to,\n        uint256 amount\n    );\n\n    /// External Methods ///\n\n    /// @notice Execute call data and withdraw asset.\n    /// @param _callTo The address to execute the calldata on.\n    /// @param _callData The data to execute.\n    /// @param _assetAddress Asset to be withdrawn.\n    /// @param _to address to withdraw to.\n    /// @param _amount amount of asset to withdraw.\n    function executeCallAndWithdraw(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n\n        // Check if the _callTo is a contract\n        bool success;\n        bool isContract = LibAsset.isContract(_callTo);\n        if (!isContract) revert NotAContract();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ) = _callTo.call(_callData);\n\n        if (success) {\n            _withdrawAsset(_assetAddress, _to, _amount);\n        } else {\n            revert WithdrawFailed();\n        }\n    }\n\n    /// @notice Withdraw asset.\n    /// @param _assetAddress Asset to be withdrawn.\n    /// @param _to address to withdraw to.\n    /// @param _amount amount of asset to withdraw.\n    function withdraw(\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external {\n        if (msg.sender != LibDiamond.contractOwner()) {\n            LibAccess.enforceAccessControl();\n        }\n        _withdrawAsset(_assetAddress, _to, _amount);\n    }\n\n    /// Internal Methods ///\n\n    /// @notice Withdraw asset.\n    /// @param _assetAddress Asset to be withdrawn.\n    /// @param _to address to withdraw to.\n    /// @param _amount amount of asset to withdraw.\n    function _withdrawAsset(\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) internal {\n        address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n        LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n        emit LogWithdraw(_assetAddress, sendTo, _amount);\n    }\n}\n"
    },
    "src/Helpers/CelerIMFacetBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ERC20 } from \"../../lib/solmate/src/tokens/ERC20.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { InvalidAmount, InformationMismatch } from \"../Errors/GenericErrors.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\nimport { MessageSenderLib, MsgDataTypes, IMessageBus } from \"../../lib/sgn-v2-contracts/contracts/message/libraries/MessageSenderLib.sol\";\nimport { RelayerCelerIM } from \"../../src/Periphery/RelayerCelerIM.sol\";\n\ninterface CelerToken {\n    function canonical() external returns (address);\n}\n\ninterface CelerIM {\n    /// @param maxSlippage The max slippage accepted, given as percentage in point (pip).\n    /// @param nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n    /// @param callTo The address of the contract to be called at destination.\n    /// @param callData The encoded calldata with below data\n    ///                 bytes32 transactionId,\n    ///                 LibSwap.SwapData[] memory swapData,\n    ///                 address receiver,\n    ///                 address refundAddress\n    /// @param messageBusFee The fee to be paid to CBridge message bus for relaying the message\n    /// @param bridgeType Defines the bridge operation type (must be one of the values of CBridge library MsgDataTypes.BridgeSendType)\n    struct CelerIMData {\n        uint32 maxSlippage;\n        uint64 nonce;\n        bytes callTo;\n        bytes callData;\n        uint256 messageBusFee;\n        MsgDataTypes.BridgeSendType bridgeType;\n    }\n}\n\n/// @title CelerIM Facet Base\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging tokens and data through CBridge\n/// @notice Used to differentiate between contract instances for mutable and immutable diamond as these cannot be shared\n/// @custom:version 2.0.0\nabstract contract CelerIMFacetBase is\n    ILiFi,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Storage ///\n\n    /// @dev The contract address of the cBridge Message Bus\n    IMessageBus private immutable cBridgeMessageBus;\n\n    /// @dev The contract address of the RelayerCelerIM\n    RelayerCelerIM public immutable relayer;\n\n    /// @dev The contract address of the Celer Flow USDC\n    address private immutable cfUSDC;\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _messageBus The contract address of the cBridge Message Bus\n    /// @param _relayerOwner The address that will become the owner of the RelayerCelerIM contract\n    /// @param _diamondAddress The address of the diamond contract that will be connected with the RelayerCelerIM\n    /// @param _cfUSDC The contract address of the Celer Flow USDC\n    constructor(\n        IMessageBus _messageBus,\n        address _relayerOwner,\n        address _diamondAddress,\n        address _cfUSDC\n    ) {\n        // deploy RelayerCelerIM\n        relayer = new RelayerCelerIM(\n            address(_messageBus),\n            _relayerOwner,\n            _diamondAddress\n        );\n\n        // store arguments in variables\n        cBridgeMessageBus = _messageBus;\n        cfUSDC = _cfUSDC;\n    }\n\n    /// External Methods ///\n\n    /// @notice Bridges tokens via CBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _celerIMData Data specific to CelerIM\n    function startBridgeTokensViaCelerIM(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        doesNotContainSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _celerIMData);\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Transfer ERC20 tokens directly to relayer\n            IERC20 asset = _getRightAsset(_bridgeData.sendingAssetId);\n\n            // Deposit ERC20 token\n            uint256 prevBalance = asset.balanceOf(address(relayer));\n            SafeERC20.safeTransferFrom(\n                asset,\n                msg.sender,\n                address(relayer),\n                _bridgeData.minAmount\n            );\n\n            if (\n                asset.balanceOf(address(relayer)) - prevBalance !=\n                _bridgeData.minAmount\n            ) {\n                revert InvalidAmount();\n            }\n        }\n\n        _startBridge(_bridgeData, _celerIMData);\n    }\n\n    /// @notice Performs a swap before bridging via CBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _swapData An array of swap related data for performing swaps before bridging\n    /// @param _celerIMData Data specific to CelerIM\n    function swapAndStartBridgeTokensViaCelerIM(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        CelerIM.CelerIMData calldata _celerIMData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        validateDestinationCallFlag(_bridgeData, _celerIMData);\n\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _celerIMData.messageBusFee\n        );\n\n        if (!LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            // Transfer ERC20 tokens directly to relayer\n            IERC20 asset = _getRightAsset(_bridgeData.sendingAssetId);\n\n            // Deposit ERC20 token\n            uint256 prevBalance = asset.balanceOf(address(relayer));\n            SafeERC20.safeTransfer(\n                asset,\n                address(relayer),\n                _bridgeData.minAmount\n            );\n\n            if (\n                asset.balanceOf(address(relayer)) - prevBalance !=\n                _bridgeData.minAmount\n            ) {\n                revert InvalidAmount();\n            }\n        }\n\n        _startBridge(_bridgeData, _celerIMData);\n    }\n\n    /// Private Methods ///\n\n    /// @dev Contains the business logic for the bridge via CBridge\n    /// @param _bridgeData The core information needed for bridging\n    /// @param _celerIMData Data specific to CBridge\n    function _startBridge(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    ) private {\n        // Assuming messageBusFee is pre-calculated off-chain and available in _celerIMData\n        // Determine correct native asset amount to be forwarded (if so) and send funds to relayer\n        uint256 msgValue = LibAsset.isNativeAsset(_bridgeData.sendingAssetId)\n            ? _bridgeData.minAmount\n            : 0;\n\n        // Check if transaction contains a destination call\n        if (!_bridgeData.hasDestinationCall) {\n            // Case 'no': Simple bridge transfer - Send to receiver\n            relayer.sendTokenTransfer{ value: msgValue }(\n                _bridgeData,\n                _celerIMData\n            );\n        } else {\n            // Case 'yes': Bridge + Destination call - Send to relayer\n\n            // save address of original recipient\n            address receiver = _bridgeData.receiver;\n\n            // Set relayer as a receiver\n            _bridgeData.receiver = address(relayer);\n\n            // send token transfer\n            (bytes32 transferId, address bridgeAddress) = relayer\n                .sendTokenTransfer{ value: msgValue }(\n                _bridgeData,\n                _celerIMData\n            );\n\n            // Call message bus via relayer incl messageBusFee\n            relayer.forwardSendMessageWithTransfer{\n                value: _celerIMData.messageBusFee\n            }(\n                _bridgeData.receiver,\n                uint64(_bridgeData.destinationChainId),\n                bridgeAddress,\n                transferId,\n                _celerIMData.callData\n            );\n\n            // Reset receiver of bridge data for event emission\n            _bridgeData.receiver = receiver;\n        }\n\n        // emit LiFi event\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @dev Get right asset to transfer to relayer.\n    /// @param _sendingAssetId The address of asset to bridge.\n    /// @return _asset The address of asset to transfer to relayer.\n    function _getRightAsset(\n        address _sendingAssetId\n    ) private returns (IERC20 _asset) {\n        if (_sendingAssetId == cfUSDC) {\n            // special case for cfUSDC token\n            _asset = IERC20(CelerToken(_sendingAssetId).canonical());\n        } else {\n            // any other ERC20 token\n            _asset = IERC20(_sendingAssetId);\n        }\n    }\n\n    function validateDestinationCallFlag(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    ) private pure {\n        if (\n            (_celerIMData.callData.length > 0) !=\n            _bridgeData.hasDestinationCall\n        ) {\n            revert InformationMismatch();\n        }\n    }\n}\n"
    },
    "src/Helpers/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n// This contract has been taken from: https://github.com/nomad-xyz/ExcessivelySafeCall\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { InvalidCallData } from \"../Errors/GenericErrors.sol\";\n\n// solhint-disable no-inline-assembly\nlibrary ExcessivelySafeCall {\n    uint256 private constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(\n        bytes4 _newSelector,\n        bytes memory _buf\n    ) internal pure {\n        if (_buf.length < 4) {\n            revert InvalidCallData();\n        }\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "src/Helpers/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\n/// @title Reentrancy Guard\n/// @author LI.FI (https://li.fi)\n/// @notice Abstract contract to provide protection against reentrancy\nabstract contract ReentrancyGuard {\n    /// Storage ///\n\n    bytes32 private constant NAMESPACE = keccak256(\"com.lifi.reentrancyguard\");\n\n    /// Types ///\n\n    struct ReentrancyStorage {\n        uint256 status;\n    }\n\n    /// Errors ///\n\n    error ReentrancyError();\n\n    /// Constants ///\n\n    uint256 private constant _NOT_ENTERED = 0;\n    uint256 private constant _ENTERED = 1;\n\n    /// Modifiers ///\n\n    modifier nonReentrant() {\n        ReentrancyStorage storage s = reentrancyStorage();\n        if (s.status == _ENTERED) revert ReentrancyError();\n        s.status = _ENTERED;\n        _;\n        s.status = _NOT_ENTERED;\n    }\n\n    /// Private Methods ///\n\n    /// @dev fetch local storage\n    function reentrancyStorage()\n        private\n        pure\n        returns (ReentrancyStorage storage data)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data.slot := position\n        }\n    }\n}\n"
    },
    "src/Helpers/SwapperV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibAllowList } from \"../Libraries/LibAllowList.sol\";\nimport { ContractCallNotAllowed, NoSwapDataProvided, CumulativeSlippageTooHigh } from \"../Errors/GenericErrors.sol\";\n\n/// @title Swapper\n/// @author LI.FI (https://li.fi)\n/// @notice Abstract contract to provide swap functionality\ncontract SwapperV2 is ILiFi {\n    /// Types ///\n\n    /// @dev only used to get around \"Stack Too Deep\" errors\n    struct ReserveData {\n        bytes32 transactionId;\n        address payable leftoverReceiver;\n        uint256 nativeReserve;\n    }\n\n    /// Modifiers ///\n\n    /// @dev Sends any leftover balances back to the user\n    /// @notice Sends any leftover balances to the user\n    /// @param _swaps Swap data array\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial token balances\n    modifier noLeftovers(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance =\n                        LibAsset.getOwnBalance(curAsset) -\n                        _initialBalances[i];\n                    if (curBalance > 0) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// @dev Sends any leftover balances back to the user reserving native tokens\n    /// @notice Sends any leftover balances to the user\n    /// @param _swaps Swap data array\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial token balances\n    modifier noLeftoversReserve(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances,\n        uint256 _nativeReserve\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance =\n                        LibAsset.getOwnBalance(curAsset) -\n                        _initialBalances[i];\n                    uint256 reserve = LibAsset.isNativeAsset(curAsset)\n                        ? _nativeReserve\n                        : 0;\n                    if (curBalance > 0) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance - reserve\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// @dev Refunds any excess native asset sent to the contract after the main function\n    /// @notice Refunds any excess native asset sent to the contract after the main function\n    /// @param _refundReceiver Address to send refunds to\n    modifier refundExcessNative(address payable _refundReceiver) {\n        uint256 initialBalance = address(this).balance - msg.value;\n        _;\n        uint256 finalBalance = address(this).balance;\n\n        if (finalBalance > initialBalance) {\n            LibAsset.transferAsset(\n                LibAsset.NATIVE_ASSETID,\n                _refundReceiver,\n                finalBalance - initialBalance\n            );\n        }\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Deposits value, executes swaps, and performs minimum amount check\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver The address to send leftover funds to\n    /// @return uint256 result of the swap\n    function _depositAndSwap(\n        bytes32 _transactionId,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver\n    ) internal returns (uint256) {\n        uint256 numSwaps = _swaps.length;\n\n        if (numSwaps == 0) {\n            revert NoSwapDataProvided();\n        }\n\n        address finalTokenId = _swaps[numSwaps - 1].receivingAssetId;\n        uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId);\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            initialBalance -= msg.value;\n        }\n\n        uint256[] memory initialBalances = _fetchBalances(_swaps);\n\n        LibAsset.depositAssets(_swaps);\n        _executeSwaps(\n            _transactionId,\n            _swaps,\n            _leftoverReceiver,\n            initialBalances\n        );\n\n        uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance;\n\n        if (newBalance < _minAmount) {\n            revert CumulativeSlippageTooHigh(_minAmount, newBalance);\n        }\n\n        return newBalance;\n    }\n\n    /// @dev Deposits value, executes swaps, and performs minimum amount check and reserves native token for fees\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver The address to send leftover funds to\n    /// @param _nativeReserve Amount of native token to prevent from being swept back to the caller\n    function _depositAndSwap(\n        bytes32 _transactionId,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256 _nativeReserve\n    ) internal returns (uint256) {\n        uint256 numSwaps = _swaps.length;\n\n        if (numSwaps == 0) {\n            revert NoSwapDataProvided();\n        }\n\n        address finalTokenId = _swaps[numSwaps - 1].receivingAssetId;\n        uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId);\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            initialBalance -= msg.value;\n        }\n\n        uint256[] memory initialBalances = _fetchBalances(_swaps);\n\n        LibAsset.depositAssets(_swaps);\n        ReserveData memory rd = ReserveData(\n            _transactionId,\n            _leftoverReceiver,\n            _nativeReserve\n        );\n        _executeSwaps(rd, _swaps, initialBalances);\n\n        uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance;\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            newBalance -= _nativeReserve;\n        }\n\n        if (newBalance < _minAmount) {\n            revert CumulativeSlippageTooHigh(_minAmount, newBalance);\n        }\n\n        return newBalance;\n    }\n\n    /// Private Methods ///\n\n    /// @dev Executes swaps and checks that DEXs used are in the allowList\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial balances\n    function _executeSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances\n    ) internal noLeftovers(_swaps, _leftoverReceiver, _initialBalances) {\n        uint256 numSwaps = _swaps.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            LibSwap.SwapData calldata currentSwap = _swaps[i];\n\n            if (\n                !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) ||\n                    LibAllowList.contractIsAllowed(currentSwap.approveTo)) &&\n                    LibAllowList.contractIsAllowed(currentSwap.callTo) &&\n                    LibAllowList.selectorIsAllowed(\n                        bytes4(currentSwap.callData[:4])\n                    ))\n            ) revert ContractCallNotAllowed();\n\n            LibSwap.swap(_transactionId, currentSwap);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Executes swaps and checks that DEXs used are in the allowList\n    /// @param _reserveData Data passed used to reserve native tokens\n    /// @param _swaps Array of data used to execute swaps\n    function _executeSwaps(\n        ReserveData memory _reserveData,\n        LibSwap.SwapData[] calldata _swaps,\n        uint256[] memory _initialBalances\n    )\n        internal\n        noLeftoversReserve(\n            _swaps,\n            _reserveData.leftoverReceiver,\n            _initialBalances,\n            _reserveData.nativeReserve\n        )\n    {\n        uint256 numSwaps = _swaps.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            LibSwap.SwapData calldata currentSwap = _swaps[i];\n\n            if (\n                !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) ||\n                    LibAllowList.contractIsAllowed(currentSwap.approveTo)) &&\n                    LibAllowList.contractIsAllowed(currentSwap.callTo) &&\n                    LibAllowList.selectorIsAllowed(\n                        bytes4(currentSwap.callData[:4])\n                    ))\n            ) revert ContractCallNotAllowed();\n\n            LibSwap.swap(_reserveData.transactionId, currentSwap);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Fetches balances of tokens to be swapped before swapping.\n    /// @param _swaps Array of data used to execute swaps\n    /// @return uint256[] Array of token balances.\n    function _fetchBalances(\n        LibSwap.SwapData[] calldata _swaps\n    ) private view returns (uint256[] memory) {\n        uint256 numSwaps = _swaps.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swaps[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }\n}\n"
    },
    "src/Helpers/TransferrableOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { IERC173 } from \"../Interfaces/IERC173.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\ncontract TransferrableOwnership is IERC173 {\n    address public owner;\n    address public pendingOwner;\n\n    /// Errors ///\n    error UnAuthorized();\n    error NoNullOwner();\n    error NewOwnerMustNotBeSelf();\n    error NoPendingOwnershipTransfer();\n    error NotPendingOwner();\n\n    /// Events ///\n    event OwnershipTransferRequested(\n        address indexed _from,\n        address indexed _to\n    );\n\n    constructor(address initialOwner) {\n        owner = initialOwner;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert UnAuthorized();\n        _;\n    }\n\n    /// @notice Initiates transfer of ownership to a new address\n    /// @param _newOwner the address to transfer ownership to\n    function transferOwnership(address _newOwner) external onlyOwner {\n        if (_newOwner == LibAsset.NULL_ADDRESS) revert NoNullOwner();\n        if (_newOwner == msg.sender) revert NewOwnerMustNotBeSelf();\n        pendingOwner = _newOwner;\n        emit OwnershipTransferRequested(msg.sender, pendingOwner);\n    }\n\n    /// @notice Cancel transfer of ownership\n    function cancelOwnershipTransfer() external onlyOwner {\n        if (pendingOwner == LibAsset.NULL_ADDRESS)\n            revert NoPendingOwnershipTransfer();\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }\n\n    /// @notice Confirms transfer of ownership to the calling address (msg.sender)\n    function confirmOwnershipTransfer() external {\n        address _pendingOwner = pendingOwner;\n        if (msg.sender != _pendingOwner) revert NotPendingOwner();\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }\n}\n"
    },
    "src/Helpers/Validatable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { InvalidReceiver, InformationMismatch, InvalidSendingToken, InvalidAmount, NativeAssetNotSupported, InvalidDestinationChain, CannotBridgeToSameNetwork } from \"../Errors/GenericErrors.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\ncontract Validatable {\n    modifier validateBridgeData(ILiFi.BridgeData memory _bridgeData) {\n        if (LibUtil.isZeroAddress(_bridgeData.receiver)) {\n            revert InvalidReceiver();\n        }\n        if (_bridgeData.minAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (_bridgeData.destinationChainId == block.chainid) {\n            revert CannotBridgeToSameNetwork();\n        }\n        _;\n    }\n\n    modifier noNativeAsset(ILiFi.BridgeData memory _bridgeData) {\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n            revert NativeAssetNotSupported();\n        }\n        _;\n    }\n\n    modifier onlyAllowSourceToken(\n        ILiFi.BridgeData memory _bridgeData,\n        address _token\n    ) {\n        if (_bridgeData.sendingAssetId != _token) {\n            revert InvalidSendingToken();\n        }\n        _;\n    }\n\n    modifier onlyAllowDestinationChain(\n        ILiFi.BridgeData memory _bridgeData,\n        uint256 _chainId\n    ) {\n        if (_bridgeData.destinationChainId != _chainId) {\n            revert InvalidDestinationChain();\n        }\n        _;\n    }\n\n    modifier containsSourceSwaps(ILiFi.BridgeData memory _bridgeData) {\n        if (!_bridgeData.hasSourceSwaps) {\n            revert InformationMismatch();\n        }\n        _;\n    }\n\n    modifier doesNotContainSourceSwaps(ILiFi.BridgeData memory _bridgeData) {\n        if (_bridgeData.hasSourceSwaps) {\n            revert InformationMismatch();\n        }\n        _;\n    }\n\n    modifier doesNotContainDestinationCalls(\n        ILiFi.BridgeData memory _bridgeData\n    ) {\n        if (_bridgeData.hasDestinationCall) {\n            revert InformationMismatch();\n        }\n        _;\n    }\n}\n"
    },
    "src/Interfaces/IAcrossSpokePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IAcrossSpokePool {\n    function deposit(\n        address recipient, // Recipient address\n        address originToken, // Address of the token\n        uint256 amount, // Token amount\n        uint256 destinationChainId, //  id\n        int64 relayerFeePct, // see #Fees Calculation\n        uint32 quoteTimestamp, // Timestamp for the quote creation\n        bytes memory message, // Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n        uint256 maxCount // Used to protect the depositor from frontrunning to guarantee their quote remains valid.\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IAllBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\n/// @title AllBridge Interface\ninterface IAllBridge {\n    /// @dev AllBridge Messenger Protocol Enum\n    enum MessengerProtocol {\n        None,\n        Allbridge,\n        Wormhole,\n        LayerZero\n    }\n\n    function pools(bytes32 addr) external returns (address);\n\n    function swapAndBridge(\n        bytes32 token,\n        uint256 amount,\n        bytes32 recipient,\n        uint256 destinationChainId,\n        bytes32 receiveToken,\n        uint256 nonce,\n        MessengerProtocol messenger,\n        uint256 feeTokenAmount\n    ) external payable;\n\n    function getTransactionCost(\n        uint256 chainId\n    ) external view returns (uint256);\n\n    function getMessageCost(\n        uint256 chainId,\n        MessengerProtocol protocol\n    ) external view returns (uint256);\n\n    function getBridgingCostInTokens(\n        uint256 destinationChainId,\n        MessengerProtocol messenger,\n        address tokenAddress\n    ) external view returns (uint256);\n}\n"
    },
    "src/Interfaces/ICBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface ICBridge {\n    /// @notice Send a cross-chain transfer via the liquidity pool-based bridge.\n    /// @dev This function DOES NOT SUPPORT fee-on-transfer / rebasing tokens.\n    /// @param _receiver The address of the receiver.\n    /// @param _token The address of the token.\n    /// @param _amount The amount of the transfer.\n    /// @param _dstChainId The destination chain ID.\n    /// @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.\n    /// @param _maxSlippage The max slippage accepted, given as percentage in point (pip).\n    ///                     Eg. 5000 means 0.5%. Must be greater than minimalMaxSlippage.\n    ///                     Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount\n    ///                     or the transfer can be refunded.\n    function send(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    /// @notice Send a cross-chain transfer via the liquidity pool-based bridge using the native token.\n    /// @param _receiver The address of the receiver.\n    /// @param _amount The amount of the transfer.\n    /// @param _dstChainId The destination chain ID.\n    /// @param _nonce A unique number. Can be timestamp in practice.\n    /// @param _maxSlippage The max slippage accepted, given as percentage in point (pip).\n    ///                     Eg. 5000 means 0.5%. Must be greater than minimalMaxSlippage.\n    ///                     Receiver is guaranteed to receive at least (100% - max slippage percentage) * amount\n    ///                     or the transfer can be refunded.\n    function sendNative(\n        address _receiver,\n        uint256 _amount,\n        uint64 _dstChainId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external payable;\n}\n"
    },
    "src/Interfaces/ICircleBridgeProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface ICircleBridgeProxy {\n    /// @notice Deposits and burns tokens from sender to be minted on destination domain.\n    /// @dev reverts if:\n    ///      - given burnToken is not supported.\n    ///      - given destinationDomain has no TokenMessenger registered.\n    ///      - transferFrom() reverts. For example, if sender's burnToken balance\n    ///        or approved allowance to this contract is less than `amount`.\n    ///      - burn() reverts. For example, if `amount` is 0.\n    ///      - MessageTransmitter returns false or reverts.\n    /// @param _amount Amount of tokens to burn.\n    /// @param _dstChid Destination domain.\n    /// @param _mintRecipient Address of mint recipient on destination domain.\n    /// @param _burnToken Address of contract to burn deposited tokens, on local domain.\n    /// @return nonce Unique nonce reserved by message.\n    function depositForBurn(\n        uint256 _amount,\n        uint64 _dstChid,\n        bytes32 _mintRecipient,\n        address _burnToken\n    ) external returns (uint64 nonce);\n}\n"
    },
    "src/Interfaces/IConnextHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IConnextHandler {\n    /// @notice These are the call parameters that will remain constant between the\n    /// two chains. They are supplied on `xcall` and should be asserted on `execute`\n    /// @property to - The account that receives funds, in the event of a crosschain call,\n    /// will receive funds if the call fails.\n    /// @param to - The address you are sending funds (and potentially data) to\n    /// @param callData - The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\n    /// @param originDomain - The originating domain (i.e. where `xcall` is called). Must match nomad domain schema\n    /// @param destinationDomain - The final domain (i.e. where `execute` / `reconcile` are called). Must match nomad domain schema\n    /// @param agent - An address who can execute txs on behalf of `to`, in addition to allowing relayers\n    /// @param recovery - The address to send funds to if your `Executor.execute call` fails\n    /// @param forceSlow - If true, will take slow liquidity path even if it is not a permissioned call\n    /// @param receiveLocal - If true, will use the local nomad asset on the destination instead of adopted.\n    /// @param callback - The address on the origin domain of the callback contract\n    /// @param callbackFee - The relayer fee to execute the callback\n    /// @param relayerFee - The amount of relayer fee the tx called xcall with\n    /// @param slippageTol - Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\n    struct CallParams {\n        address to;\n        bytes callData;\n        uint32 originDomain;\n        uint32 destinationDomain;\n        address agent;\n        address recovery;\n        bool forceSlow;\n        bool receiveLocal;\n        address callback;\n        uint256 callbackFee;\n        uint256 relayerFee;\n        uint256 slippageTol;\n    }\n\n    /// @notice The arguments you supply to the `xcall` function called by user on origin domain\n    /// @param params - The CallParams. These are consistent across sending and receiving chains\n    /// @param transactingAsset - The asset the caller sent with the transfer. Can be the adopted, canonical,\n    /// or the representational asset\n    /// @param transactingAmount - The amount of transferring asset supplied by the user in the `xcall`\n    /// @param originMinOut - Minimum amount received on swaps for adopted <> local on origin chain\n    struct XCallArgs {\n        CallParams params;\n        address transactingAsset; // Could be adopted, local, or wrapped\n        uint256 transactingAmount;\n        uint256 originMinOut;\n    }\n\n    function xcall(\n        uint32 destination,\n        address recipient,\n        address tokenAddress,\n        address delegate,\n        uint256 amount,\n        uint256 slippage,\n        bytes memory callData\n    ) external payable returns (bytes32);\n\n    function xcall(\n        uint32 destination,\n        address recipient,\n        address tokenAddress,\n        address delegate,\n        uint256 amount,\n        uint256 slippage,\n        bytes memory callData,\n        uint256 _relayerFee\n    ) external returns (bytes32);\n}\n"
    },
    "src/Interfaces/IDeBridgeGate.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IDeBridgeGate {\n    /// @param fixedNativeFee Transfer fixed fee.\n    /// @param isSupported Whether the chain for the asset is supported.\n    /// @param transferFeeBps Transfer fee rate nominated in basis points (1/10000)\n    ///                       of transferred amount.\n    struct ChainSupportInfo {\n        uint256 fixedNativeFee;\n        bool isSupported;\n        uint16 transferFeeBps;\n    }\n\n    /// @dev Fallback fixed fee in native asset, used if a chain fixed fee is set to 0\n    function globalFixedNativeFee() external view returns (uint256);\n\n    /// @dev Whether the chain for the asset is supported to send\n    function getChainToConfig(\n        uint256\n    ) external view returns (ChainSupportInfo memory);\n\n    /// @dev This method is used for the transfer of assets.\n    ///      It locks an asset in the smart contract in the native chain\n    ///      and enables minting of deAsset on the secondary chain.\n    /// @param _tokenAddress Asset identifier.\n    /// @param _amount Amount to be transferred (note: the fee can be applied).\n    /// @param _chainIdTo Chain id of the target chain.\n    /// @param _receiver Receiver address.\n    /// @param _permit deadline + signature for approving the spender by signature.\n    /// @param _useAssetFee use assets fee for pay protocol fix (work only for specials token)\n    /// @param _referralCode Referral code\n    /// @param _autoParams Auto params for external call in target network\n    function send(\n        address _tokenAddress,\n        uint256 _amount,\n        uint256 _chainIdTo,\n        bytes memory _receiver,\n        bytes memory _permit,\n        bool _useAssetFee,\n        uint32 _referralCode,\n        bytes calldata _autoParams\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "src/Interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view returns (address facetAddress_);\n}\n"
    },
    "src/Interfaces/IDlnSource.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IDlnSource {\n    struct OrderCreation {\n        // the address of the ERC-20 token you are giving;\n        // use the zero address to indicate you are giving a native blockchain token (ether, matic, etc).\n        address giveTokenAddress;\n        // the amount of tokens you are giving\n        uint256 giveAmount;\n        // the address of the ERC-20 token you are willing to take on the destination chain\n        bytes takeTokenAddress;\n        // the amount of tokens you are willing to take on the destination chain\n        uint256 takeAmount;\n        // the ID of the chain where an order should be fulfilled.\n        // Use the list of supported chains mentioned above\n        uint256 takeChainId;\n        // the address on the destination chain where the funds\n        // should be sent to upon order fulfillment\n        bytes receiverDst;\n        // the address on the source (current) chain who is allowed to patch the order\n        // giving more input tokens and thus making the order more attractive to takers, just in case\n        address givePatchAuthoritySrc;\n        // the address on the destination chain who is allowed to patch the order\n        // decreasing the take amount and thus making the order more attractive to takers, just in case\n        bytes orderAuthorityAddressDst;\n        // an optional address restricting anyone in the open market from fulfilling\n        // this order but the given address. This can be useful if you are creating a order\n        //  for a specific taker. By default, set to empty bytes array (0x)\n        bytes allowedTakerDst; // *optional\n        // set to an empty bytes array (0x)\n        bytes externalCall; // N/A, *optional\n        // an optional address on the source (current) chain where the given input tokens\n        // would be transferred to in case order cancellation is initiated by the orderAuthorityAddressDst\n        // on the destination chain. This property can be safely set to an empty bytes array (0x):\n        // in this case, tokens would be transferred to the arbitrary address specified\n        // by the orderAuthorityAddressDst upon order cancellation\n        bytes allowedCancelBeneficiarySrc; // *optional\n    }\n\n    function globalFixedNativeFee() external returns (uint256);\n\n    function createOrder(\n        OrderCreation calldata _orderCreation,\n        bytes calldata _affiliateFee,\n        uint32 _referralCode,\n        bytes calldata _permitEnvelope\n    ) external payable returns (bytes32 orderId);\n}\n"
    },
    "src/Interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external view returns (bool);\n}\n"
    },
    "src/Interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "src/Interfaces/IERC20Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IERC20Proxy {\n    function transferFrom(\n        address tokenAddress,\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n}\n"
    },
    "src/Interfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\n\n/// @title Interface for Executor\n/// @author LI.FI (https://li.fi)\ninterface IExecutor {\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param transferredAssetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address transferredAssetId,\n        address payable receiver\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IGatewayRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IGatewayRouter {\n    /// @notice Transfer non-native assets\n    /// @param _token L1 address of ERC20\n    /// @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract)\n    /// @param _amount Token Amount\n    /// @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n    /// @param _gasPriceBid Gas price for L2 execution\n    /// @param _data Encoded data from router and user\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    /// @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress). createRetryableTicket method is the recommended standard.\n    /// @param _destAddr destination L2 contract address\n    /// @param _l2CallValue call value for retryable L2 message\n    /// @param _maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n    /// @param _excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\n    /// @param _callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n    /// @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n    /// @param _gasPriceBid price bid for L2 execution\n    /// @param _data ABI encoded data of L2 message\n    /// @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n    function unsafeCreateRetryableTicket(\n        address _destAddr,\n        uint256 _l2CallValue,\n        uint256 _maxSubmissionCost,\n        address _excessFeeRefundAddress,\n        address _callValueRefundAddress,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (uint256);\n\n    /// @notice Returns receiving token address on L2\n    /// @param _token Sending token address on L1\n    /// @return Receiving token address on L2\n    function calculateL2TokenAddress(\n        address _token\n    ) external view returns (address);\n\n    /// @notice Returns exact gateway router address for token\n    /// @param _token Sending token address on L1\n    /// @return Gateway router address for sending token\n    function getGateway(address _token) external view returns (address);\n}\n"
    },
    "src/Interfaces/IHopBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IHopBridge {\n    function sendToL2(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 amountOutMin,\n        uint256 deadline,\n        address relayer,\n        uint256 relayerFee\n    ) external payable;\n\n    function swapAndSend(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline\n    ) external payable;\n\n    function send(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline\n    ) external;\n}\n\ninterface IL2AmmWrapper {\n    function bridge() external view returns (address);\n\n    function l2CanonicalToken() external view returns (address);\n\n    function hToken() external view returns (address);\n\n    function exchangeAddress() external view returns (address);\n}\n\ninterface ISwap {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n}\n"
    },
    "src/Interfaces/IHyphenRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\n// https://github.com/bcnmy/hyphen-contract/blob/master/contracts/hyphen/LiquidityPool.sol\ninterface IHyphenRouter {\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string calldata tag\n    ) external;\n\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string calldata tag\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IL1StandardBridge {\n    /// @notice Deposit an amount of ETH to a recipient's balance on L2.\n    /// @param _to L2 address to credit the withdrawal to.\n    /// @param _l2Gas Gas limit required to complete the deposit on L2.\n    /// @param _data Optional data to forward to L2. This data is provided\n    ///        solely as a convenience for external contracts. Aside from enforcing a maximum\n    ///        length, these contracts provide no guarantees about its content.\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /// @notice Deposit an amount of the ERC20 to the caller's balance on L2.\n    /// @param _l1Token Address of the L1 ERC20 we are depositing\n    /// @param _l2Token Address of the L1 respective L2 ERC20\n    /// @param _to L2 address to credit the withdrawal to.\n    /// @param _amount Amount of the ERC20 to deposit\n    /// @param _l2Gas Gas limit required to complete the deposit on L2.\n    /// @param _data Optional data to forward to L2. This data is provided\n    ///        solely as a convenience for external contracts. Aside from enforcing a maximum\n    ///        length, these contracts provide no guarantees about its content.\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /// @notice Deposit an amount of the ERC20 to the caller's balance on L2.\n    /// @dev This function is implemented on SynthetixBridgeToOptimism contract.\n    /// @param _to L2 address to credit the withdrawal to.\n    /// @param _amount Amount of the ERC20 to deposit\n    function depositTo(address _to, uint256 _amount) external;\n}\n"
    },
    "src/Interfaces/ILiFi.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface ILiFi {\n    /// Structs ///\n\n    struct BridgeData {\n        bytes32 transactionId;\n        string bridge;\n        string integrator;\n        address referrer;\n        address sendingAssetId;\n        address receiver;\n        uint256 minAmount;\n        uint256 destinationChainId;\n        bool hasSourceSwaps;\n        bool hasDestinationCall;\n    }\n\n    /// Events ///\n\n    event LiFiTransferStarted(ILiFi.BridgeData bridgeData);\n\n    event LiFiTransferCompleted(\n        bytes32 indexed transactionId,\n        address receivingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event LiFiTransferRecovered(\n        bytes32 indexed transactionId,\n        address receivingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event LiFiGenericSwapCompleted(\n        bytes32 indexed transactionId,\n        string integrator,\n        string referrer,\n        address receiver,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount\n    );\n\n    // Deprecated but kept here to include in ABI to parse historic events\n    event LiFiSwappedGeneric(\n        bytes32 indexed transactionId,\n        string integrator,\n        string referrer,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount\n    );\n}\n"
    },
    "src/Interfaces/IMayan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IMayan {\n    struct PermitParams {\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function forwardEth(\n        address mayanProtocol,\n        bytes calldata protocolData\n    ) external payable;\n\n    function forwardERC20(\n        address tokenIn,\n        uint256 amountIn,\n        PermitParams calldata permitParams,\n        address mayanProtocol,\n        bytes calldata protocolData\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IMultichainRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IMultichainRouter {\n    function anySwapOutUnderlying(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 toChainID\n    ) external;\n\n    function anySwapOut(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 toChainID\n    ) external;\n\n    function anySwapOutNative(\n        address token,\n        address to,\n        uint256 toChainID\n    ) external payable;\n\n    function wNATIVE() external returns (address);\n}\n"
    },
    "src/Interfaces/IMultichainToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IMultichainToken {\n    function underlying() external returns (address);\n}\n"
    },
    "src/Interfaces/IOmniBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IOmniBridge {\n    /// @dev Initiate the bridge operation for some amount of tokens from msg.sender.\n    /// @param token bridged token contract address.\n    /// @param receiver Receiver address\n    /// @param amount Dai amount\n    function relayTokens(\n        address token,\n        address receiver,\n        uint256 amount\n    ) external;\n\n    /// @dev Wraps native assets and relays wrapped ERC20 tokens to the other chain.\n    /// @param receiver Bridged assets receiver on the other side of the bridge.\n    function wrapAndRelayTokens(address receiver) external payable;\n}\n"
    },
    "src/Interfaces/IRootChainManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IRootChainManager {\n    /// @notice Move ether from root to child chain, accepts ether transfer\n    /// @dev Keep in mind this ether cannot be used to pay gas on child chain\n    ///      Use Matic tokens deposited using plasma mechanism for that\n    /// @param user address of account that should receive WETH on child chain\n    function depositEtherFor(address user) external payable;\n\n    /// @notice Move tokens from root to child chain\n    /// @dev This mechanism supports arbitrary tokens as long as\n    ///      its predicate has been registered and the token is mapped\n    /// @param user address of account that should receive this deposit on child chain\n    /// @param rootToken address of token that is being deposited\n    /// @param depositData bytes data that is sent to predicate and\n    ///        child token contracts to handle deposit\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external;\n\n    /// @notice Returns child token address for root token\n    /// @param rootToken Root token address\n    /// @return childToken Child token address\n    function rootToChildToken(\n        address rootToken\n    ) external view returns (address childToken);\n}\n"
    },
    "src/Interfaces/ISquidMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface ISquidMulticall {\n    enum CallType {\n        Default,\n        FullTokenBalance,\n        FullNativeBalance,\n        CollectTokenBalance\n    }\n\n    struct Call {\n        CallType callType;\n        address target;\n        uint256 value;\n        bytes callData;\n        bytes payload;\n    }\n}\n"
    },
    "src/Interfaces/ISquidRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { ISquidMulticall } from \"./ISquidMulticall.sol\";\n\ninterface ISquidRouter {\n    function bridgeCall(\n        string calldata bridgedTokenSymbol,\n        uint256 amount,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasRefundRecipient,\n        bool enableExpress\n    ) external payable;\n\n    function callBridge(\n        address token,\n        uint256 amount,\n        ISquidMulticall.Call[] calldata calls,\n        string calldata bridgedTokenSymbol,\n        string calldata destinationChain,\n        string calldata destinationAddress\n    ) external payable;\n\n    function callBridgeCall(\n        address token,\n        uint256 amount,\n        ISquidMulticall.Call[] calldata calls,\n        string calldata bridgedTokenSymbol,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasRefundRecipient,\n        bool enableExpress\n    ) external payable;\n}\n"
    },
    "src/Interfaces/IStargate.sol": {
      "content": "// Interface for Stargate V2\n/// @custom:version 1.0.0\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.17;\n\n/// @notice Stargate implementation type.\nenum StargateType {\n    Pool,\n    OFT\n}\n\n/// @notice Ticket data for bus ride.\nstruct Ticket {\n    uint72 ticketId;\n    bytes passengerBytes;\n}\n\n/// @title Interface for Stargate.\n/// @notice Defines an API for sending tokens to destination chains.\ninterface IStargate {\n    /**\n     * @dev Struct representing token parameters for the OFT send() operation.\n     */\n    struct SendParam {\n        uint32 dstEid; // Destination endpoint ID.\n        bytes32 to; // Recipient address.\n        uint256 amountLD; // Amount to send in local decimals.\n        uint256 minAmountLD; // Minimum amount to send in local decimals.\n        bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n        bytes composeMsg; // The composed message for the send() operation.\n        bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n    }\n\n    /**\n     * @dev Struct representing OFT limit information.\n     * @dev These amounts can change dynamically and are up the the specific oft implementation.\n     */\n    struct OFTLimit {\n        uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\n        uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\n    }\n\n    /**\n     * @dev Struct representing OFT receipt information.\n     */\n    struct OFTReceipt {\n        uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\n        // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\n        uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\n    }\n\n    /**\n     * @dev Struct representing OFT fee details.\n     * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\n     */\n    struct OFTFeeDetail {\n        int256 feeAmountLD; // Amount of the fee in local decimals.\n        string description; // Description of the fee.\n    }\n\n    struct MessagingFee {\n        uint256 nativeFee;\n        uint256 lzTokenFee;\n    }\n\n    struct MessagingReceipt {\n        bytes32 guid;\n        uint64 nonce;\n        MessagingFee fee;\n    }\n\n    /// @dev This function is same as `send` in OFT interface but returns the ticket data if in the bus ride mode,\n    /// which allows the caller to ride and drive the bus in the same transaction.\n    function sendToken(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    )\n        external\n        payable\n        returns (\n            MessagingReceipt memory msgReceipt,\n            OFTReceipt memory oftReceipt,\n            Ticket memory ticket\n        );\n\n    /**\n     * @notice Provides a quote for OFT-related operations.\n     * @param _sendParam The parameters for the send operation.\n     * @return limit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return receipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    )\n        external\n        view\n        returns (\n            OFTLimit memory,\n            OFTFeeDetail[] memory oftFeeDetails,\n            OFTReceipt memory\n        );\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(\n        SendParam calldata _sendParam,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n}\n\ninterface ITokenMessaging {\n    function assetIds(address tokenAddress) external returns (uint16);\n\n    function stargateImpls(uint16 assetId) external returns (address);\n}\n"
    },
    "src/Interfaces/IStargateRouter.sol": {
      "content": "// Interface for Stargate V1\n/// @custom:version 1.0.0\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\n// solhint-disable contract-name-camelcase\ninterface IStargateRouter {\n    struct lzTxObj {\n        uint256 dstGasForCall;\n        uint256 dstNativeAmount;\n        bytes dstNativeAddr;\n    }\n\n    /// @notice SwapAmount struct\n    /// @param amountLD The amount, in Local Decimals, to be swapped\n    /// @param minAmountLD The minimum amount accepted out on destination\n    struct SwapAmount {\n        uint256 amountLD;\n        uint256 minAmountLD;\n    }\n\n    /// @notice Returns factory address used for creating pools.\n    function factory() external view returns (address);\n\n    /// @notice Swap assets cross-chain.\n    /// @dev Pass (0, 0, \"0x\") to lzTxParams\n    ///      for 0 additional gasLimit increase, 0 airdrop, at 0x address.\n    /// @param dstChainId Destination chainId\n    /// @param srcPoolId Source pool id\n    /// @param dstPoolId Dest pool id\n    /// @param refundAddress Refund adddress. extra gas (if any) is returned to this address\n    /// @param amountLD Quantity to swap\n    /// @param minAmountLD The min qty you would accept on the destination\n    /// @param lzTxParams Additional gas, airdrop data\n    /// @param to The address to send the tokens to on the destination\n    /// @param payload Additional payload. You can abi.encode() them here\n    function swap(\n        uint16 dstChainId,\n        uint256 srcPoolId,\n        uint256 dstPoolId,\n        address payable refundAddress,\n        uint256 amountLD,\n        uint256 minAmountLD,\n        lzTxObj memory lzTxParams,\n        bytes calldata to,\n        bytes calldata payload\n    ) external payable;\n\n    /// @notice Swap native assets cross-chain.\n    /// @param _dstChainId Destination Stargate chainId\n    /// @param _refundAddress Refunds additional messageFee to this address\n    /// @param _toAddress The receiver of the destination ETH\n    /// @param _swapAmount The amount and the minimum swap amount\n    /// @param _lzTxParams The LZ tx params\n    /// @param _payload The payload to send to the destination\n    function swapETHAndCall(\n        uint16 _dstChainId,\n        address payable _refundAddress,\n        bytes calldata _toAddress,\n        SwapAmount memory _swapAmount,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes calldata _payload\n    ) external payable;\n\n    /// @notice Returns the native gas fee required for swap.\n    function quoteLayerZeroFee(\n        uint16 dstChainId,\n        uint8 functionType,\n        bytes calldata toAddress,\n        bytes calldata transferAndCallPayload,\n        lzTxObj memory lzTxParams\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n}\n"
    },
    "src/Interfaces/ISymbiosisMetaRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface ISymbiosisMetaRouter {\n    /// @notice entry point data to Symbiosis contracts\n    /// @param firstSwapCalldata calldata for the dex swap to get corresponding asset (USDC) on init chain\n    /// @param secondSwapCalldata legacy calldata from v1, should be empty\n    /// @param approvedTokens set of token for firstSwapCalldata, and o bridgingCalldata\n    /// @param firstDexRouter entry point for firstSwapCalldata\n    /// @param secondDexRouter legacy entry point from v1, should be empty\n    /// @param amount of tokens\n    /// @param nativeIn native token in amount or not\n    /// @param relayRecipient entry point to bridge provided from API\n    /// @param otherSideCalldata bridging calldata\n    struct MetaRouteTransaction {\n        bytes firstSwapCalldata;\n        bytes secondSwapCalldata;\n        address[] approvedTokens;\n        address firstDexRouter;\n        address secondDexRouter;\n        uint256 amount;\n        bool nativeIn;\n        address relayRecipient;\n        bytes otherSideCalldata;\n    }\n\n    /**\n     * @notice Method that starts the Meta Routing in Symbiosis\n     * @param _metarouteTransaction metaRoute offchain transaction data\n     */\n    function metaRoute(\n        MetaRouteTransaction calldata _metarouteTransaction\n    ) external payable;\n}\n"
    },
    "src/Interfaces/ISynapseRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface ISynapseRouter {\n    /// @notice Struct representing a request for SynapseRouter.\n    /// @dev tokenIn is supplied separately.\n    /// @param swapAdapter Adapter address that will perform the swap.\n    ///                    Address(0) specifies a \"no swap\" query.\n    /// @param tokenOut Token address to swap to.\n    /// @param minAmountOut Minimum amount of tokens to receive after the swap,\n    ///                     or tx will be reverted.\n    /// @param deadline Latest timestamp for when the transaction needs to be executed,\n    ///                 or tx will be reverted.\n    /// @param rawParams ABI-encoded params for the swap that will be passed to `swapAdapter`.\n    ///                  Should be SynapseParams for swaps via SynapseAdapter.\n    struct SwapQuery {\n        address swapAdapter;\n        address tokenOut;\n        uint256 minAmountOut;\n        uint256 deadline;\n        bytes rawParams;\n    }\n\n    /// @notice Struct representing a request for a swap quote from a bridge token.\n    /// @dev tokenOut is passed externally.\n    /// @param symbol Bridge token symbol: unique token ID consistent among all chains.\n    /// @param amountIn Amount of bridge token to start with, before the bridge fee is applied.\n    struct DestRequest {\n        string symbol;\n        uint256 amountIn;\n    }\n\n    /// @notice Struct representing a bridge token.\n    ///         Used as the return value in view functions.\n    /// @param symbol Bridge token symbol: unique token ID consistent among all chains.\n    /// @param token Bridge token address.\n    struct BridgeToken {\n        string symbol;\n        address token;\n    }\n\n    /// @notice Initiate a bridge transaction with an optional swap on both origin\n    ///         and destination chains.\n    /// @dev Note This method is payable.\n    ///      If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\n    ///      If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\n    ///      Make sure to approve this contract for spending `token` beforehand.\n    ///      originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\n    ///\n    ///      `token` is always a token user is sending.\n    ///      In case token requires a wrapper token to be bridge,\n    ///      use underlying address for `token` instead of the wrapper one.\n    ///\n    ///      `originQuery` contains instructions for the swap on origin chain.\n    ///      As above, originQuery.tokenOut should always use the underlying address.\n    ///      In other words, the concept of wrapper token is fully abstracted away from the end user.\n    ///\n    ///      `originQuery` is supposed to be fetched using SynapseRouter.getOriginAmountOut().\n    ///      Alternatively one could use an external adapter for more complex swaps on the origin chain.\n    ///\n    ///      `destQuery` is supposed to be fetched using SynapseRouter.getDestinationAmountOut().\n    ///      Complex swaps on destination chain are not supported for the time being.\n    ///      Check contract description above for more details.\n    /// @param to Address to receive tokens on destination chain.\n    /// @param chainId Destination chain id.\n    /// @param token Initial token for the bridge transaction to be pulled from the user.\n    /// @param amount Amount of the initial tokens for the bridge transaction.\n    /// @param originQuery Origin swap query. Empty struct indicates no swap is required.\n    /// @param destQuery Destination swap query. Empty struct indicates no swap is required.\n    function bridge(\n        address to,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        SwapQuery memory originQuery,\n        SwapQuery memory destQuery\n    ) external payable;\n\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token\n    ///         from the given list, treating the swap as \"origin swap\",\n    ///         without putting any restrictions on the swap.\n    /// @dev Will NOT revert if any of the tokens are not supported,\n    ///      instead will return an empty query for that symbol.\n    ///      Check (query.minAmountOut != 0): this is true only if the swap is possible\n    ///      and bridge token is supported.\n    ///      The returned queries with minAmountOut != 0 could be used as `originQuery`\n    ///      with SynapseRouter.\n    /// Note: It is possible to form a SwapQuery off-chain using alternative SwapAdapter\n    ///       for the origin swap.\n    /// @param tokenIn Initial token that user wants to bridge/swap.\n    /// @param tokenSymbols List of symbols representing bridge tokens.\n    /// @param amountIn Amount of tokens user wants to bridge/swap.\n    /// @return originQueries List of structs that could be used as `originQuery` in SynapseRouter.\n    ///                       minAmountOut and deadline fields will need to be adjusted\n    ///                       based on the user settings.\n    function getOriginAmountOut(\n        address tokenIn,\n        string[] memory tokenSymbols,\n        uint256 amountIn\n    ) external view returns (SwapQuery[] memory originQueries);\n\n    /// @notice Finds the best path between every supported bridge token from\n    ///         the given list and `tokenOut`, treating the swap as \"destination swap\",\n    ///         limiting possible actions to those available for every bridge token.\n    /// @dev Will NOT revert if any of the tokens are not supported,\n    ///      instead will return an empty query for that symbol.\n    /// Note: It is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter\n    ///       for the destination swap.\n    ///       For the time being, only swaps through the Synapse-supported pools\n    ///       are available on destination chain.\n    /// @param requests List of structs with following information:\n    ///                 - symbol: unique token ID consistent among all chains.\n    ///                 - amountIn: amount of bridge token to start with,\n    ///                              before the bridge fee is applied.\n    /// @param tokenOut Token user wants to receive on destination chain.\n    /// @return destQueries List of structs that could be used as `destQuery` in SynapseRouter.\n    ///                     minAmountOut and deadline fields will need to be adjusted based\n    ///                     on the user settings.\n    function getDestinationAmountOut(\n        DestRequest[] memory requests,\n        address tokenOut\n    ) external view returns (SwapQuery[] memory destQueries);\n\n    /// @notice Gets the list of all bridge tokens (and their symbols),\n    ///         such that destination swap from a bridge token to `tokenOut` is possible.\n    /// @param tokenOut Token address to swap to on destination chain\n    /// @return tokens List of structs with following information:\n    ///                - symbol: unique token ID consistent among all chains\n    ///                - token: bridge token address\n    function getConnectedBridgeTokens(\n        address tokenOut\n    ) external view returns (BridgeToken[] memory tokens);\n}\n"
    },
    "src/Interfaces/ITeleportGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface ITeleportGateway {\n    /// @notice Initiate DAI transfer.\n    /// @param targetDomain Domain of destination chain.\n    /// @param receiver Receiver address.\n    /// @param amount The amount of DAI to transfer.\n    function initiateTeleport(\n        bytes32 targetDomain,\n        address receiver,\n        uint128 amount\n    ) external;\n}\n"
    },
    "src/Interfaces/IThorSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\n/// @title ThorSwap Interface\ninterface IThorSwap {\n    // Thorchain router\n    function depositWithExpiry(\n        address vault,\n        address asset,\n        uint256 amount,\n        string calldata memo,\n        uint256 expiration\n    ) external payable;\n}\n"
    },
    "src/Interfaces/ITokenMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface ITokenMessenger {\n    /// @notice Deposits and burns tokens from sender to be minted on destination domain.\n    /// @dev reverts if:\n    ///      - given burnToken is not supported.\n    ///      - given destinationDomain has no TokenMessenger registered.\n    ///      - transferFrom() reverts. For example, if sender's burnToken balance\n    ///        or approved allowance to this contract is less than `amount`.\n    ///      - burn() reverts. For example, if `amount` is 0.\n    ///      - MessageTransmitter returns false or reverts.\n    /// @param amount Amount of tokens to burn.\n    /// @param destinationDomain Destination domain.\n    /// @param mintRecipient Address of mint recipient on destination domain.\n    /// @param burnToken Address of contract to burn deposited tokens, on local domain.\n    /// @return nonce Unique nonce reserved by message.\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken\n    ) external returns (uint64 nonce);\n}\n"
    },
    "src/Interfaces/ITransactionManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface ITransactionManager {\n    // Structs\n\n    // Holds all data that is constant between sending and\n    // receiving chains. The hash of this is what gets signed\n    // to ensure the signature can be used on both chains.\n    struct InvariantTransactionData {\n        address receivingChainTxManagerAddress;\n        address user;\n        address router;\n        address initiator; // msg.sender of sending side\n        address sendingAssetId;\n        address receivingAssetId;\n        address sendingChainFallback; // funds sent here on cancel\n        address receivingAddress;\n        address callTo;\n        uint256 sendingChainId;\n        uint256 receivingChainId;\n        bytes32 callDataHash; // hashed to prevent free option\n        bytes32 transactionId;\n    }\n\n    // All Transaction data, constant and variable\n    struct TransactionData {\n        address receivingChainTxManagerAddress;\n        address user;\n        address router;\n        address initiator; // msg.sender of sending side\n        address sendingAssetId;\n        address receivingAssetId;\n        address sendingChainFallback;\n        address receivingAddress;\n        address callTo;\n        bytes32 callDataHash;\n        bytes32 transactionId;\n        uint256 sendingChainId;\n        uint256 receivingChainId;\n        uint256 amount;\n        uint256 expiry;\n        uint256 preparedBlockNumber; // Needed for removal of active blocks on fulfill/cancel\n    }\n\n    /**\n     * Arguments for calling prepare()\n     * @param invariantData The data for a crosschain transaction that will\n     *                      not change between sending and receiving chains.\n     *                      The hash of this data is used as the key to store\n     *                      the inforamtion that does change between chains\n     *                      (amount,expiry,preparedBlock) for verification\n     * @param amount The amount of the transaction on this chain\n     * @param expiry The block.timestamp when the transaction will no longer be\n     *               fulfillable and is freely cancellable on this chain\n     * @param encryptedCallData The calldata to be executed when the tx is\n     *                          fulfilled. Used in the function to allow the user\n     *                          to reconstruct the tx from events. Hash is stored\n     *                          onchain to prevent shenanigans.\n     * @param encodedBid The encoded bid that was accepted by the user for this\n     *                   crosschain transfer. It is supplied as a param to the\n     *                   function but is only used in event emission\n     * @param bidSignature The signature of the bidder on the encoded bid for\n     *                     this transaction. Only used within the function for\n     *                     event emission. The validity of the bid and\n     *                     bidSignature are enforced offchain\n     * @param encodedMeta The meta for the function\n     */\n    struct PrepareArgs {\n        InvariantTransactionData invariantData;\n        uint256 amount;\n        uint256 expiry;\n        bytes encryptedCallData;\n        bytes encodedBid;\n        bytes bidSignature;\n        bytes encodedMeta;\n    }\n\n    // called in the following order (in happy case)\n    // 1. prepare by user on sending chain\n    function prepare(\n        PrepareArgs calldata args\n    ) external payable returns (TransactionData memory);\n}\n"
    },
    "src/Interfaces/IXDaiBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IXDaiBridge {\n    /// @notice Bridge Dai to xDai and sends to receiver\n    /// @dev It's implemented in xDaiBridge on only Ethereum\n    /// @param receiver Receiver address\n    /// @param amount Dai amount\n    function relayTokens(address receiver, uint256 amount) external;\n}\n"
    },
    "src/Interfaces/IXDaiBridgeL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\ninterface IXDaiBridgeL2 {\n    /// @notice Bridge xDai to DAI and sends to receiver\n    /// @dev It's implemented in xDaiBridge on only Gnosis\n    /// @param receiver Receiver address\n    function relayTokens(address receiver) external payable;\n}\n"
    },
    "src/Libraries/LibAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { CannotAuthoriseSelf, UnAuthorized } from \"../Errors/GenericErrors.sol\";\n\n/// @title Access Library\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for managing method level access control\nlibrary LibAccess {\n    /// Types ///\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.library.access.management\");\n\n    /// Storage ///\n    struct AccessStorage {\n        mapping(bytes4 => mapping(address => bool)) execAccess;\n    }\n\n    /// Events ///\n    event AccessGranted(address indexed account, bytes4 indexed method);\n    event AccessRevoked(address indexed account, bytes4 indexed method);\n\n    /// @dev Fetch local storage\n    function accessStorage()\n        internal\n        pure\n        returns (AccessStorage storage accStor)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            accStor.slot := position\n        }\n    }\n\n    /// @notice Gives an address permission to execute a method\n    /// @param selector The method selector to execute\n    /// @param executor The address to grant permission to\n    function addAccess(bytes4 selector, address executor) internal {\n        if (executor == address(this)) {\n            revert CannotAuthoriseSelf();\n        }\n        AccessStorage storage accStor = accessStorage();\n        accStor.execAccess[selector][executor] = true;\n        emit AccessGranted(executor, selector);\n    }\n\n    /// @notice Revokes permission to execute a method\n    /// @param selector The method selector to execute\n    /// @param executor The address to revoke permission from\n    function removeAccess(bytes4 selector, address executor) internal {\n        AccessStorage storage accStor = accessStorage();\n        accStor.execAccess[selector][executor] = false;\n        emit AccessRevoked(executor, selector);\n    }\n\n    /// @notice Enforces access control by reverting if `msg.sender`\n    ///     has not been given permission to execute `msg.sig`\n    function enforceAccessControl() internal view {\n        AccessStorage storage accStor = accessStorage();\n        if (accStor.execAccess[msg.sig][msg.sender] != true)\n            revert UnAuthorized();\n    }\n}\n"
    },
    "src/Libraries/LibAllowList.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { InvalidContract } from \"../Errors/GenericErrors.sol\";\n\n/// @title Lib Allow List\n/// @author LI.FI (https://li.fi)\n/// @notice Library for managing and accessing the conract address allow list\nlibrary LibAllowList {\n    /// Storage ///\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.library.allow.list\");\n\n    struct AllowListStorage {\n        mapping(address => bool) allowlist;\n        mapping(bytes4 => bool) selectorAllowList;\n        address[] contracts;\n    }\n\n    /// @dev Adds a contract address to the allow list\n    /// @param _contract the contract address to add\n    function addAllowedContract(address _contract) internal {\n        _checkAddress(_contract);\n\n        AllowListStorage storage als = _getStorage();\n\n        if (als.allowlist[_contract]) return;\n\n        als.allowlist[_contract] = true;\n        als.contracts.push(_contract);\n    }\n\n    /// @dev Checks whether a contract address has been added to the allow list\n    /// @param _contract the contract address to check\n    function contractIsAllowed(\n        address _contract\n    ) internal view returns (bool) {\n        return _getStorage().allowlist[_contract];\n    }\n\n    /// @dev Remove a contract address from the allow list\n    /// @param _contract the contract address to remove\n    function removeAllowedContract(address _contract) internal {\n        AllowListStorage storage als = _getStorage();\n\n        if (!als.allowlist[_contract]) {\n            return;\n        }\n\n        als.allowlist[_contract] = false;\n\n        uint256 length = als.contracts.length;\n        // Find the contract in the list\n        for (uint256 i = 0; i < length; i++) {\n            if (als.contracts[i] == _contract) {\n                // Move the last element into the place to delete\n                als.contracts[i] = als.contracts[length - 1];\n                // Remove the last element\n                als.contracts.pop();\n                break;\n            }\n        }\n    }\n\n    /// @dev Fetch contract addresses from the allow list\n    function getAllowedContracts() internal view returns (address[] memory) {\n        return _getStorage().contracts;\n    }\n\n    /// @dev Add a selector to the allow list\n    /// @param _selector the selector to add\n    function addAllowedSelector(bytes4 _selector) internal {\n        _getStorage().selectorAllowList[_selector] = true;\n    }\n\n    /// @dev Removes a selector from the allow list\n    /// @param _selector the selector to remove\n    function removeAllowedSelector(bytes4 _selector) internal {\n        _getStorage().selectorAllowList[_selector] = false;\n    }\n\n    /// @dev Returns if selector has been added to the allow list\n    /// @param _selector the selector to check\n    function selectorIsAllowed(bytes4 _selector) internal view returns (bool) {\n        return _getStorage().selectorAllowList[_selector];\n    }\n\n    /// @dev Fetch local storage struct\n    function _getStorage()\n        internal\n        pure\n        returns (AllowListStorage storage als)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            als.slot := position\n        }\n    }\n\n    /// @dev Contains business logic for validating a contract address.\n    /// @param _contract address of the dex to check\n    function _checkAddress(address _contract) private view {\n        if (_contract == address(0)) revert InvalidContract();\n\n        if (_contract.code.length == 0) revert InvalidContract();\n    }\n}\n"
    },
    "src/Libraries/LibAsset.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\nimport { InsufficientBalance, NullAddrIsNotAnERC20Token, NullAddrIsNotAValidSpender, NoTransferToNullAddress, InvalidAmount, NativeAssetTransferFailed } from \"../Errors/GenericErrors.sol\";\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { LibSwap } from \"./LibSwap.sol\";\n\n/// @title LibAsset\n/// @notice This library contains helpers for dealing with onchain transfers\n///         of assets, including accounting for the native asset `assetId`\n///         conventions and any noncompliant ERC20 transfers\nlibrary LibAsset {\n    uint256 private constant MAX_UINT = type(uint256).max;\n\n    address internal constant NULL_ADDRESS = address(0);\n\n    /// @dev All native assets use the empty address for their asset id\n    ///      by convention\n\n    address internal constant NATIVE_ASSETID = NULL_ADDRESS; //address(0)\n\n    /// @notice Gets the balance of the inheriting contract for the given asset\n    /// @param assetId The asset identifier to get the balance of\n    /// @return Balance held by contracts using this library\n    function getOwnBalance(address assetId) internal view returns (uint256) {\n        return\n            isNativeAsset(assetId)\n                ? address(this).balance\n                : IERC20(assetId).balanceOf(address(this));\n    }\n\n    /// @notice Transfers ether from the inheriting contract to a given\n    ///         recipient\n    /// @param recipient Address to send ether to\n    /// @param amount Amount to send to given recipient\n    function transferNativeAsset(\n        address payable recipient,\n        uint256 amount\n    ) private {\n        if (recipient == NULL_ADDRESS) revert NoTransferToNullAddress();\n        if (amount > address(this).balance)\n            revert InsufficientBalance(amount, address(this).balance);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        if (!success) revert NativeAssetTransferFailed();\n    }\n\n    /// @notice If the current allowance is insufficient, the allowance for a given spender\n    /// is set to MAX_UINT.\n    /// @param assetId Token address to transfer\n    /// @param spender Address to give spend approval to\n    /// @param amount Amount to approve for spending\n    function maxApproveERC20(\n        IERC20 assetId,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(address(assetId))) {\n            return;\n        }\n        if (spender == NULL_ADDRESS) {\n            revert NullAddrIsNotAValidSpender();\n        }\n\n        if (assetId.allowance(address(this), spender) < amount) {\n            SafeERC20.safeApprove(IERC20(assetId), spender, 0);\n            SafeERC20.safeApprove(IERC20(assetId), spender, MAX_UINT);\n        }\n    }\n\n    /// @notice Transfers tokens from the inheriting contract to a given\n    ///         recipient\n    /// @param assetId Token address to transfer\n    /// @param recipient Address to send token to\n    /// @param amount Amount to send to given recipient\n    function transferERC20(\n        address assetId,\n        address recipient,\n        uint256 amount\n    ) private {\n        if (isNativeAsset(assetId)) {\n            revert NullAddrIsNotAnERC20Token();\n        }\n        if (recipient == NULL_ADDRESS) {\n            revert NoTransferToNullAddress();\n        }\n\n        uint256 assetBalance = IERC20(assetId).balanceOf(address(this));\n        if (amount > assetBalance) {\n            revert InsufficientBalance(amount, assetBalance);\n        }\n        SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);\n    }\n\n    /// @notice Transfers tokens from a sender to a given recipient\n    /// @param assetId Token address to transfer\n    /// @param from Address of sender/owner\n    /// @param to Address of recipient/spender\n    /// @param amount Amount to transfer from owner to spender\n    function transferFromERC20(\n        address assetId,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(assetId)) {\n            revert NullAddrIsNotAnERC20Token();\n        }\n        if (to == NULL_ADDRESS) {\n            revert NoTransferToNullAddress();\n        }\n\n        IERC20 asset = IERC20(assetId);\n        uint256 prevBalance = asset.balanceOf(to);\n        SafeERC20.safeTransferFrom(asset, from, to, amount);\n        if (asset.balanceOf(to) - prevBalance != amount) {\n            revert InvalidAmount();\n        }\n    }\n\n    function depositAsset(address assetId, uint256 amount) internal {\n        if (amount == 0) revert InvalidAmount();\n        if (isNativeAsset(assetId)) {\n            if (msg.value < amount) revert InvalidAmount();\n        } else {\n            uint256 balance = IERC20(assetId).balanceOf(msg.sender);\n            if (balance < amount) revert InsufficientBalance(amount, balance);\n            transferFromERC20(assetId, msg.sender, address(this), amount);\n        }\n    }\n\n    function depositAssets(LibSwap.SwapData[] calldata swaps) internal {\n        for (uint256 i = 0; i < swaps.length; ) {\n            LibSwap.SwapData calldata swap = swaps[i];\n            if (swap.requiresDeposit) {\n                depositAsset(swap.sendingAssetId, swap.fromAmount);\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @notice Determines whether the given assetId is the native asset\n    /// @param assetId The asset identifier to evaluate\n    /// @return Boolean indicating if the asset is the native asset\n    function isNativeAsset(address assetId) internal pure returns (bool) {\n        return assetId == NATIVE_ASSETID;\n    }\n\n    /// @notice Wrapper function to transfer a given asset (native or erc20) to\n    ///         some recipient. Should handle all non-compliant return value\n    ///         tokens as well by using the SafeERC20 contract by open zeppelin.\n    /// @param assetId Asset id for transfer (address(0) for native asset,\n    ///                token address for erc20s)\n    /// @param recipient Address to send asset to\n    /// @param amount Amount to send to given recipient\n    function transferAsset(\n        address assetId,\n        address payable recipient,\n        uint256 amount\n    ) internal {\n        isNativeAsset(assetId)\n            ? transferNativeAsset(recipient, amount)\n            : transferERC20(assetId, recipient, amount);\n    }\n\n    /// @dev Checks whether the given address is a contract and contains code\n    function isContract(address _contractAddr) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(_contractAddr)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "src/Libraries/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nlibrary LibBytes {\n    // solhint-disable no-inline-assembly\n\n    // LibBytes specific errors\n    error SliceOverflow();\n    error SliceOutOfBounds();\n    error AddressOutOfBounds();\n\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n\n    // -------------------------\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        if (_length + 31 < _length) revert SliceOverflow();\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(\n                    add(tempBytes, lengthmod),\n                    mul(0x20, iszero(lengthmod))\n                )\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(\n                        add(\n                            add(_bytes, lengthmod),\n                            mul(0x20, iszero(lengthmod))\n                        ),\n                        _start\n                    )\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(\n        bytes memory _bytes,\n        uint256 _start\n    ) internal pure returns (address) {\n        if (_bytes.length < _start + 20) {\n            revert AddressOutOfBounds();\n        }\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/Libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { IDiamondCut } from \"../Interfaces/IDiamondCut.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { OnlyContractOwner } from \"../Errors/GenericErrors.sol\";\n\n/// Implementation of EIP-2535 Diamond Standard\n/// https://eips.ethereum.org/EIPS/eip-2535\nlibrary LibDiamond {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    // Diamond specific errors\n    error IncorrectFacetCutAction();\n    error NoSelectorsInFace();\n    error FunctionAlreadyExists();\n    error FacetAddressIsZero();\n    error FacetAddressIsNotZero();\n    error FacetContainsNoCode();\n    error FunctionDoesNotExist();\n    error FunctionIsImmutable();\n    error InitZeroButCalldataNotEmpty();\n    error CalldataEmptyButInitNotZero();\n    error InitReverted();\n    // ----------------\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner)\n            revert OnlyContractOwner();\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else {\n                revert IncorrectFacetCutAction();\n            }\n            unchecked {\n                ++facetIndex;\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsZero();\n        }\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            if (!LibUtil.isZeroAddress(oldFacetAddress)) {\n                revert FunctionAlreadyExists();\n            }\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            unchecked {\n                ++selectorPosition;\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsZero();\n        }\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            if (oldFacetAddress == _facetAddress) {\n                revert FunctionAlreadyExists();\n            }\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            unchecked {\n                ++selectorPosition;\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        if (!LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsNotZero();\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n            unchecked {\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function addFacet(\n        DiamondStorage storage ds,\n        address _facetAddress\n    ) internal {\n        enforceHasContractCode(_facetAddress);\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\n            .facetAddresses\n            .length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondStorage storage ds,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\n            _selector\n        );\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(\n        DiamondStorage storage ds,\n        address _facetAddress,\n        bytes4 _selector\n    ) internal {\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FunctionDoesNotExist();\n        }\n        // an immutable function is a function defined directly in a diamond\n        if (_facetAddress == address(this)) {\n            revert FunctionIsImmutable();\n        }\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition;\n        uint256 lastSelectorPosition = ds\n            .facetFunctionSelectors[_facetAddress]\n            .functionSelectors\n            .length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds\n                .facetFunctionSelectors[_facetAddress]\n                .functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\n                selectorPosition\n            ] = lastSelector;\n            ds\n                .selectorToFacetAndPosition[lastSelector]\n                .functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[\n                    lastFacetAddressPosition\n                ];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds\n                    .facetFunctionSelectors[lastFacetAddress]\n                    .facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        if (LibUtil.isZeroAddress(_init)) {\n            if (_calldata.length != 0) {\n                revert InitZeroButCalldataNotEmpty();\n            }\n        } else {\n            if (_calldata.length == 0) {\n                revert CalldataEmptyButInitNotZero();\n            }\n            if (_init != address(this)) {\n                enforceHasContractCode(_init);\n            }\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert InitReverted();\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract) internal view {\n        uint256 contractSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if (contractSize == 0) {\n            revert FacetContainsNoCode();\n        }\n    }\n}\n"
    },
    "src/Libraries/LibSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\nimport { InvalidContract, NoSwapFromZeroBalance, InsufficientBalance } from \"../Errors/GenericErrors.sol\";\nimport { IERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nlibrary LibSwap {\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n        bool requiresDeposit;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swap) internal {\n        if (!LibAsset.isContract(_swap.callTo)) revert InvalidContract();\n        uint256 fromAmount = _swap.fromAmount;\n        if (fromAmount == 0) revert NoSwapFromZeroBalance();\n        uint256 nativeValue = LibAsset.isNativeAsset(_swap.sendingAssetId)\n            ? _swap.fromAmount\n            : 0;\n        uint256 initialSendingAssetBalance = LibAsset.getOwnBalance(\n            _swap.sendingAssetId\n        );\n        uint256 initialReceivingAssetBalance = LibAsset.getOwnBalance(\n            _swap.receivingAssetId\n        );\n\n        if (nativeValue == 0) {\n            LibAsset.maxApproveERC20(\n                IERC20(_swap.sendingAssetId),\n                _swap.approveTo,\n                _swap.fromAmount\n            );\n        }\n\n        if (initialSendingAssetBalance < _swap.fromAmount) {\n            revert InsufficientBalance(\n                _swap.fromAmount,\n                initialSendingAssetBalance\n            );\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swap.callTo.call{\n            value: nativeValue\n        }(_swap.callData);\n        if (!success) {\n            LibUtil.revertWith(res);\n        }\n\n        uint256 newBalance = LibAsset.getOwnBalance(_swap.receivingAssetId);\n\n        emit AssetSwapped(\n            transactionId,\n            _swap.callTo,\n            _swap.sendingAssetId,\n            _swap.receivingAssetId,\n            _swap.fromAmount,\n            newBalance > initialReceivingAssetBalance\n                ? newBalance - initialReceivingAssetBalance\n                : newBalance,\n            block.timestamp\n        );\n    }\n}\n"
    },
    "src/Libraries/LibUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity 0.8.17;\n\nimport \"./LibBytes.sol\";\n\nlibrary LibUtil {\n    using LibBytes for bytes;\n\n    function getRevertMsg(\n        bytes memory _res\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) return \"Transaction reverted silently\";\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Determines whether the given address is the zero address\n    /// @param addr The address to verify\n    /// @return Boolean indicating if the address is the zero address\n    function isZeroAddress(address addr) internal pure returns (bool) {\n        return addr == address(0);\n    }\n\n    function revertWith(bytes memory data) internal pure {\n        assembly {\n            let dataSize := mload(data) // Load the size of the data\n            let dataPtr := add(data, 0x20) // Advance data pointer to the next word\n            revert(dataPtr, dataSize) // Revert with the given data\n        }\n    }\n}\n"
    },
    "src/Libraries/OFTComposeMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/// @custom:version 1.0.0\npragma solidity =0.8.17;\n\n// This library was taken from: https://github.com/LayerZero-Labs/LayerZero-v2/tree/38278c8d8f4606d0ce247d6edd473fc96674769b/packages/layerzero-v2/evm/oapp/contracts/oft/libs\n// since the Solidity version did not match with ours, we decided to use a copy of this library with adjusted solc version for better compatibility\nlibrary OFTComposeMsgCodec {\n    // Offset constants for decoding composed messages\n    uint8 private constant NONCE_OFFSET = 8;\n    uint8 private constant SRC_EID_OFFSET = 12;\n    uint8 private constant AMOUNT_LD_OFFSET = 44;\n    uint8 private constant COMPOSE_FROM_OFFSET = 76;\n\n    /**\n     * @dev Encodes a OFT composed message.\n     * @param _nonce The nonce value.\n     * @param _srcEid The source endpoint ID.\n     * @param _amountLD The amount in local decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded Composed message.\n     */\n    function encode(\n        uint64 _nonce,\n        uint32 _srcEid,\n        uint256 _amountLD,\n        bytes memory _composeMsg // 0x[composeFrom][composeMsg]\n    ) internal pure returns (bytes memory _msg) {\n        _msg = abi.encodePacked(_nonce, _srcEid, _amountLD, _composeMsg);\n    }\n\n    /**\n     * @dev Retrieves the nonce from the composed message.\n     * @param _msg The message.\n     * @return The nonce value.\n     */\n    function nonce(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[:NONCE_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the source endpoint ID from the composed message.\n     * @param _msg The message.\n     * @return The source endpoint ID.\n     */\n    function srcEid(bytes calldata _msg) internal pure returns (uint32) {\n        return uint32(bytes4(_msg[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the amount in local decimals from the composed message.\n     * @param _msg The message.\n     * @return The amount in local decimals.\n     */\n    function amountLD(bytes calldata _msg) internal pure returns (uint256) {\n        return uint256(bytes32(_msg[SRC_EID_OFFSET:AMOUNT_LD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composeFrom value from the composed message.\n     * @param _msg The message.\n     * @return The composeFrom value.\n     */\n    function composeFrom(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[AMOUNT_LD_OFFSET:COMPOSE_FROM_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(\n        bytes calldata _msg\n    ) internal pure returns (bytes memory) {\n        return _msg[COMPOSE_FROM_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "src/LiFiDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibDiamond } from \"./Libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./Interfaces/IDiamondCut.sol\";\nimport { LibUtil } from \"./Libraries/LibUtil.sol\";\n\n/// @title LIFI Diamond\n/// @author LI.FI (https://li.fi)\n/// @notice Base EIP-2535 Diamond Proxy Contract.\n/// @custom:version 1.0.0\ncontract LiFiDiamond {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n\n        // get diamond storage\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n\n        if (facet == address(0)) {\n            revert LibDiamond.FunctionDoesNotExist();\n        }\n\n        // Execute external function from facet using delegatecall and return any value.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Able to receive ether\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/Periphery/ERC20Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { Ownable } from \"../../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\n/// @title ERC20 Proxy\n/// @author LI.FI (https://li.fi)\n/// @notice Proxy contract for safely transferring ERC20 tokens for swaps/executions\n/// @custom:version 1.0.0\ncontract ERC20Proxy is Ownable {\n    /// Storage ///\n    mapping(address => bool) public authorizedCallers;\n\n    /// Errors ///\n    error UnAuthorized();\n\n    /// Events ///\n    event AuthorizationChanged(address indexed caller, bool authorized);\n\n    /// Constructor\n    constructor(address _owner) {\n        transferOwnership(_owner);\n    }\n\n    /// @notice Sets whether or not a specified caller is authorized to call this contract\n    /// @param caller the caller to change authorization for\n    /// @param authorized specifies whether the caller is authorized (true/false)\n    function setAuthorizedCaller(\n        address caller,\n        bool authorized\n    ) external onlyOwner {\n        authorizedCallers[caller] = authorized;\n        emit AuthorizationChanged(caller, authorized);\n    }\n\n    /// @notice Transfers tokens from one address to another specified address\n    /// @param tokenAddress the ERC20 contract address of the token to send\n    /// @param from the address to transfer from\n    /// @param to the address to transfer to\n    /// @param amount the amount of tokens to send\n    function transferFrom(\n        address tokenAddress,\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        if (!authorizedCallers[msg.sender]) revert UnAuthorized();\n\n        LibAsset.transferFromERC20(tokenAddress, from, to, amount);\n    }\n}\n"
    },
    "src/Periphery/Executor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { UnAuthorized } from \"../../src/Errors/GenericErrors.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IERC20Proxy } from \"../Interfaces/IERC20Proxy.sol\";\nimport { ERC1155Holder } from \"../../lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport { ERC721Holder } from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { IERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Executor\n/// @author LI.FI (https://li.fi)\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing\n/// @custom:version 2.0.0\ncontract Executor is ILiFi, ReentrancyGuard, ERC1155Holder, ERC721Holder {\n    /// Storage ///\n\n    /// @notice The address of the ERC20Proxy contract\n    IERC20Proxy public erc20Proxy;\n\n    /// Events ///\n    event ERC20ProxySet(address indexed proxy);\n\n    /// Modifiers ///\n\n    /// @dev Sends any leftover balances back to the user\n    modifier noLeftovers(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            uint256[] memory initialBalances = _fetchBalances(_swaps);\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance = 0;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance = LibAsset.getOwnBalance(curAsset);\n                    if (curBalance > initialBalances[i]) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance - initialBalances[i]\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// Constructor\n    /// @notice Initialize local variables for the Executor\n    /// @param _erc20Proxy The address of the ERC20Proxy contract\n    constructor(address _erc20Proxy) {\n        erc20Proxy = IERC20Proxy(_erc20Proxy);\n        emit ERC20ProxySet(_erc20Proxy);\n    }\n\n    /// External Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver\n    ) external payable nonReentrant {\n        _processSwaps(\n            _transactionId,\n            _swapData,\n            _transferredAssetId,\n            _receiver,\n            0,\n            true\n        );\n    }\n\n    /// @notice Performs a series of swaps or arbitrary executions\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    /// @param _amount amount of token for swaps or arbitrary executions\n    function swapAndExecute(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver,\n        uint256 _amount\n    ) external payable nonReentrant {\n        _processSwaps(\n            _transactionId,\n            _swapData,\n            _transferredAssetId,\n            _receiver,\n            _amount,\n            false\n        );\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a series of swaps or arbitrary executions\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    /// @param _amount amount of token for swaps or arbitrary executions\n    /// @param _depositAllowance If deposit approved amount of token\n    function _processSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver,\n        uint256 _amount,\n        bool _depositAllowance\n    ) private {\n        uint256 startingBalance;\n        uint256 finalAssetStartingBalance;\n        address finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        if (!LibAsset.isNativeAsset(finalAssetId)) {\n            finalAssetStartingBalance = LibAsset.getOwnBalance(finalAssetId);\n        } else {\n            finalAssetStartingBalance =\n                LibAsset.getOwnBalance(finalAssetId) -\n                msg.value;\n        }\n\n        if (!LibAsset.isNativeAsset(_transferredAssetId)) {\n            startingBalance = LibAsset.getOwnBalance(_transferredAssetId);\n            if (_depositAllowance) {\n                uint256 allowance = IERC20(_transferredAssetId).allowance(\n                    msg.sender,\n                    address(this)\n                );\n                LibAsset.depositAsset(_transferredAssetId, allowance);\n            } else {\n                erc20Proxy.transferFrom(\n                    _transferredAssetId,\n                    msg.sender,\n                    address(this),\n                    _amount\n                );\n            }\n        } else {\n            startingBalance =\n                LibAsset.getOwnBalance(_transferredAssetId) -\n                msg.value;\n        }\n\n        _executeSwaps(_transactionId, _swapData, _receiver);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_transferredAssetId);\n        if (postSwapBalance > startingBalance) {\n            LibAsset.transferAsset(\n                _transferredAssetId,\n                _receiver,\n                postSwapBalance - startingBalance\n            );\n        }\n\n        uint256 finalAssetPostSwapBalance = LibAsset.getOwnBalance(\n            finalAssetId\n        );\n\n        if (finalAssetPostSwapBalance > finalAssetStartingBalance) {\n            LibAsset.transferAsset(\n                finalAssetId,\n                _receiver,\n                finalAssetPostSwapBalance - finalAssetStartingBalance\n            );\n        }\n\n        emit LiFiTransferCompleted(\n            _transactionId,\n            _transferredAssetId,\n            _receiver,\n            finalAssetPostSwapBalance,\n            block.timestamp\n        );\n    }\n\n    /// @dev Executes swaps one after the other\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData Array of data used to execute swaps\n    /// @param _leftoverReceiver Address to receive lefover tokens\n    function _executeSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address payable _leftoverReceiver\n    ) private noLeftovers(_swapData, _leftoverReceiver) {\n        uint256 numSwaps = _swapData.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            if (_swapData[i].callTo == address(erc20Proxy)) {\n                revert UnAuthorized(); // Prevent calling ERC20 Proxy directly\n            }\n\n            LibSwap.SwapData calldata currentSwapData = _swapData[i];\n            LibSwap.swap(_transactionId, currentSwapData);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Fetches balances of tokens to be swapped before swapping.\n    /// @param _swapData Array of data used to execute swaps\n    /// @return uint256[] Array of token balances.\n    function _fetchBalances(\n        LibSwap.SwapData[] calldata _swapData\n    ) private view returns (uint256[] memory) {\n        uint256 numSwaps = _swapData.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swapData[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }\n\n    /// @dev required for receiving native assets from destination swaps\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/Periphery/FeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title Fee Collector\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for collecting integrator fees\n/// @custom:version 1.0.0\ncontract FeeCollector is TransferrableOwnership {\n    /// State ///\n\n    // Integrator -> TokenAddress -> Balance\n    mapping(address => mapping(address => uint256)) private _balances;\n    // TokenAddress -> Balance\n    mapping(address => uint256) private _lifiBalances;\n\n    /// Errors ///\n    error TransferFailure();\n    error NotEnoughNativeForFees();\n\n    /// Events ///\n    event FeesCollected(\n        address indexed _token,\n        address indexed _integrator,\n        uint256 _integratorFee,\n        uint256 _lifiFee\n    );\n    event FeesWithdrawn(\n        address indexed _token,\n        address indexed _to,\n        uint256 _amount\n    );\n    event LiFiFeesWithdrawn(\n        address indexed _token,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    /// Constructor ///\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) TransferrableOwnership(_owner) {}\n\n    /// External Methods ///\n\n    /// @notice Collects fees for the integrator\n    /// @param tokenAddress address of the token to collect fees for\n    /// @param integratorFee amount of fees to collect going to the integrator\n    /// @param lifiFee amount of fees to collect going to lifi\n    /// @param integratorAddress address of the integrator\n    function collectTokenFees(\n        address tokenAddress,\n        uint256 integratorFee,\n        uint256 lifiFee,\n        address integratorAddress\n    ) external {\n        LibAsset.depositAsset(tokenAddress, integratorFee + lifiFee);\n        _balances[integratorAddress][tokenAddress] += integratorFee;\n        _lifiBalances[tokenAddress] += lifiFee;\n        emit FeesCollected(\n            tokenAddress,\n            integratorAddress,\n            integratorFee,\n            lifiFee\n        );\n    }\n\n    /// @notice Collects fees for the integrator in native token\n    /// @param integratorFee amount of fees to collect going to the integrator\n    /// @param lifiFee amount of fees to collect going to lifi\n    /// @param integratorAddress address of the integrator\n    function collectNativeFees(\n        uint256 integratorFee,\n        uint256 lifiFee,\n        address integratorAddress\n    ) external payable {\n        if (msg.value < integratorFee + lifiFee)\n            revert NotEnoughNativeForFees();\n        _balances[integratorAddress][LibAsset.NULL_ADDRESS] += integratorFee;\n        _lifiBalances[LibAsset.NULL_ADDRESS] += lifiFee;\n        uint256 remaining = msg.value - (integratorFee + lifiFee);\n        // Prevent extra native token from being locked in the contract\n        if (remaining > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = payable(msg.sender).call{ value: remaining }(\n                \"\"\n            );\n            if (!success) {\n                revert TransferFailure();\n            }\n        }\n        emit FeesCollected(\n            LibAsset.NULL_ADDRESS,\n            integratorAddress,\n            integratorFee,\n            lifiFee\n        );\n    }\n\n    /// @notice Withdraw fees and sends to the integrator\n    /// @param tokenAddress address of the token to withdraw fees for\n    function withdrawIntegratorFees(address tokenAddress) external {\n        uint256 balance = _balances[msg.sender][tokenAddress];\n        if (balance == 0) {\n            return;\n        }\n        _balances[msg.sender][tokenAddress] = 0;\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit FeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraw fees and sends to the integrator\n    /// @param tokenAddresses addresses of the tokens to withdraw fees for\n    function batchWithdrawIntegratorFees(\n        address[] memory tokenAddresses\n    ) external {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = _balances[msg.sender][tokenAddresses[i]];\n            if (balance != 0) {\n                _balances[msg.sender][tokenAddresses[i]] = 0;\n                LibAsset.transferAsset(\n                    tokenAddresses[i],\n                    payable(msg.sender),\n                    balance\n                );\n                emit FeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Withdraws fees and sends to lifi\n    /// @param tokenAddress address of the token to withdraw fees for\n    function withdrawLifiFees(address tokenAddress) external onlyOwner {\n        uint256 balance = _lifiBalances[tokenAddress];\n        if (balance == 0) {\n            return;\n        }\n        _lifiBalances[tokenAddress] = 0;\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit LiFiFeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraws fees and sends to lifi\n    /// @param tokenAddresses addresses of the tokens to withdraw fees for\n    function batchWithdrawLifiFees(\n        address[] memory tokenAddresses\n    ) external onlyOwner {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = _lifiBalances[tokenAddresses[i]];\n            _lifiBalances[tokenAddresses[i]] = 0;\n            LibAsset.transferAsset(\n                tokenAddresses[i],\n                payable(msg.sender),\n                balance\n            );\n            emit LiFiFeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the balance of the integrator\n    /// @param integratorAddress address of the integrator\n    /// @param tokenAddress address of the token to get the balance of\n    function getTokenBalance(\n        address integratorAddress,\n        address tokenAddress\n    ) external view returns (uint256) {\n        return _balances[integratorAddress][tokenAddress];\n    }\n\n    /// @notice Returns the balance of lifi\n    /// @param tokenAddress address of the token to get the balance of\n    function getLifiTokenBalance(\n        address tokenAddress\n    ) external view returns (uint256) {\n        return _lifiBalances[tokenAddress];\n    }\n}\n"
    },
    "src/Periphery/GasRebateDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { MerkleProof } from \"../../lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Pausable } from \"../../lib/openzeppelin-contracts/contracts/security/Pausable.sol\";\n\n/// @title GasRebateDistributor\n/// @author LI.FI (https://li.fi)\n/// @notice Contract to distribute gas rebates from a LI.FI marketing campaign\n/// @custom:version 1.0.0\ncontract GasRebateDistributor is TransferrableOwnership, Pausable {\n    /// Storage ///\n\n    /// stores the root of the merkle tree that contains info about which account can claim which amount in which token\n    bytes32 public merkleRoot;\n    /// (account => latestClaimedMerkleRootVersion) mapping from account to the latest merkle root version that was claimed by this address\n    mapping(address => uint8) private _hasClaimed;\n    /// stores the current version of the merkle root\n    uint8 private _currentMerkleRootVersion;\n    /// stores the timestamp until the claims of the current merkle root can be claimed\n    uint256 public claimDeadline;\n    /// address of the ERC20 token in which gas rebates are paid out\n    address public tokenAddress;\n\n    /// Errors ///\n\n    error AlreadyClaimed();\n    error InvalidProof();\n    error ClaimDeadlineExpired();\n\n    /// Events ///\n\n    event Claimed(address indexed account, uint256 amount);\n\n    /// Constructor\n    constructor(\n        address owner_,\n        bytes32 merkleRoot_,\n        uint256 deadline,\n        address tokenAddress_\n    ) TransferrableOwnership(owner_) Pausable() {\n        merkleRoot = merkleRoot_;\n        claimDeadline = deadline;\n        tokenAddress = tokenAddress_;\n        _currentMerkleRootVersion = 1;\n    }\n\n    /// EXTERNAL FUNCTIONS ///\n\n    /// @notice Allows the caller of this function to claim the specified amount if presented with a valid merkle proof\n    /// @param amount the amount that should be claimed\n    /// @param merkleProof the merkle proof required to verify the claim (this proof is generated by LI.FI backend)\n    function claim(\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) public virtual whenNotPaused {\n        // check if account claimed already for the current merkle root version\n        if (_hasClaimed[msg.sender] == _currentMerkleRootVersion)\n            revert AlreadyClaimed();\n\n        // check if claim deadline is expired\n        if (block.timestamp > claimDeadline) revert ClaimDeadlineExpired();\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, amount));\n        if (!MerkleProof.verify(merkleProof, merkleRoot, node))\n            revert InvalidProof();\n\n        // Mark the account as claimed for the current merkle root version\n        _hasClaimed[msg.sender] = _currentMerkleRootVersion;\n\n        // send specified and validated amount of tokens to caller\n        SafeERC20.safeTransfer(IERC20(tokenAddress), msg.sender, amount);\n\n        emit Claimed(msg.sender, amount);\n    }\n\n    /// ADMIN FUNCTIONS ///\n\n    /// @notice Sends all unclaimed token balance(s) to the specified address\n    /// @param to the address unclaimed funds should be sent to\n    function withdrawUnclaimed(\n        address[] calldata tokenAddresses,\n        address to\n    ) public onlyOwner whenNotPaused {\n        for (uint i; i < tokenAddresses.length; ) {\n            // get current balance\n            uint256 balance = IERC20(tokenAddresses[i]).balanceOf(\n                address(this)\n            );\n\n            // send specified and validated amount of tokens to caller\n            SafeERC20.safeTransfer(IERC20(tokenAddresses[i]), to, balance);\n\n            // gas-efficient way to increase loop index\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Updates the merkle root and its version to allow wallets that have previously claimed to claim again, if permitted\n    /// @param merkleRoot_ the root of the merkle tree that contains all claimable amounts\n    /// @param deadline timestamp until claims for this merkle root are claimable\n    /// @param tokenAddress_ address of the gas rebate token\n    function updateMerkleRoot(\n        bytes32 merkleRoot_,\n        uint256 deadline,\n        address tokenAddress_\n    ) public onlyOwner {\n        // update the merkle root\n        merkleRoot = merkleRoot_;\n\n        // update tokenAddress\n        tokenAddress = tokenAddress_;\n\n        // update the claimable-until deadline\n        claimDeadline = deadline;\n\n        // increase the merkle root version\n        _currentMerkleRootVersion++;\n    }\n\n    /// @notice Allows to pause the contract to stop claims and withdrawals for security purposes\n    function pauseContract() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Allows to unpause the contract to stop claims and withdrawals for security purposes\n    function unpauseContract() external onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "src/Periphery/LiFiDEXAggregator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.17;\n\nimport { SafeERC20, IERC20, IERC20Permit } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable } from \"../../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\n\naddress constant NATIVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\naddress constant IMPOSSIBLE_POOL_ADDRESS = 0x0000000000000000000000000000000000000001;\naddress constant INTERNAL_INPUT_SOURCE = 0x0000000000000000000000000000000000000000;\n\nuint8 constant LOCKED = 2;\nuint8 constant NOT_LOCKED = 1;\nuint8 constant PAUSED = 2;\nuint8 constant NOT_PAUSED = 1;\n\n/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\nuint160 constant MIN_SQRT_RATIO = 4295128739;\n/// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\nuint160 constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n/// @title LiFi DEX Aggregator\n/// @author Ilya Lyalin (contract copied from: https://github.com/sushiswap/sushiswap/blob/c8c80dec821003eb72eb77c7e0446ddde8ca9e1e/protocols/route-processor/contracts/RouteProcessor4.sol)\n/// @notice Processes calldata to swap using various DEXs\n/// @custom:version 1.0.0\ncontract LiFiDEXAggregator is Ownable {\n    using SafeERC20 for IERC20;\n    using Approve for IERC20;\n    using SafeERC20 for IERC20Permit;\n    using InputStream for uint256;\n\n    event Route(\n        address indexed from,\n        address to,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256 amountOut\n    );\n\n    error MinimalOutputBalanceViolation(uint256 amountOut);\n\n    IBentoBoxMinimal public immutable bentoBox;\n    mapping(address => bool) public priviledgedUsers;\n    address private lastCalledPool;\n\n    uint8 private unlocked = NOT_LOCKED;\n    uint8 private paused = NOT_PAUSED;\n    modifier lock() {\n        require(unlocked == NOT_LOCKED, \"RouteProcessor is locked\");\n        require(paused == NOT_PAUSED, \"RouteProcessor is paused\");\n        unlocked = LOCKED;\n        _;\n        unlocked = NOT_LOCKED;\n    }\n\n    modifier onlyOwnerOrPriviledgedUser() {\n        require(\n            msg.sender == owner() || priviledgedUsers[msg.sender],\n            \"RP: caller is not the owner or a privileged user\"\n        );\n        _;\n    }\n\n    constructor(address _bentoBox, address[] memory priviledgedUserList) {\n        bentoBox = IBentoBoxMinimal(_bentoBox);\n        lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n\n        for (uint256 i = 0; i < priviledgedUserList.length; i++) {\n            priviledgedUsers[priviledgedUserList[i]] = true;\n        }\n    }\n\n    function setPriviledge(address user, bool priviledge) external onlyOwner {\n        priviledgedUsers[user] = priviledge;\n    }\n\n    function pause() external onlyOwnerOrPriviledgedUser {\n        paused = PAUSED;\n    }\n\n    function resume() external onlyOwnerOrPriviledgedUser {\n        paused = NOT_PAUSED;\n    }\n\n    /// @notice For native unwrapping\n    receive() external payable {}\n\n    /// @notice Processes the route generated off-chain. Has a lock\n    /// @param tokenIn Address of the input token\n    /// @param amountIn Amount of the input token\n    /// @param tokenOut Address of the output token\n    /// @param amountOutMin Minimum amount of the output token\n    /// @return amountOut Actual amount of the output token\n    function processRoute(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        uint256 amountOutMin,\n        address to,\n        bytes memory route\n    ) external payable lock returns (uint256 amountOut) {\n        return\n            processRouteInternal(\n                tokenIn,\n                amountIn,\n                tokenOut,\n                amountOutMin,\n                to,\n                route\n            );\n    }\n\n    /// @notice Transfers some value to <transferValueTo> and then processes the route\n    /// @param transferValueTo Address where the value should be transferred\n    /// @param amountValueTransfer How much value to transfer\n    /// @param tokenIn Address of the input token\n    /// @param amountIn Amount of the input token\n    /// @param tokenOut Address of the output token\n    /// @param amountOutMin Minimum amount of the output token\n    /// @return amountOut Actual amount of the output token\n    function transferValueAndprocessRoute(\n        address payable transferValueTo,\n        uint256 amountValueTransfer,\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        uint256 amountOutMin,\n        address to,\n        bytes memory route\n    ) external payable lock returns (uint256 amountOut) {\n        (bool success, bytes memory returnBytes) = transferValueTo.call{\n            value: amountValueTransfer\n        }(\"\");\n        if (!success) {\n            assembly {\n                revert(add(32, returnBytes), mload(returnBytes))\n            }\n        }\n        return\n            processRouteInternal(\n                tokenIn,\n                amountIn,\n                tokenOut,\n                amountOutMin,\n                to,\n                route\n            );\n    }\n\n    /// @notice Processes the route generated off-chain\n    /// @param tokenIn Address of the input token\n    /// @param amountIn Amount of the input token\n    /// @param tokenOut Address of the output token\n    /// @param amountOutMin Minimum amount of the output token\n    /// @return amountOut Actual amount of the output token\n    function processRouteInternal(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        uint256 amountOutMin,\n        address to,\n        bytes memory route\n    ) private returns (uint256 amountOut) {\n        uint256 balanceInInitial = tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender);\n        uint256 balanceOutInitial = tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to);\n\n        uint256 realAmountIn = amountIn;\n        {\n            uint256 step = 0;\n            uint256 stream = InputStream.createStream(route);\n            while (stream.isNotEmpty()) {\n                uint8 commandCode = stream.readUint8();\n                if (commandCode == 1) {\n                    uint256 usedAmount = processMyERC20(stream);\n                    if (step == 0) realAmountIn = usedAmount;\n                } else if (commandCode == 2)\n                    processUserERC20(stream, amountIn);\n                else if (commandCode == 3) {\n                    uint256 usedAmount = processNative(stream);\n                    if (step == 0) realAmountIn = usedAmount;\n                } else if (commandCode == 4) processOnePool(stream);\n                else if (commandCode == 5) processInsideBento(stream);\n                else if (commandCode == 6) applyPermit(tokenIn, stream);\n                else revert(\"RouteProcessor: Unknown command code\");\n                ++step;\n            }\n        }\n\n        uint256 balanceInFinal = tokenIn == NATIVE_ADDRESS\n            ? 0\n            : IERC20(tokenIn).balanceOf(msg.sender);\n        require(\n            balanceInFinal + amountIn >= balanceInInitial,\n            \"RouteProcessor: Minimal input balance violation\"\n        );\n\n        uint256 balanceOutFinal = tokenOut == NATIVE_ADDRESS\n            ? address(to).balance\n            : IERC20(tokenOut).balanceOf(to);\n        if (balanceOutFinal < balanceOutInitial + amountOutMin)\n            revert MinimalOutputBalanceViolation(\n                balanceOutFinal - balanceOutInitial\n            );\n\n        amountOut = balanceOutFinal - balanceOutInitial;\n\n        emit Route(\n            msg.sender,\n            to,\n            tokenIn,\n            tokenOut,\n            realAmountIn,\n            amountOutMin,\n            amountOut\n        );\n    }\n\n    /// @notice Applies ERC-2612 permit\n    /// @param tokenIn permitted token\n    /// @param stream Streamed program\n    function applyPermit(address tokenIn, uint256 stream) private {\n        uint256 value = stream.readUint();\n        uint256 deadline = stream.readUint();\n        uint8 v = stream.readUint8();\n        bytes32 r = stream.readBytes32();\n        bytes32 s = stream.readBytes32();\n        IERC20Permit(tokenIn).safePermit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n    }\n\n    /// @notice Processes native coin: call swap for all pools that swap from native coin\n    /// @param stream Streamed program\n    function processNative(\n        uint256 stream\n    ) private returns (uint256 amountTotal) {\n        amountTotal = address(this).balance;\n        distributeAndSwap(stream, address(this), NATIVE_ADDRESS, amountTotal);\n    }\n\n    /// @notice Processes ERC20 token from this contract balance:\n    /// @notice Call swap for all pools that swap from this token\n    /// @param stream Streamed program\n    function processMyERC20(\n        uint256 stream\n    ) private returns (uint256 amountTotal) {\n        address token = stream.readAddress();\n        amountTotal = IERC20(token).balanceOf(address(this));\n        unchecked {\n            if (amountTotal > 0) amountTotal -= 1; // slot undrain protection\n        }\n        distributeAndSwap(stream, address(this), token, amountTotal);\n    }\n\n    /// @notice Processes ERC20 token from msg.sender balance:\n    /// @notice Call swap for all pools that swap from this token\n    /// @param stream Streamed program\n    /// @param amountTotal Amount of tokens to take from msg.sender\n    function processUserERC20(uint256 stream, uint256 amountTotal) private {\n        address token = stream.readAddress();\n        distributeAndSwap(stream, msg.sender, token, amountTotal);\n    }\n\n    /// @notice Processes ERC20 token for cases when the token has only one output pool\n    /// @notice In this case liquidity is already at pool balance. This is an optimization\n    /// @notice Call swap for all pools that swap from this token\n    /// @param stream Streamed program\n    function processOnePool(uint256 stream) private {\n        address token = stream.readAddress();\n        swap(stream, INTERNAL_INPUT_SOURCE, token, 0);\n    }\n\n    /// @notice Processes Bento tokens\n    /// @notice Call swap for all pools that swap from this token\n    /// @param stream Streamed program\n    function processInsideBento(uint256 stream) private {\n        address token = stream.readAddress();\n        uint256 amountTotal = bentoBox.balanceOf(token, address(this));\n        unchecked {\n            if (amountTotal > 0) amountTotal -= 1; // slot undrain protection\n        }\n        distributeAndSwap(stream, address(this), token, amountTotal);\n    }\n\n    /// @notice Distributes amountTotal to several pools according to their shares and calls swap for each pool\n    /// @param stream Streamed program\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountTotal Total amount of tokenIn for swaps\n    function distributeAndSwap(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountTotal\n    ) private {\n        uint8 num = stream.readUint8();\n        unchecked {\n            for (uint256 i = 0; i < num; ++i) {\n                uint16 share = stream.readUint16();\n                uint256 amount = (amountTotal * share) /\n                    type(uint16).max /*65535*/;\n                amountTotal -= amount;\n                swap(stream, from, tokenIn, amount);\n            }\n        }\n    }\n\n    /// @notice Makes swap\n    /// @param stream Streamed program\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swap(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        uint8 poolType = stream.readUint8();\n        if (poolType == 0) swapUniV2(stream, from, tokenIn, amountIn);\n        else if (poolType == 1) swapUniV3(stream, from, tokenIn, amountIn);\n        else if (poolType == 2) wrapNative(stream, from, tokenIn, amountIn);\n        else if (poolType == 3) bentoBridge(stream, from, tokenIn, amountIn);\n        else if (poolType == 4) swapTrident(stream, from, tokenIn, amountIn);\n        else if (poolType == 5) swapCurve(stream, from, tokenIn, amountIn);\n        else revert(\"RouteProcessor: Unknown pool type\");\n    }\n\n    /// @notice Wraps/unwraps native token\n    /// @param stream [direction & fake, recipient, wrapToken?]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function wrapNative(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        uint8 directionAndFake = stream.readUint8();\n        address to = stream.readAddress();\n\n        if (directionAndFake & 1 == 1) {\n            // wrap native\n            address wrapToken = stream.readAddress();\n            if (directionAndFake & 2 == 0)\n                IWETH(wrapToken).deposit{ value: amountIn }();\n            if (to != address(this))\n                IERC20(wrapToken).safeTransfer(to, amountIn);\n        } else {\n            // unwrap native\n            if (directionAndFake & 2 == 0) {\n                if (from == msg.sender)\n                    IERC20(tokenIn).safeTransferFrom(\n                        msg.sender,\n                        address(this),\n                        amountIn\n                    );\n                IWETH(tokenIn).withdraw(amountIn);\n            }\n            (bool success, ) = payable(to).call{ value: amountIn }(\"\");\n            require(\n                success,\n                \"RouteProcessor.wrapNative: Native token transfer failed\"\n            );\n        }\n    }\n\n    /// @notice Bridge/unbridge tokens to/from Bento\n    /// @param stream [direction, recipient]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function bentoBridge(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        uint8 direction = stream.readUint8();\n        address to = stream.readAddress();\n\n        if (direction > 0) {\n            // outside to Bento\n            // deposit to arbitrary recipient is possible only from address(bentoBox)\n            if (from == address(this))\n                IERC20(tokenIn).safeTransfer(address(bentoBox), amountIn);\n            else if (from == msg.sender)\n                IERC20(tokenIn).safeTransferFrom(\n                    msg.sender,\n                    address(bentoBox),\n                    amountIn\n                );\n            else {\n                // tokens already are at address(bentoBox)\n                amountIn =\n                    IERC20(tokenIn).balanceOf(address(bentoBox)) +\n                    bentoBox.strategyData(tokenIn).balance -\n                    bentoBox.totals(tokenIn).elastic;\n            }\n            bentoBox.deposit(tokenIn, address(bentoBox), to, amountIn, 0);\n        } else {\n            // Bento to outside\n            if (from != INTERNAL_INPUT_SOURCE) {\n                bentoBox.transfer(tokenIn, from, address(this), amountIn);\n            } else amountIn = bentoBox.balanceOf(tokenIn, address(this));\n            bentoBox.withdraw(tokenIn, address(this), to, 0, amountIn);\n        }\n    }\n\n    /// @notice UniswapV2 pool swap\n    /// @param stream [pool, direction, recipient, fee]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swapUniV2(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        address pool = stream.readAddress();\n        uint8 direction = stream.readUint8();\n        address to = stream.readAddress();\n        uint24 fee = stream.readUint24(); // pool fee in 1/1_000_000\n\n        if (from == address(this))\n            IERC20(tokenIn).safeTransfer(pool, amountIn);\n        else if (from == msg.sender)\n            IERC20(tokenIn).safeTransferFrom(msg.sender, pool, amountIn);\n\n        (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pool).getReserves();\n        require(r0 > 0 && r1 > 0, \"Wrong pool reserves\");\n        (uint256 reserveIn, uint256 reserveOut) = direction == 1\n            ? (r0, r1)\n            : (r1, r0);\n        amountIn = IERC20(tokenIn).balanceOf(pool) - reserveIn; // tokens already were transferred\n\n        uint256 amountInWithFee = amountIn * (1_000_000 - fee);\n        uint256 amountOut = (amountInWithFee * reserveOut) /\n            (reserveIn * 1_000_000 + amountInWithFee);\n        (uint256 amount0Out, uint256 amount1Out) = direction == 1\n            ? (uint256(0), amountOut)\n            : (amountOut, uint256(0));\n        IUniswapV2Pair(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n\n    /// @notice Trident pool swap\n    /// @param stream [pool, swapData]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swapTrident(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        address pool = stream.readAddress();\n        bytes memory swapData = stream.readBytes();\n\n        if (from != INTERNAL_INPUT_SOURCE) {\n            bentoBox.transfer(tokenIn, from, pool, amountIn);\n        }\n\n        IPool(pool).swap(swapData);\n    }\n\n    /// @notice UniswapV3 pool swap\n    /// @param stream [pool, direction, recipient]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swapUniV3(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        address pool = stream.readAddress();\n        bool zeroForOne = stream.readUint8() > 0;\n        address recipient = stream.readAddress();\n\n        if (from == msg.sender)\n            IERC20(tokenIn).safeTransferFrom(\n                msg.sender,\n                address(this),\n                uint256(amountIn)\n            );\n\n        lastCalledPool = pool;\n        IUniswapV3Pool(pool).swap(\n            recipient,\n            zeroForOne,\n            int256(amountIn),\n            zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n            abi.encode(tokenIn)\n        );\n        require(\n            lastCalledPool == IMPOSSIBLE_POOL_ADDRESS,\n            \"RouteProcessor.swapUniV3: unexpected\"\n        ); // Just to be sure\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) public {\n        require(\n            msg.sender == lastCalledPool,\n            \"RouteProcessor.uniswapV3SwapCallback: call from unknown source\"\n        );\n        int256 amount = amount0Delta > 0 ? amount0Delta : amount1Delta;\n        require(\n            amount > 0,\n            \"RouteProcessor.uniswapV3SwapCallback: not positive amount\"\n        );\n\n        lastCalledPool = IMPOSSIBLE_POOL_ADDRESS;\n        address tokenIn = abi.decode(data, (address));\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount));\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method _must_ be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n    function algebraSwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Called to `msg.sender` after executing a swap via PancakeV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the PancakeV3Pool#swap call\n    function pancakeV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        uniswapV3SwapCallback(amount0Delta, amount1Delta, data);\n    }\n\n    /// @notice Curve pool swap. Legacy pools that don't return amountOut and have native coins are not supported\n    /// @param stream [pool, poolType, fromIndex, toIndex, recipient, output token]\n    /// @param from Where to take liquidity for swap\n    /// @param tokenIn Input token\n    /// @param amountIn Amount of tokenIn to take for swap\n    function swapCurve(\n        uint256 stream,\n        address from,\n        address tokenIn,\n        uint256 amountIn\n    ) private {\n        address pool = stream.readAddress();\n        uint8 poolType = stream.readUint8();\n        int128 fromIndex = int8(stream.readUint8());\n        int128 toIndex = int8(stream.readUint8());\n        address to = stream.readAddress();\n        address tokenOut = stream.readAddress();\n\n        uint256 amountOut;\n        if (tokenIn == NATIVE_ADDRESS) {\n            amountOut = ICurve(pool).exchange{ value: amountIn }(\n                fromIndex,\n                toIndex,\n                amountIn,\n                0\n            );\n        } else {\n            if (from == msg.sender)\n                IERC20(tokenIn).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amountIn\n                );\n            IERC20(tokenIn).approveSafe(pool, amountIn);\n            if (poolType == 0)\n                amountOut = ICurve(pool).exchange(\n                    fromIndex,\n                    toIndex,\n                    amountIn,\n                    0\n                );\n            else {\n                uint256 balanceBefore = IERC20(tokenOut).balanceOf(\n                    address(this)\n                );\n                ICurveLegacy(pool).exchange(fromIndex, toIndex, amountIn, 0);\n                uint256 balanceAfter = IERC20(tokenOut).balanceOf(\n                    address(this)\n                );\n                amountOut = balanceAfter - balanceBefore;\n            }\n        }\n\n        if (to != address(this)) {\n            if (tokenOut == NATIVE_ADDRESS) {\n                (bool success, ) = payable(to).call{ value: amountOut }(\"\");\n                require(\n                    success,\n                    \"RouteProcessor.swapCurve: Native token transfer failed\"\n                );\n            } else {\n                IERC20(tokenOut).safeTransfer(to, amountOut);\n            }\n        }\n    }\n}\n\n/// @notice Minimal BentoBox vault interface.\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\ninterface IBentoBoxMinimal {\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    function strategyData(\n        address token\n    ) external view returns (StrategyData memory total);\n\n    /// @dev Approves users' BentoBox assets to a \"master\" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}\n\ninterface ICurve {\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable returns (uint256);\n}\n\ninterface ICurveLegacy {\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable;\n}\n\n/// @notice Trident pool interface.\ninterface IPool {\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(\n        bytes calldata data\n    ) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(\n        bytes calldata data\n    ) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(\n        bytes calldata data\n    ) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(\n        bytes calldata data\n    ) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(\n        bytes calldata data\n    ) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(\n        bytes calldata data\n    ) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(\n        address indexed recipient,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}\n\ninterface ITridentCLPool {\n    function token0() external returns (address);\n\n    function token1() external returns (address);\n\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bool unwrapBento,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint);\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(\n        address indexed sender,\n        uint amount0,\n        uint amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint);\n\n    function price1CumulativeLast() external view returns (uint);\n\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV3Pool {\n    function token0() external returns (address);\n\n    function token1() external returns (address);\n\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n\n/** @notice Simple read stream */\nlibrary InputStream {\n    /** @notice Creates stream from data\n     * @param data data\n     */\n    function createStream(\n        bytes memory data\n    ) internal pure returns (uint256 stream) {\n        assembly {\n            stream := mload(0x40)\n            mstore(0x40, add(stream, 64))\n            mstore(stream, data)\n            let length := mload(data)\n            mstore(add(stream, 32), add(data, length))\n        }\n    }\n\n    /** @notice Checks if stream is not empty\n     * @param stream stream\n     */\n    function isNotEmpty(uint256 stream) internal pure returns (bool) {\n        uint256 pos;\n        uint256 finish;\n        assembly {\n            pos := mload(stream)\n            finish := mload(add(stream, 32))\n        }\n        return pos < finish;\n    }\n\n    /** @notice Reads uint8 from the stream\n     * @param stream stream\n     */\n    function readUint8(uint256 stream) internal pure returns (uint8 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 1)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads uint16 from the stream\n     * @param stream stream\n     */\n    function readUint16(uint256 stream) internal pure returns (uint16 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 2)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads uint24 from the stream\n     * @param stream stream\n     */\n    function readUint24(uint256 stream) internal pure returns (uint24 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 3)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads uint32 from the stream\n     * @param stream stream\n     */\n    function readUint32(uint256 stream) internal pure returns (uint32 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 4)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads uint256 from the stream\n     * @param stream stream\n     */\n    function readUint(uint256 stream) internal pure returns (uint256 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 32)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads bytes32 from the stream\n     * @param stream stream\n     */\n    function readBytes32(uint256 stream) internal pure returns (bytes32 res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 32)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads address from the stream\n     * @param stream stream\n     */\n    function readAddress(uint256 stream) internal pure returns (address res) {\n        assembly {\n            let pos := mload(stream)\n            pos := add(pos, 20)\n            res := mload(pos)\n            mstore(stream, pos)\n        }\n    }\n\n    /** @notice Reads bytes from the stream\n     * @param stream stream\n     */\n    function readBytes(\n        uint256 stream\n    ) internal pure returns (bytes memory res) {\n        assembly {\n            let pos := mload(stream)\n            res := add(pos, 32)\n            let length := mload(res)\n            mstore(stream, add(res, length))\n        }\n    }\n}\n\nlibrary Approve {\n    /**\n     * @dev ERC20 approve that correct works with token.approve which returns bool or nothing (USDT for example)\n     * @param token The token targeted by the call.\n     * @param spender token spender\n     * @param amount token amount\n     */\n    function approveStable(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal returns (bool) {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(token.approve.selector, spender, amount)\n        );\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n\n    /**\n     * @dev ERC20 approve that correct works with token.approve which reverts if amount and\n     *      current allowance are not zero simultaniously (USDT for example).\n     *      In second case it tries to set allowance to 0, and then back to amount.\n     * @param token The token targeted by the call.\n     * @param spender token spender\n     * @param amount token amount\n     */\n    function approveSafe(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal returns (bool) {\n        return\n            approveStable(token, spender, amount) ||\n            (approveStable(token, spender, 0) &&\n                approveStable(token, spender, amount));\n    }\n}\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\nstruct StrategyData {\n    uint64 strategyStartDate;\n    uint64 targetPercentage;\n    uint128 balance; // the balance of the strategy that BentoBox thinks is in there\n}\n\n/// @notice A rebasing library\nlibrary RebaseLibrary {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n        }\n    }\n}\n"
    },
    "src/Periphery/LiFuelFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title LiFuelFeeCollector\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for collecting fees for LiFuel\n/// @custom:version 1.0.1\ncontract LiFuelFeeCollector is TransferrableOwnership {\n    /// Errors ///\n    error TransferFailure();\n    error NotEnoughNativeForFees();\n\n    /// Events ///\n    event GasFeesCollected(\n        address indexed token,\n        uint256 indexed chainId,\n        address indexed receiver,\n        uint256 feeAmount\n    );\n\n    event FeesWithdrawn(\n        address indexed token,\n        address indexed to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) TransferrableOwnership(_owner) {}\n\n    /// External Methods ///\n\n    /// @notice Collects gas fees\n    /// @param tokenAddress The address of the token to collect\n    /// @param feeAmount The amount of fees to collect\n    /// @param chainId The chain id of the destination chain\n    /// @param receiver The address to send gas to on the destination chain\n    function collectTokenGasFees(\n        address tokenAddress,\n        uint256 feeAmount,\n        uint256 chainId,\n        address receiver\n    ) external {\n        LibAsset.depositAsset(tokenAddress, feeAmount);\n        emit GasFeesCollected(tokenAddress, chainId, receiver, feeAmount);\n    }\n\n    /// @notice Collects gas fees in native token\n    /// @param chainId The chain id of the destination chain\n    /// @param receiver The address to send gas to on destination chain\n    function collectNativeGasFees(\n        uint256 feeAmount,\n        uint256 chainId,\n        address receiver\n    ) external payable {\n        emit GasFeesCollected(\n            LibAsset.NULL_ADDRESS,\n            chainId,\n            receiver,\n            feeAmount\n        );\n        uint256 amountMinusFees = msg.value - feeAmount;\n        if (amountMinusFees > 0) {\n            (bool success, ) = msg.sender.call{ value: amountMinusFees }(\"\");\n            if (!success) {\n                revert TransferFailure();\n            }\n        }\n    }\n\n    /// @notice Withdraws fees\n    /// @param tokenAddress The address of the token to withdraw fees for\n    function withdrawFees(address tokenAddress) external onlyOwner {\n        uint256 balance = LibAsset.getOwnBalance(tokenAddress);\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit FeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraws fees\n    /// @param tokenAddresses The addresses of the tokens to withdraw fees for\n    function batchWithdrawFees(\n        address[] calldata tokenAddresses\n    ) external onlyOwner {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = LibAsset.getOwnBalance(tokenAddresses[i]);\n            LibAsset.transferAsset(\n                tokenAddresses[i],\n                payable(msg.sender),\n                balance\n            );\n            emit FeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "src/Periphery/Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC20, SafeERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IExecutor } from \"../Interfaces/IExecutor.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { ExternalCallFailed, UnAuthorized } from \"../Errors/GenericErrors.sol\";\n\n/// @title Receiver\n/// @author LI.FI (https://li.fi)\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing\n/// @custom:version 2.0.2\ncontract Receiver is ILiFi, ReentrancyGuard, TransferrableOwnership {\n    using SafeERC20 for IERC20;\n\n    /// Storage ///\n    address public sgRouter;\n    IExecutor public executor;\n    uint256 public recoverGas;\n    address public amarokRouter;\n\n    /// Events ///\n    event StargateRouterSet(address indexed router);\n    event AmarokRouterSet(address indexed router);\n    event ExecutorSet(address indexed executor);\n    event RecoverGasSet(uint256 indexed recoverGas);\n\n    /// Modifiers ///\n    modifier onlySGRouter() {\n        if (msg.sender != sgRouter) {\n            revert UnAuthorized();\n        }\n        _;\n    }\n    modifier onlyAmarokRouter() {\n        if (msg.sender != amarokRouter) {\n            revert UnAuthorized();\n        }\n        _;\n    }\n\n    /// Constructor\n    constructor(\n        address _owner,\n        address _sgRouter,\n        address _amarokRouter,\n        address _executor,\n        uint256 _recoverGas\n    ) TransferrableOwnership(_owner) {\n        owner = _owner;\n        sgRouter = _sgRouter;\n        amarokRouter = _amarokRouter;\n        executor = IExecutor(_executor);\n        recoverGas = _recoverGas;\n        emit StargateRouterSet(_sgRouter);\n        emit AmarokRouterSet(_amarokRouter);\n        emit RecoverGasSet(_recoverGas);\n    }\n\n    /// External Methods ///\n\n    /// @notice Completes a cross-chain transaction with calldata via Amarok facet on the receiving chain.\n    /// @dev This function is called from Amarok Router.\n    /// @param _transferId The unique ID of this transaction (assigned by Amarok)\n    /// @param _amount the amount of bridged tokens\n    /// @param _asset the address of the bridged token\n    /// @param * (unused) the sender of the transaction\n    /// @param * (unused) the domain ID of the src chain\n    /// @param _callData The data to execute\n    function xReceive(\n        bytes32 _transferId,\n        uint256 _amount,\n        address _asset,\n        address,\n        uint32,\n        bytes memory _callData\n    ) external nonReentrant onlyAmarokRouter {\n        (LibSwap.SwapData[] memory swapData, address receiver) = abi.decode(\n            _callData,\n            (LibSwap.SwapData[], address)\n        );\n\n        _swapAndCompleteBridgeTokens(\n            _transferId,\n            swapData,\n            _asset,\n            payable(receiver),\n            _amount,\n            false\n        );\n    }\n\n    /// @notice Completes a cross-chain transaction on the receiving chain.\n    /// @dev This function is called from Stargate Router.\n    /// @param * (unused) The remote chainId sending the tokens\n    /// @param * (unused) The remote Bridge address\n    /// @param * (unused) Nonce\n    /// @param _token The token contract on the local chain\n    /// @param _amountLD The amount of tokens received through bridging\n    /// @param _payload The data to execute\n    function sgReceive(\n        uint16, // _srcChainId unused\n        bytes memory, // _srcAddress unused\n        uint256, // _nonce unused\n        address _token,\n        uint256 _amountLD,\n        bytes memory _payload\n    ) external nonReentrant onlySGRouter {\n        (\n            bytes32 transactionId,\n            LibSwap.SwapData[] memory swapData,\n            ,\n            address receiver\n        ) = abi.decode(\n                _payload,\n                (bytes32, LibSwap.SwapData[], address, address)\n            );\n\n        _swapAndCompleteBridgeTokens(\n            transactionId,\n            swapData,\n            swapData.length > 0 ? swapData[0].sendingAssetId : _token, // If swapping assume sent token is the first token in swapData\n            payable(receiver),\n            _amountLD,\n            true\n        );\n    }\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver\n    ) external payable nonReentrant {\n        if (LibAsset.isNativeAsset(assetId)) {\n            _swapAndCompleteBridgeTokens(\n                _transactionId,\n                _swapData,\n                assetId,\n                receiver,\n                msg.value,\n                false\n            );\n        } else {\n            uint256 allowance = IERC20(assetId).allowance(\n                msg.sender,\n                address(this)\n            );\n            LibAsset.depositAsset(assetId, allowance);\n            _swapAndCompleteBridgeTokens(\n                _transactionId,\n                _swapData,\n                assetId,\n                receiver,\n                allowance,\n                false\n            );\n        }\n    }\n\n    /// @notice Send remaining token to receiver\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    function pullToken(\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    ) external onlyOwner {\n        if (LibAsset.isNativeAsset(assetId)) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = receiver.call{ value: amount }(\"\");\n            if (!success) revert ExternalCallFailed();\n        } else {\n            IERC20(assetId).safeTransfer(receiver, amount);\n        }\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    /// @param reserveRecoverGas whether we need a gas buffer to recover\n    function _swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver,\n        uint256 amount,\n        bool reserveRecoverGas\n    ) private {\n        uint256 _recoverGas = reserveRecoverGas ? recoverGas : 0;\n\n        if (LibAsset.isNativeAsset(assetId)) {\n            // case 1: native asset\n            uint256 cacheGasLeft = gasleft();\n            if (reserveRecoverGas && cacheGasLeft < _recoverGas) {\n                // case 1a: not enough gas left to execute calls\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = receiver.call{ value: amount }(\"\");\n                if (!success) revert ExternalCallFailed();\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 1b: enough gas left to execute calls\n            // solhint-disable no-empty-blocks\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    value: amount,\n                    gas: cacheGasLeft - _recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = receiver.call{ value: amount }(\"\");\n                if (!success) revert ExternalCallFailed();\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n        } else {\n            // case 2: ERC20 asset\n            uint256 cacheGasLeft = gasleft();\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n\n            if (reserveRecoverGas && cacheGasLeft < _recoverGas) {\n                // case 2a: not enough gas left to execute calls\n                token.safeTransfer(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 2b: enough gas left to execute calls\n            token.safeIncreaseAllowance(address(executor), amount);\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    gas: cacheGasLeft - _recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                token.safeTransfer(receiver, amount);\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n\n            token.safeApprove(address(executor), 0);\n        }\n    }\n\n    /// @notice Receive native asset directly.\n    /// @dev Some bridges may send native asset before execute external calls.\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/Periphery/ReceiverStargateV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC20, SafeERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { OFTComposeMsgCodec } from \"../Libraries/OFTComposeMsgCodec.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IExecutor } from \"../Interfaces/IExecutor.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { ExternalCallFailed, UnAuthorized } from \"../Errors/GenericErrors.sol\";\nimport { ITokenMessaging } from \"../Interfaces/IStargate.sol\";\n\ninterface IPool {\n    function token() external view returns (address tokenAddress);\n}\n\ninterface ILayerZeroComposer {\n    /// @notice Composes a LayerZero message from an OApp.\n    /// @param _from The address initiating the composition, typically the OApp where the lzReceive was called.\n    /// @param _guid The unique identifier for the corresponding LayerZero src/dst tx.\n    /// @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.\n    /// @param _executor The address of the executor for the composed message.\n    /// @param _extraData Additional arbitrary data in bytes passed by the entity who executes the lzCompose.\n    function lzCompose(\n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n\n/// @title ReceiverStargateV2\n/// @author LI.FI (https://li.fi)\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing via Stargate V2\n/// @custom:version 1.0.0\ncontract ReceiverStargateV2 is\n    ILiFi,\n    TransferrableOwnership,\n    ILayerZeroComposer\n{\n    using SafeERC20 for IERC20;\n\n    /// Storage ///\n    IExecutor public immutable executor;\n    ITokenMessaging public immutable tokenMessaging;\n    address public immutable endpointV2;\n    uint256 public immutable recoverGas;\n\n    /// Modifiers ///\n    modifier onlyEndpointV2() {\n        if (msg.sender != endpointV2) {\n            revert UnAuthorized();\n        }\n        _;\n    }\n\n    /// Constructor\n    constructor(\n        address _owner,\n        address _executor,\n        address _tokenMessaging,\n        address _endpointV2,\n        uint256 _recoverGas\n    ) TransferrableOwnership(_owner) {\n        owner = _owner;\n        executor = IExecutor(_executor);\n        tokenMessaging = ITokenMessaging(_tokenMessaging);\n        endpointV2 = _endpointV2;\n        recoverGas = _recoverGas;\n    }\n\n    /// External Methods ///\n\n    /// @notice Completes a stargateV2 cross-chain transaction on the receiving chain\n    /// @dev This function is called by Stargate Router via LayerZero endpoint (sendCompose(...) function)\n    /// @param _from The address initiating the composition, typically the OApp where the lzReceive was called\n    /// @param * (unused) The unique identifier for the corresponding LayerZero src/dst tx\n    /// @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive\n    /// @param * (unused) The address of the executor for the composed message\n    /// @param * (unused) Additional arbitrary data in bytes passed by the entity who executes the lzCompose\n    function lzCompose(\n        address _from,\n        bytes32, // _guid (not used)\n        bytes calldata _message,\n        address, // _executor (not used)\n        bytes calldata // _extraData (not used)\n    ) external payable onlyEndpointV2 {\n        // verify that _from address is actually a Stargate pool by checking if Stargate's\n        // TokenMessaging contract has an assetId registered for this address\n        if (tokenMessaging.assetIds(_from) == 0) revert UnAuthorized();\n\n        // get the address of the token that was received from Stargate bridge\n        address bridgedAssetId = IPool(_from).token();\n\n        // decode payload\n        (\n            bytes32 transactionId,\n            LibSwap.SwapData[] memory swapData,\n            address receiver\n        ) = abi.decode(\n                OFTComposeMsgCodec.composeMsg(_message),\n                (bytes32, LibSwap.SwapData[], address)\n            );\n\n        // execute swap(s)\n        _swapAndCompleteBridgeTokens(\n            transactionId,\n            swapData,\n            bridgedAssetId,\n            payable(receiver),\n            OFTComposeMsgCodec.amountLD(_message)\n        );\n    }\n\n    /// @notice Send remaining token to receiver\n    /// @param assetId address of the token to be withdrawn (not to be confused with StargateV2's assetIds which are uint16 values)\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    function pullToken(\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    ) external onlyOwner {\n        if (LibAsset.isNativeAsset(assetId)) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = receiver.call{ value: amount }(\"\");\n            if (!success) revert ExternalCallFailed();\n        } else {\n            IERC20(assetId).safeTransfer(receiver, amount);\n        }\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId address of the token received from the source chain (not to be confused with StargateV2's assetIds which are uint16 values)\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    function _swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    ) private {\n        uint256 cacheGasLeft = gasleft();\n\n        if (LibAsset.isNativeAsset(assetId)) {\n            // case 1: native asset\n            if (cacheGasLeft < recoverGas) {\n                // case 1a: not enough gas left to execute calls\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = receiver.call{ value: amount }(\"\");\n                if (!success) revert ExternalCallFailed();\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 1b: enough gas left to execute calls\n            // solhint-disable no-empty-blocks\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    value: amount,\n                    gas: cacheGasLeft - recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = receiver.call{ value: amount }(\"\");\n                if (!success) revert ExternalCallFailed();\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n        } else {\n            // case 2: ERC20 asset\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n\n            if (cacheGasLeft < recoverGas) {\n                // case 2a: not enough gas left to execute calls\n                token.safeTransfer(receiver, amount);\n\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n                return;\n            }\n\n            // case 2b: enough gas left to execute calls\n            token.safeIncreaseAllowance(address(executor), amount);\n            try\n                executor.swapAndCompleteBridgeTokens{\n                    gas: cacheGasLeft - recoverGas\n                }(_transactionId, _swapData, assetId, receiver)\n            {} catch {\n                token.safeTransfer(receiver, amount);\n                emit LiFiTransferRecovered(\n                    _transactionId,\n                    assetId,\n                    receiver,\n                    amount,\n                    block.timestamp\n                );\n            }\n\n            token.safeApprove(address(executor), 0);\n        }\n    }\n\n    /// @notice Receive native asset directly.\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/Periphery/RelayerCelerIM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC20, SafeERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { ContractCallNotAllowed, ExternalCallFailed, InvalidConfig, UnAuthorized, WithdrawFailed } from \"../Errors/GenericErrors.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { PeripheryRegistryFacet } from \"../Facets/PeripheryRegistryFacet.sol\";\nimport { IExecutor } from \"../Interfaces/IExecutor.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { IMessageReceiverApp } from \"../../lib/sgn-v2-contracts/contracts/message/interfaces/IMessageReceiverApp.sol\";\nimport { CelerIM } from \"../../src/Helpers/CelerIMFacetBase.sol\";\nimport { MessageSenderLib, MsgDataTypes, IMessageBus, IOriginalTokenVault, IPeggedTokenBridge, IOriginalTokenVaultV2, IPeggedTokenBridgeV2 } from \"../../lib/sgn-v2-contracts/contracts/message/libraries/MessageSenderLib.sol\";\nimport { IBridge as ICBridge } from \"../../lib/sgn-v2-contracts/contracts/interfaces/IBridge.sol\";\n\n/// @title RelayerCelerIM\n/// @author LI.FI (https://li.fi)\n/// @notice Relayer contract for CelerIM that forwards calls and handles refunds on src side and acts receiver on dest\n/// @custom:version 2.0.0\ncontract RelayerCelerIM is ILiFi, TransferrableOwnership {\n    using SafeERC20 for IERC20;\n\n    /// Storage ///\n\n    IMessageBus public cBridgeMessageBus;\n    address public diamondAddress;\n\n    /// Events ///\n\n    event LogWithdraw(\n        address indexed _assetAddress,\n        address indexed _to,\n        uint256 amount\n    );\n\n    /// Modifiers ///\n\n    modifier onlyCBridgeMessageBus() {\n        if (msg.sender != address(cBridgeMessageBus)) revert UnAuthorized();\n        _;\n    }\n    modifier onlyDiamond() {\n        if (msg.sender != diamondAddress) revert UnAuthorized();\n        _;\n    }\n\n    /// Constructor\n\n    constructor(\n        address _cBridgeMessageBusAddress,\n        address _owner,\n        address _diamondAddress\n    ) TransferrableOwnership(_owner) {\n        owner = _owner;\n        cBridgeMessageBus = IMessageBus(_cBridgeMessageBusAddress);\n        diamondAddress = _diamondAddress;\n    }\n\n    /// External Methods ///\n\n    /**\n     * @notice Called by MessageBus to execute a message with an associated token transfer.\n     * The Receiver is guaranteed to have received the right amount of tokens before this function is called.\n     * @param * (unused) The address of the source app contract\n     * @param _token The address of the token that comes out of the bridge\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\n     * @param * (unused)  The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param * (unused)  Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransfer(\n        address,\n        address _token,\n        uint256 _amount,\n        uint64,\n        bytes calldata _message,\n        address\n    )\n        external\n        payable\n        onlyCBridgeMessageBus\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        // decode message\n        (\n            bytes32 transactionId,\n            LibSwap.SwapData[] memory swapData,\n            address receiver,\n            address refundAddress\n        ) = abi.decode(\n                _message,\n                (bytes32, LibSwap.SwapData[], address, address)\n            );\n\n        _swapAndCompleteBridgeTokens(\n            transactionId,\n            swapData,\n            _token,\n            payable(receiver),\n            _amount,\n            refundAddress\n        );\n\n        return IMessageReceiverApp.ExecutionStatus.Success;\n    }\n\n    /**\n     * @notice Called by MessageBus to process refund of the original transfer from this contract.\n     * The contract is guaranteed to have received the refund before this function is called.\n     * @param _token The token address of the original transfer\n     * @param _amount The amount of the original transfer\n     * @param _message The same message associated with the original transfer\n     * @param * (unused) Address who called the MessageBus execution function\n     */\n    function executeMessageWithTransferRefund(\n        address _token,\n        uint256 _amount,\n        bytes calldata _message,\n        address\n    )\n        external\n        payable\n        onlyCBridgeMessageBus\n        returns (IMessageReceiverApp.ExecutionStatus)\n    {\n        (bytes32 transactionId, , , address refundAddress) = abi.decode(\n            _message,\n            (bytes32, LibSwap.SwapData[], address, address)\n        );\n\n        // return funds to cBridgeData.refundAddress\n        LibAsset.transferAsset(_token, payable(refundAddress), _amount);\n\n        emit LiFiTransferRecovered(\n            transactionId,\n            _token,\n            refundAddress,\n            _amount,\n            block.timestamp\n        );\n\n        return IMessageReceiverApp.ExecutionStatus.Success;\n    }\n\n    /**\n     * @notice Forwards a call to transfer tokens to cBridge (sent via this contract to ensure that potential refunds are sent here)\n     * @param _bridgeData the core information needed for bridging\n     * @param _celerIMData data specific to CelerIM\n     */\n    // solhint-disable-next-line code-complexity\n    function sendTokenTransfer(\n        ILiFi.BridgeData memory _bridgeData,\n        CelerIM.CelerIMData calldata _celerIMData\n    )\n        external\n        payable\n        onlyDiamond\n        returns (bytes32 transferId, address bridgeAddress)\n    {\n        // approve to and call correct bridge depending on BridgeSendType\n        // @dev copied and slightly adapted from Celer MessageSenderLib\n        if (_celerIMData.bridgeType == MsgDataTypes.BridgeSendType.Liquidity) {\n            bridgeAddress = cBridgeMessageBus.liquidityBridge();\n            if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n                // case: native asset bridging\n                ICBridge(bridgeAddress).sendNative{\n                    value: _bridgeData.minAmount\n                }(\n                    _bridgeData.receiver,\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _celerIMData.nonce,\n                    _celerIMData.maxSlippage\n                );\n            } else {\n                // case: ERC20 asset bridging\n                LibAsset.maxApproveERC20(\n                    IERC20(_bridgeData.sendingAssetId),\n                    bridgeAddress,\n                    _bridgeData.minAmount\n                );\n                // solhint-disable-next-line check-send-result\n                ICBridge(bridgeAddress).send(\n                    _bridgeData.receiver,\n                    _bridgeData.sendingAssetId,\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _celerIMData.nonce,\n                    _celerIMData.maxSlippage\n                );\n            }\n            transferId = MessageSenderLib.computeLiqBridgeTransferId(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegDeposit\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegVault();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            IOriginalTokenVault(bridgeAddress).deposit(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n            transferId = MessageSenderLib.computePegV1DepositId(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegBurn\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegBridge();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            IPeggedTokenBridge(bridgeAddress).burn(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n            transferId = MessageSenderLib.computePegV1BurnId(\n                _bridgeData.receiver,\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegV2Deposit\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegVaultV2();\n            if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId)) {\n                // case: native asset bridging\n                transferId = IOriginalTokenVaultV2(bridgeAddress)\n                    .depositNative{ value: _bridgeData.minAmount }(\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _bridgeData.receiver,\n                    _celerIMData.nonce\n                );\n            } else {\n                // case: ERC20 bridging\n                LibAsset.maxApproveERC20(\n                    IERC20(_bridgeData.sendingAssetId),\n                    bridgeAddress,\n                    _bridgeData.minAmount\n                );\n                transferId = IOriginalTokenVaultV2(bridgeAddress).deposit(\n                    _bridgeData.sendingAssetId,\n                    _bridgeData.minAmount,\n                    uint64(_bridgeData.destinationChainId),\n                    _bridgeData.receiver,\n                    _celerIMData.nonce\n                );\n            }\n        } else if (\n            _celerIMData.bridgeType == MsgDataTypes.BridgeSendType.PegV2Burn\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegBridgeV2();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            transferId = IPeggedTokenBridgeV2(bridgeAddress).burn(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n        } else if (\n            _celerIMData.bridgeType ==\n            MsgDataTypes.BridgeSendType.PegV2BurnFrom\n        ) {\n            bridgeAddress = cBridgeMessageBus.pegBridgeV2();\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                bridgeAddress,\n                _bridgeData.minAmount\n            );\n            transferId = IPeggedTokenBridgeV2(bridgeAddress).burnFrom(\n                _bridgeData.sendingAssetId,\n                _bridgeData.minAmount,\n                uint64(_bridgeData.destinationChainId),\n                _bridgeData.receiver,\n                _celerIMData.nonce\n            );\n        } else {\n            revert InvalidConfig();\n        }\n    }\n\n    /**\n     * @notice Forwards a call to the CBridge Messagebus\n     * @param _receiver The address of the destination app contract.\n     * @param _dstChainId The destination chain ID.\n     * @param _srcBridge The bridge contract to send the transfer with.\n     * @param _srcTransferId The transfer ID.\n     * @param _dstChainId The destination chain ID.\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\n     */\n    function forwardSendMessageWithTransfer(\n        address _receiver,\n        uint256 _dstChainId,\n        address _srcBridge,\n        bytes32 _srcTransferId,\n        bytes calldata _message\n    ) external payable onlyDiamond {\n        cBridgeMessageBus.sendMessageWithTransfer{ value: msg.value }(\n            _receiver,\n            _dstChainId,\n            _srcBridge,\n            _srcTransferId,\n            _message\n        );\n    }\n\n    // ------------------------------------------------------------------------------------------------\n\n    /// Private Methods ///\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swapData array of data needed for swaps\n    /// @param assetId token received from the other chain\n    /// @param receiver address that will receive tokens in the end\n    /// @param amount amount of token\n    function _swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver,\n        uint256 amount,\n        address refundAddress\n    ) private {\n        bool success;\n        IExecutor executor = IExecutor(\n            PeripheryRegistryFacet(diamondAddress).getPeripheryContract(\n                \"Executor\"\n            )\n        );\n        if (LibAsset.isNativeAsset(assetId)) {\n            try\n                executor.swapAndCompleteBridgeTokens{ value: amount }(\n                    _transactionId,\n                    _swapData,\n                    assetId,\n                    receiver\n                )\n            {\n                success = true;\n            } catch {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool fundsSent, ) = refundAddress.call{ value: amount }(\"\");\n                if (!fundsSent) {\n                    revert ExternalCallFailed();\n                }\n            }\n        } else {\n            IERC20 token = IERC20(assetId);\n            token.safeApprove(address(executor), 0);\n            token.safeIncreaseAllowance(address(executor), amount);\n\n            try\n                executor.swapAndCompleteBridgeTokens(\n                    _transactionId,\n                    _swapData,\n                    assetId,\n                    receiver\n                )\n            {\n                success = true;\n            } catch {\n                token.safeTransfer(refundAddress, amount);\n            }\n            token.safeApprove(address(executor), 0);\n        }\n\n        if (!success) {\n            emit LiFiTransferRecovered(\n                _transactionId,\n                assetId,\n                refundAddress,\n                amount,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @notice Sends remaining token to given receiver address (for refund cases)\n    /// @param assetId Address of the token to be withdrawn\n    /// @param receiver Address that will receive tokens\n    /// @param amount Amount of tokens to be withdrawn\n    function withdraw(\n        address assetId,\n        address payable receiver,\n        uint256 amount\n    ) external onlyOwner {\n        if (LibAsset.isNativeAsset(assetId)) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = receiver.call{ value: amount }(\"\");\n            if (!success) {\n                revert WithdrawFailed();\n            }\n        } else {\n            IERC20(assetId).safeTransfer(receiver, amount);\n        }\n        emit LogWithdraw(assetId, receiver, amount);\n    }\n\n    /// @notice Triggers a cBridge refund with calldata produced by cBridge API\n    /// @param _callTo The address to execute the calldata on\n    /// @param _callData The data to execute\n    /// @param _assetAddress Asset to be withdrawn\n    /// @param _to Address to withdraw to\n    /// @param _amount Amount of asset to withdraw\n    function triggerRefund(\n        address payable _callTo,\n        bytes calldata _callData,\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        bool success;\n\n        // make sure that callTo address is either of the cBridge addresses\n        if (\n            cBridgeMessageBus.liquidityBridge() != _callTo &&\n            cBridgeMessageBus.pegBridge() != _callTo &&\n            cBridgeMessageBus.pegBridgeV2() != _callTo &&\n            cBridgeMessageBus.pegVault() != _callTo &&\n            cBridgeMessageBus.pegVaultV2() != _callTo\n        ) {\n            revert ContractCallNotAllowed();\n        }\n\n        // call contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ) = _callTo.call(_callData);\n\n        // forward funds to _to address and emit event, if cBridge refund successful\n        if (success) {\n            address sendTo = (LibUtil.isZeroAddress(_to)) ? msg.sender : _to;\n            LibAsset.transferAsset(_assetAddress, payable(sendTo), _amount);\n            emit LogWithdraw(_assetAddress, sendTo, _amount);\n        } else {\n            revert WithdrawFailed();\n        }\n    }\n\n    // required in order to receive native tokens from cBridge facet\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "src/Periphery/ServiceFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title Service Fee Collector\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for collecting service fees (gas/insurance)\n/// @custom:version 1.0.1\ncontract ServiceFeeCollector is TransferrableOwnership {\n    /// Errors ///\n    error TransferFailure();\n    error NotEnoughNativeForFees();\n\n    /// Events ///\n    event GasFeesCollected(\n        address indexed token,\n        uint256 indexed chainId,\n        address indexed receiver,\n        uint256 feeAmount\n    );\n\n    event InsuranceFeesCollected(\n        address indexed token,\n        address indexed receiver,\n        uint256 feeAmount\n    );\n\n    event FeesWithdrawn(\n        address indexed token,\n        address indexed to,\n        uint256 amount\n    );\n\n    /// Constructor ///\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) TransferrableOwnership(_owner) {}\n\n    /// External Methods ///\n\n    /// @notice Collects insurance fees\n    /// @param tokenAddress The address of the token to collect\n    /// @param feeAmount The amount of fees to collect\n    /// @param receiver The address to insure\n    function collectTokenInsuranceFees(\n        address tokenAddress,\n        uint256 feeAmount,\n        address receiver\n    ) external {\n        LibAsset.depositAsset(tokenAddress, feeAmount);\n        emit InsuranceFeesCollected(tokenAddress, receiver, feeAmount);\n    }\n\n    /// @notice Collects insurance fees in native token\n    /// @param receiver The address to insure\n    function collectNativeInsuranceFees(address receiver) external payable {\n        emit InsuranceFeesCollected(\n            LibAsset.NULL_ADDRESS,\n            receiver,\n            msg.value\n        );\n    }\n\n    /// @notice Withdraws fees\n    /// @param tokenAddress The address of the token to withdraw fees for\n    function withdrawFees(address tokenAddress) external onlyOwner {\n        uint256 balance = LibAsset.getOwnBalance(tokenAddress);\n        LibAsset.transferAsset(tokenAddress, payable(msg.sender), balance);\n        emit FeesWithdrawn(tokenAddress, msg.sender, balance);\n    }\n\n    /// @notice Batch withdraws fees\n    /// @param tokenAddresses The addresses of the tokens to withdraw fees for\n    function batchWithdrawFees(\n        address[] calldata tokenAddresses\n    ) external onlyOwner {\n        uint256 length = tokenAddresses.length;\n        uint256 balance;\n        for (uint256 i = 0; i < length; ) {\n            balance = LibAsset.getOwnBalance(tokenAddresses[i]);\n            LibAsset.transferAsset(\n                tokenAddresses[i],\n                payable(msg.sender),\n                balance\n            );\n            emit FeesWithdrawn(tokenAddresses[i], msg.sender, balance);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "src/Periphery/TokenWrapper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { IERC20 } from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// External wrapper interface\ninterface IWrapper {\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n}\n\n/// @title TokenWrapper\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for wrapping and unwrapping tokens\n/// @custom:version 1.0.0\ncontract TokenWrapper {\n    uint256 private constant MAX_INT = 2 ** 256 - 1;\n    address public wrappedToken;\n\n    /// Errors ///\n    error WithdrawFailure();\n\n    /// Constructor ///\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _wrappedToken) {\n        wrappedToken = _wrappedToken;\n        IERC20(wrappedToken).approve(address(this), MAX_INT);\n    }\n\n    /// External Methods ///\n\n    /// @notice Wraps the native token\n    function deposit() external payable {\n        IWrapper(wrappedToken).deposit{ value: msg.value }();\n        IERC20(wrappedToken).transfer(msg.sender, msg.value);\n    }\n\n    /// @notice Unwraps all the caller's balance of wrapped token\n    function withdraw() external {\n        // While in a general purpose contract it would make sense\n        // to have `wad` equal to the minimum between the balance and the\n        // given allowance, in our specific usecase allowance is always\n        // nearly MAX_UINT256. Using the balance only is a gas optimisation.\n        uint256 wad = IERC20(wrappedToken).balanceOf(msg.sender);\n        IERC20(wrappedToken).transferFrom(msg.sender, address(this), wad);\n        IWrapper(wrappedToken).withdraw(wad);\n        (bool success, ) = payable(msg.sender).call{ value: wad }(\"\");\n        if (!success) {\n            revert WithdrawFailure();\n        }\n    }\n\n    // Needs to be able to receive native on `withdraw`\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "mode": "3"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.methodIdentifiers",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031373237333130383730333638"
      }
    }
  }
}