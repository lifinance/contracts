name: Permit2 Bytecode Verifier
# - detects newly added permit2 addresses in config/permit2Proxy.json
# - runs address-specific verification via a dedicated Bash script
# - verifies only the newly added entries (not full file scan)
# - exits with error if any check fails

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read

jobs:
  verify-permit2-addresses:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if config/permit2Proxy.json was changed in this branch
        id: check-file-change
        run: |
          if git diff --name-only origin/main...HEAD | grep -q "config/permit2Proxy.json"; then
            echo "config/permit2Proxy.json has been modified in this branch"
            echo "CONTINUE=true" >> $GITHUB_ENV
          else
            echo "No changes in config/permit2Proxy.json detected in this branch"
            echo "CONTINUE=false" >> $GITHUB_ENV
          fi

      - name: Detect New or Changed Permit2 Addresses
        if: env.CONTINUE == 'true'
        id: detect-changes
        run: |
          echo "Comparing config/permit2Proxy.json with main branch..."

          git fetch origin main --depth=1

          # Fallback if no previous version exists
          if git show origin/main:config/permit2Proxy.json > /dev/null 2>&1; then
            git show origin/main:config/permit2Proxy.json | jq -r 'to_entries[] | "\(.key)=\(.value)"' | sort > old.txt
          else
            echo "# fallback: no old file" > old.txt
          fi

          # Current version
          jq -r 'to_entries[] | "\(.key)=\(.value)"' config/permit2Proxy.json | sort > new.txt

          # Get lines only in new or changed (i.e., not in old)
          comm -13 old.txt new.txt > changed_lines.txt

          if [ ! -s changed_lines.txt ]; then
            echo "No new or updated permit2 addresses detected."
            echo "SKIP_CHECK=true" >> $GITHUB_ENV
          else
            echo "Found changed entries:"
            cat changed_lines.txt

            # Extract keys only
            CHANGED_NETWORKS=$(cut -d= -f1 changed_lines.txt | jq -R . | jq -cs .)
            echo "CHANGED_NETWORKS=$CHANGED_NETWORKS" >> $GITHUB_ENV
          fi

      - name: Install Foundry (provides forge and cast)
        if: env.CONTINUE == 'true' && env.SKIP_CHECK != 'true'
        uses: foundry-rs/foundry-toolchain@v1.3.1

      - name: Install Bun
        if: env.CONTINUE == 'true' && env.SKIP_CHECK != 'true'
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies (includes jq via preinstall.sh)
        if: env.CONTINUE == 'true' && env.SKIP_CHECK != 'true'
        run: |
          bun install
          forge install

      - name: Strip etherscan section from foundry.toml in CI
        run: sed -i '/^\[etherscan\]/,/^$/d' foundry.toml

      - name: Fetch RPC endpoints from MongoDB
        if: env.CONTINUE == 'true' && env.SKIP_CHECK != 'true'
        run: |
          echo "Fetching prioritized RPCs..."
          bun fetch-rpcs
        env:
          MONGODB_URI: ${{ secrets.MONGODB_URI }}

      - name: Create config.sh from config.example.sh (required by helperfunctions.sh)
        if: env.CONTINUE == 'true' && env.SKIP_CHECK != 'true'
        run: |
          cp script/config.example.sh script/config.sh

      - name: Run Permit2 Verification for New Networks
        if: env.CONTINUE == 'true' && env.SKIP_CHECK != 'true'
        run: |
          echo "Running permit2 verification for new addresses..."
          set -e
          for NETWORK in $(echo $CHANGED_NETWORKS | jq -r '.[]'); do
            echo "üîç Verifying permit2 address for network: $NETWORK"
            if ./script/utils/permit2/verifyPermit2Bytecode.sh "$NETWORK"; then
              echo "‚úÖ $NETWORK verified successfully."
            else
              echo "‚ùå Verification failed for $NETWORK. Exiting..."
              exit 1
            fi
          done
