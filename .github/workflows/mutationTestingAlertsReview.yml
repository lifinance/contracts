name: Mutation Testing PR Summary

# - generates a PR comment summary of mutation testing results from GitHub Code Scanning
# - lists surviving mutants (test coverage gaps) found in the changed files
# - shows how many mutants were dismissed with proper justification
# - reports net unresolved findings that need attention
# - provides a clear overview of test coverage quality for the PR
# - leaves a summary comment starting with "üß™ Mutation Testing Summary"

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review
    paths:
      - 'src/**/*.sol'
  workflow_run:
    workflows: ["Olympix Mutation Testing"]
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: read # required to fetch repository contents
  pull-requests: write # required to post, update PR comments & revert PR to draft
  security-events: read # required to fetch code scanning alerts
  issues: write # required to post comments via the GitHub Issues API (used for PR comments)

jobs:
  mutation-testing-summary:
    runs-on: ubuntu-latest

    steps:

      - uses: actions/checkout@v4

      - name: Get PR Number
        id: get_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Try to get PR number from different contexts
          PR_NUMBER=""
          
          # If triggered by pull_request event
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            PR_NUMBER="${{ github.event.number }}"
            echo "PR number from pull_request event: $PR_NUMBER"
          
          # If triggered by workflow_run or workflow_dispatch, search for PR
          elif [ -n "${{ github.sha }}" ]; then
            echo "Searching for PR associated with commit ${{ github.sha }}"
            SEARCH_RESULT=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
              "https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:${{ github.ref_name }}")
            
            PR_NUMBER=$(echo "$SEARCH_RESULT" | jq -r '.[0].number // empty')
            echo "PR number from API search: $PR_NUMBER"
          fi
          
          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" == "null" ]; then
            echo "Error: No pull request found for this trigger." >&2
            exit 1
          fi
          
          echo "Using PR number: $PR_NUMBER"
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV

      - name: Fetch Mutation Testing Results for PR
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching mutation testing results for PR #${PR_NUMBER}..."

          # Fetch mutation testing results from GitHub Code Scanning
          echo "Fetching alerts for PR #${PR_NUMBER}..."
          MUTATIONS_PR=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${{ github.repository }}/code-scanning/alerts?pr=${PR_NUMBER}")
          
          echo "PR-specific API response:"
          echo "$MUTATIONS_PR" | head -10
          
          # Also fetch all recent alerts to compare
          echo "Fetching all recent alerts..."
          MUTATIONS_ALL=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${{ github.repository }}/code-scanning/alerts?per_page=100&state=open")
          
          echo "All alerts API response:"
          echo "$MUTATIONS_ALL" | head -10
          
          # Also try fetching by commit SHA
          echo "Fetching alerts for commit ${{ github.sha }}..."
          MUTATIONS_COMMIT=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${{ github.repository }}/code-scanning/alerts?ref=${{ github.sha }}&per_page=100")
          
          echo "Commit-specific API response:"
          echo "$MUTATIONS_COMMIT" | head -10
          
          # Use the source with the most results
          PR_COUNT=$(echo "$MUTATIONS_PR" | jq 'length // 0')
          ALL_COUNT=$(echo "$MUTATIONS_ALL" | jq 'length // 0')
          COMMIT_COUNT=$(echo "$MUTATIONS_COMMIT" | jq 'length // 0')
          
          echo "PR alerts: $PR_COUNT, All alerts: $ALL_COUNT, Commit alerts: $COMMIT_COUNT"
          
          # Show what's in each response for debugging
          if [[ $PR_COUNT -gt 0 ]]; then
            echo "PR response tools:"
            echo "$MUTATIONS_PR" | jq -r '.[] | .tool.name' | head -5
          fi
          if [[ $ALL_COUNT -gt 0 ]]; then
            echo "All alerts tools:"
            echo "$MUTATIONS_ALL" | jq -r '.[] | .tool.name' | head -5
          fi
          if [[ $COMMIT_COUNT -gt 0 ]]; then
            echo "Commit alerts tools:"
            echo "$MUTATIONS_COMMIT" | jq -r '.[] | .tool.name' | head -5
          fi
          
          if [[ $PR_COUNT -gt 0 ]]; then
            MUTATIONS="$MUTATIONS_PR"
            echo "Using PR-specific alerts ($PR_COUNT results)"
          elif [[ $COMMIT_COUNT -gt 0 ]]; then
            MUTATIONS="$MUTATIONS_COMMIT"
            echo "Using commit-specific alerts ($COMMIT_COUNT results)"
          else
            MUTATIONS="$MUTATIONS_ALL"
            echo "Using all recent alerts ($ALL_COUNT results)"
          fi

          echo "Filtering to Olympix Mutation Testing results only"
          
          # Debug: Show what tools are available
          echo "Available tools in alerts:"
          echo "$MUTATIONS" | jq -r '.[] | .tool.name' | sort | uniq -c || echo "No tools found"
          
          # Filter specifically for "Olympix Mutation Testing"
          echo "Filtering for tool name: 'Olympix Mutation Testing'"
          
          # Show first few alerts for debugging
          echo "Sample alerts (first 3):"
          echo "$MUTATIONS" | jq -c '.[:3] | .[] | {tool_name: .tool.name, rule_id: .rule.id, state: .state, file: .most_recent_instance.location.path}' || echo "No alerts to sample"
          
          MUTATIONS=$(echo "$MUTATIONS" | jq -c '[ .[] | select(.tool.name == "Olympix Mutation Testing") ]' || echo "[]")
          
          MUTATION_COUNT=$(echo "$MUTATIONS" | jq 'length')
          echo "Found $MUTATION_COUNT Olympix Mutation Testing alerts"

          # Extract surviving mutants (open - test coverage gaps)
          SURVIVING_MUTANTS=$(echo "$MUTATIONS" | jq -c '[.[] | select(.state == "open") ]' || echo "[]")
          # Extract dismissed mutants (acknowledged coverage gaps)
          DISMISSED_MUTANTS=$(echo "$MUTATIONS" | jq -c '[.[] | select(.state == "dismissed")]' || echo "[]")

          SURVIVING_COUNT=$(echo "$SURVIVING_MUTANTS" | jq -r 'length')
          DISMISSED_COUNT=$(echo "$DISMISSED_MUTANTS" | jq -r 'length')
          TOTAL_MUTANTS=$((SURVIVING_COUNT + DISMISSED_COUNT))

          # Output for debugging
          echo "SURVIVING_MUTANTS: $SURVIVING_MUTANTS"
          echo "DISMISSED_MUTANTS: $DISMISSED_MUTANTS"
          echo "SURVIVING_COUNT: $SURVIVING_COUNT"
          echo "DISMISSED_COUNT: $DISMISSED_COUNT"
          echo "TOTAL_MUTANTS: $TOTAL_MUTANTS"

          # Save values in the environment - limit data to prevent argument list too long
          # Only save first 50 of each type to avoid shell limits
          SURVIVING_MUTANTS_LIMITED=$(echo "$SURVIVING_MUTANTS" | jq -c '.[:50]')
          DISMISSED_MUTANTS_LIMITED=$(echo "$DISMISSED_MUTANTS" | jq -c '.[:50]')
          
          echo "SURVIVING_MUTANTS=$SURVIVING_MUTANTS_LIMITED" >> $GITHUB_ENV
          echo "DISMISSED_MUTANTS=$DISMISSED_MUTANTS_LIMITED" >> $GITHUB_ENV
          echo "SURVIVING_COUNT=$SURVIVING_COUNT" >> $GITHUB_ENV
          echo "DISMISSED_COUNT=$DISMISSED_COUNT" >> $GITHUB_ENV
          echo "TOTAL_MUTANTS=$TOTAL_MUTANTS" >> $GITHUB_ENV
          
          if [[ $SURVIVING_COUNT -gt 50 ]]; then
            echo "Note: Limiting display to first 50 surviving mutants (total: $SURVIVING_COUNT)"
          fi
          if [[ $DISMISSED_COUNT -gt 50 ]]; then
            echo "Note: Limiting display to first 50 dismissed mutants (total: $DISMISSED_COUNT)"
          fi

      - name: Find Existing PR Comment
        id: find_comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Searching for existing PR comment..."

          # Get comments with error handling - limit to recent comments only
          COMMENTS_RESPONSE=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments?per_page=20&sort=updated&direction=desc")
          
          echo "Recent comments count: $(echo "$COMMENTS_RESPONSE" | jq 'length // 0')"
          
          # Check if response is valid JSON array
          if echo "$COMMENTS_RESPONSE" | jq -e '. | type == "array"' > /dev/null 2>&1; then
            COMMENT_ID=$(echo "$COMMENTS_RESPONSE" | jq -r \
              '.[] | select(.body | startswith("## üß™ Mutation Testing Summary")) | .id // empty' | head -1)
          else
            echo "Warning: Invalid JSON response from comments API"
            COMMENT_ID=""
          fi

          if [[ -n "$COMMENT_ID" && "$COMMENT_ID" != "null" ]]; then
            echo "EXISTING_COMMENT_ID=$COMMENT_ID" >> $GITHUB_ENV
            echo "Found existing comment ID: $COMMENT_ID"
          else
            echo "No existing comment found"
          fi

      - name: Post or Update PR Comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create comment body with proper line breaks using printf
          if [[ "$TOTAL_MUTANTS" -gt 0 ]]; then
            KILLED_COUNT=$((TOTAL_MUTANTS - SURVIVING_COUNT))
            MUTATION_SCORE=$(( (KILLED_COUNT * 100) / TOTAL_MUTANTS ))
            
            # Determine status emoji and message based on score
            if [[ $MUTATION_SCORE -ge 80 ]]; then
              STATUS_EMOJI="‚úÖ"
              STATUS_TEXT="Excellent"
            elif [[ $MUTATION_SCORE -ge 60 ]]; then
              STATUS_EMOJI="üü°"
              STATUS_TEXT="Good"
            elif [[ $MUTATION_SCORE -ge 40 ]]; then
              STATUS_EMOJI="üü†"
              STATUS_TEXT="Needs Improvement"
            else
              STATUS_EMOJI="üî¥"
              STATUS_TEXT="Critical"
            fi
            
            COMMENT_BODY=$(printf -- "### üß™ Olympix Mutation Testing Analysis\n\n")
            COMMENT_BODY+=$(printf -- "| Metric | Value | Status |\n")
            COMMENT_BODY+=$(printf -- "|--------|-------|--------|\n")
            COMMENT_BODY+=$(printf -- "| **Mutation Score** | **%s%%** | %s %s |\n" "$MUTATION_SCORE" "$STATUS_EMOJI" "$STATUS_TEXT")
            COMMENT_BODY+=$(printf -- "| **Mutants Killed** | %s/%s | üéØ |\n" "$KILLED_COUNT" "$TOTAL_MUTANTS")
            COMMENT_BODY+=$(printf -- "| **Coverage Gaps** | %s | ‚ö†Ô∏è |\n\n" "$SURVIVING_COUNT")
          else
            COMMENT_BODY=$(printf -- "### üß™ Olympix Mutation Testing Analysis\n\n")
            COMMENT_BODY+=$(printf -- "‚ÑπÔ∏è **No mutation testing results found for this PR.**\n\n")
          fi

                    # Professional footer with action items
          if [[ "$SURVIVING_COUNT" -gt 0 ]]; then
            COMMENT_BODY+=$(printf -- "#### üîç **Action Required**\n")
            COMMENT_BODY+=$(printf -- "Review and address surviving mutants to improve test coverage quality.\n\n")
            COMMENT_BODY+=$(printf -- "**üìã Next Steps:**\n")
            COMMENT_BODY+=$(printf -- "‚Ä¢ View detailed findings in [Security > Code Scanning](../../security/code-scanning?tool=Olympix%%20Mutation%%20Testing)\n")
            COMMENT_BODY+=$(printf -- "‚Ä¢ Add test cases to kill surviving mutants\n")
            COMMENT_BODY+=$(printf -- "‚Ä¢ Dismiss mutants with proper justification if appropriate\n\n")
          else
            COMMENT_BODY+=$(printf -- "#### ‚úÖ **Test Coverage Excellence**\n")
            COMMENT_BODY+=$(printf -- "All mutation tests passed! Your test suite effectively validates the code behavior.\n\n")
          fi
          
          COMMENT_BODY+=$(printf -- "---\n")
          COMMENT_BODY+=$(printf -- "*üõ°Ô∏è Powered by Olympix Security Platform*\n")

          # Properly escape JSON for API call
          COMMENT_JSON=$(jq -n --arg body "$COMMENT_BODY" '{body: $body}')
          
          # Update existing comment if found; otherwise, post a new one.
          if [[ -n "$EXISTING_COMMENT_ID" ]]; then
            echo "Updating existing comment ID: $EXISTING_COMMENT_ID"
            RESPONSE=$(echo "$COMMENT_JSON" | curl -s -X PATCH -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" \
              -d @- \
              "https://api.github.com/repos/${{ github.repository }}/issues/comments/${EXISTING_COMMENT_ID}")
            echo "Update response: $RESPONSE"
          else
            echo "Posting new comment to PR..."
            RESPONSE=$(echo "$COMMENT_JSON" | curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" \
              -d @- \
              "https://api.github.com/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments")
            echo "Post response: $RESPONSE"
          fi

 